"use strict";(globalThis.webpackChunk_coral_xyz_app_extension=globalThis.webpackChunk_coral_xyz_app_extension||[]).push([[3748],{461763:(t,e,n)=>{n.d(e,{Q6:()=>i,fC:()=>s,iw:()=>a,u5:()=>r});const a=BigInt("4000000"),s=BigInt("20000000"),r=(BigInt("750000"),BigInt("825000"),BigInt("50000000000")),i=BigInt("1000")},733748:(t,e,n)=>{n.d(e,{G:()=>ye});var a=n(817967),s=n(801384),r=n(660026),i=n(883739),o=n(602267);class c{config;networkConfig}var l=n(44171),d=n(152010);const u=BigInt(2e3),m=(BigInt(1e4),BigInt(1e5)),p=BigInt(15e4),h=BigInt(100),g=BigInt(2e5);var f=n(348834).Buffer;class w extends c{blockchain;provider;secureAptosVmClient;prefetchedAssets={};constructor(t,e){super(),this.secureAptosVmClient=new r.f(t),this.blockchain=e.blockchain,this.config=(0,i.X2)(a.$O.APTOS),this.networkConfig=e;const n=new s.ScN({network:s.ZcK.MAINNET,clientConfig:{WITH_CREDENTIALS:!1},...e.rpcUrl&&{fullnode:e.rpcUrl}});this.provider=new s.gZG(n)}getProvider(){return this.provider}async fetchBalances(t){return await Promise.all(t.publicKeys.map((async(t,e)=>{try{const n=await this.provider.getAccountAPTAmount({accountAddress:t}),a=BigInt(n);let s=a;return s>u?s-=u:s=BigInt(0),{publicKey:t,balance:a,transferrableBalance:s,index:e}}catch(n){return{publicKey:t,balance:BigInt(0),transferrableBalance:BigInt(0),index:e}}})))}async estimateGas(t){throw new Error("Method not implemented. Use simTransaction instead.")}async validateAddress(t){if(!s.kxK.isValid({input:t}).valid)return{isValid:!1,isWallet:!1};try{const e=await this.provider.getAccountAPTAmount({accountAddress:t});return{isValid:!0,isWallet:!0,funded:BigInt(e)>BigInt(0),publicKey:t,isTokenMintAddress:!1}}catch(e){return{isValid:!0,isWallet:!1,funded:!1,publicKey:t,rpcFailed:!0}}}async transferAsset(t){const{from:e,to:n,amount:a}=t;try{const r=s.kxK.isValid({input:e.publicKey}),i=s.kxK.isValid({input:n.publicKey});if(!r.valid)throw new Error("Invalid sender address format");if(!i.valid)throw new Error("Invalid recipient address format");const c=await this.getAssetById(t);if(!c)throw new Error("Asset not available");let l;if("TokenBalance"===c.__typename)l=c.contractAddress===this.networkConfig.gasCurrencyAddress?{function:"0x1::aptos_account::transfer",functionArguments:[n.publicKey,a.toString()]}:"v1"===(await this.provider.getFungibleAssetMetadataByAssetType({assetType:c.contractAddress})).token_standard?{function:"0x1::coin::transfer",typeArguments:[c.contractAddress],functionArguments:[n.publicKey,a.toString()]}:{function:"0x1::primary_fungible_store::transfer",typeArguments:["0x1::object::ObjectCore"],functionArguments:[c.contractAddress,n.publicKey,a.toString()]};else{if("Nft"!==c.__typename)throw new Error("Unsupported asset type for transfer");l={function:"0x1::object::transfer",typeArguments:["0x1::object::ObjectCore"],functionArguments:[c.tokenId,n.publicKey]}}const d=await this.buildTransaction(e.publicKey,l),{signature:u,tx:m}=await(0,o.W)(this.secureAptosVmClient.signTransaction({tx:f.from(d.bcsToBytes()).toString("base64"),publicKey:e.publicKey,blockchainId:this.networkConfig.blockchainId},{uiOptions:{relevantAccounts:[e.publicKey,n.publicKey]},transactionType:t.transactionType}));return await this.executeTransaction({signedTx:m,signature:u})}catch(t){throw new Error(`Transfer failed: ${t||"Unknown error"}`)}}async executeSwap(t,e){try{const n=await this.buildTransaction(t,JSON.parse(e)),{signature:a,tx:s}=await(0,o.W)(this.secureAptosVmClient.signTransaction({tx:f.from(n.bcsToBytes()).toString("base64"),publicKey:t,blockchainId:this.networkConfig.blockchainId},{uiOptions:{relevantAccounts:[t]}}));return await this.executeTransaction({signedTx:s,signature:a})}catch(t){throw new Error(`Swap failed: ${t||"Unknown error"}`)}}async burnAsset(t){throw new Error("Method not implemented.")}async confirmTransaction(t){await new Promise((t=>setTimeout(t,1e3)));try{const e=await this.provider.waitForTransaction({transactionHash:t});if(!e)throw new Error("Unable to confirm transaction");if(t!==e.hash)throw new Error("Transaction hash mismatch");return!0}catch(t){throw new Error(`Transaction confirmation failed: ${t.message||t}`)}}async buildTransaction(t,e,n){return await this.provider.transaction.build.simple({sender:t,data:e,options:n})}async executeTransaction({signedTx:t,signature:e}){try{const n=f.from(t,"base64"),a=f.from(e,"base64"),r=s._tO.deserialize(new s.ZKs(n)),i=s.LLd.deserialize(new s.ZKs(a));return(await this.provider.transaction.submit.simple({transaction:r,senderAuthenticator:i})).hash}catch(t){throw new Error(`Transaction execution failed: ${t||"Unknown error"}`)}}async simTransaction({tx:t}){try{const e=f.from(t,"base64"),n=s._tO.deserialize(new s.ZKs(e)),a=await this.provider.getGasPriceEstimation(),r=BigInt(a.gas_estimate),i=n.rawTransaction.max_gas_amount??g,o=n.rawTransaction.gas_unit_price??h;if(o===h&&(n.rawTransaction.gas_unit_price=BigInt(Math.min(Number(o),Number(r)))),i===g){const t=await this.provider.getAccountAPTAmount({accountAddress:n.feePayerAddress??n.rawTransaction.sender}),e=BigInt(Math.min(t,2e8))/n.rawTransaction.gas_unit_price;n.rawTransaction.max_gas_amount=e}const[c]=await this.provider.transaction.simulate.simple({transaction:n,options:{estimateGasUnitPrice:!0,estimateMaxGasAmount:!0,estimatePrioritizedGasUnitPrice:!0}}),l=(c.gas_used&&BigInt(c.gas_used)>0?BigInt(c.gas_used):m)*r,d=c.gas_used?BigInt(Math.ceil(1.5*Number(c.gas_used))):p,u=d*r;let w=t;try{n.rawTransaction.max_gas_amount=i===g?BigInt(Math.min(Number(i),Number(d))):i,n.rawTransaction.gas_unit_price=o===h?BigInt(Math.min(Number(o),Number(r))):o,w=f.from(n.bcsToBytes()).toString("base64")}catch(e){w=t}return{preparedTx:w,success:c.success,gasBudget:u,estimatedGasCost:l}}catch(e){return console.log("error",e),{preparedTx:t,success:!1,gasBudget:p,estimatedGasCost:m}}}prefetch(t){this.getAssetById({assetId:t.assetId})}getAssetById({assetId:t}){return this.prefetchedAssets[t]??=async function(t,e){if(!t)throw new Error("Received empty asset identifier for lookup");const n=(0,i.qZ)(e.blockchainId),a=(0,d.zY)(e,n?.rpcUrl),s=(0,d.im)(d.cH,{assetId:t}),r=await(0,d.HL)(s),o=await fetch(`${l.Fv}/v3/graphql`,{method:"POST",headers:{Accept:"application/json","apollographql-client-name":"backpack-secure-clients","Content-Type":"application/json",...a,...r},body:JSON.stringify(s)});return(await o.json()).data.node}(t,this.networkConfig),this.prefetchedAssets[t]}async executeWormholeTransaction(t){try{const e=await this.buildTransaction(t.publicKey,t.tx,{maxGasAmount:5e5,gasUnitPrice:100}),{signature:n,tx:a}=await(0,o.W)(this.secureAptosVmClient.signTransaction({tx:f.from(e.bcsToBytes()).toString("base64"),publicKey:t.publicKey,blockchainId:t.blockchainId},{uiOptions:{relevantAccounts:[t.publicKey]}}));return await this.executeTransaction({signedTx:a,signature:n})}catch(t){throw new Error(`Wormhole bridge transaction failed: ${t||"Unknown error"}`)}}}var y=n(226148),b=n(995253),I=n(36697),k=n(799828),T=n(182486),v=n(78126),A=n(199670);async function B(t,e,n,a){if(!e)throw new Error("Received empty asset identifier for lookup");const s=(0,i.qZ)(t.blockchainId),r=(0,d.zY)(t,s?.rpcUrl),o=(0,d.im)(d.Ee,{assetId:e,ordinalAddress:n.publicKey,spendingAddress:a.publicKey}),c=await(0,d.HL)(o),[u,m]=await Promise.all([fetch(t.rpcUrl,{method:"POST",body:JSON.stringify({method:"estimatesmartfee",params:[1]})}),fetch(`${l.Fv}/v3/graphql`,{method:"POST",headers:{Accept:"application/json","apollographql-client-name":"backpack-secure-clients","Content-Type":"application/json",...r,...c},body:JSON.stringify(o)})]),[p,h]=await Promise.all([m.json(),u.json()]);return{assetData:p.data,estimateSmartFee:h.result}}var C=n(348834).Buffer;const S=t=>{if(!t)throw new Error("Unable to fetch fee estimate.");const e=1e5*t.feerate;return BigInt(Math.ceil(1.2*e))},x=(t,e)=>{if(t.nfts?.some((t=>t.id===e)))return!0;if(t.tokens?.some((t=>t.id===e)))return!0;const n=(t=>{try{return C.from(t,"base64").toString("utf-8")}catch{return t}})(e);if(t.nfts?.length>0||t.tokens?.length>0){const e=`${t.hash}:${t.index}`;if(n.includes(e)||n.includes(t.id))return!0}if(t.rareSats?.ranges?.length){const e=n.split("/").pop();if(e&&/^\d{10,}$/.test(e)){const n=BigInt(e);return t.rareSats.ranges.some((t=>{const[e,a]=t.split("-").map((t=>BigInt(t)));return n>=e&&n<=a}))}}return!1},P=t=>t.filter((t=>!t.nfts?.length&&!t.tokens?.length&&!t.rareSats)),E=(t,e,n,s,r,i)=>{const o=e.reduce(((t,e)=>t+BigInt(e.value)),BigInt(0)),c=I.IS(t,[{address:n,amount:o}],"all",{changeAddress:s,allowLegacyWitnessUtxo:r===a.DL.BVM_LEGACY,feePerByte:i,bip69:!1,createTx:!0});if(!c?.fee)return o;const l=o-c.fee;return l>BigInt(0)?l:BigInt(0)};class K extends c{blockchain;secureBvmClient;constructor(t,e){super(),this.secureBvmClient=new y.I(t),this.blockchain=e.blockchain,this.config=(0,i.X2)(a.$O.BITCOIN),this.networkConfig=e}async fetchBalances({publicKeys:t,balances:e}){const n=await Promise.all(t.map((n=>async function(t,e){const n=(0,i.qZ)(t.blockchainId),a=(0,d.zY)(t,n?.rpcUrl),s=(0,d.im)(d.xb,{address:e}),r=await(0,d.HL)(s),o=await fetch(`${l.Fv}/v3/graphql`,{method:"POST",headers:{Accept:"application/json","apollographql-client-name":"backpack-secure-clients","Content-Type":"application/json",...a,...r},body:JSON.stringify(s)}),c=await o.json();let u=BigInt(0);for(const t of c?.data?.utxos?.edges??[]){const e=t.node;(e.nfts?.length??0)>0||(e.tokens?.length??0)>0||e.rareSats||(u+=BigInt(e.value||"0"))}return u}(this.networkConfig,n).catch((()=>e?BigInt(e[t.indexOf(n)]):BigInt(0))))));return t.map(((t,a)=>({publicKey:t,index:a,balance:e?BigInt(e[a]):BigInt(0),transferrableBalance:n[a]})))}estimateGas(t){throw new Error("Method not implemented.")}async validateAddress(t){if(""===t)return{isValid:!1,isWallet:!1};try{const e=(0,v.ZX)(t);return{p2pkh:a.DL.BVM_LEGACY,p2sh:a.DL.BVM_SEGWIT,p2wpkh:a.DL.BVM_NATIVE_SEGWIT,p2tr:a.DL.BVM_TAPROOT}[e.type]?{funded:!0,isValid:!0,isWallet:!0,publicKey:t}:{isValid:!1,isWallet:!1}}catch{return{isValid:!1,isWallet:!1}}}prefetchedAssets={};prefetch({assetId:t,from:e,additionalSigners:n}){const a=n?.[0];this.prefetchedAssets[t]=B(this.networkConfig,t,e,a??e)}getAssetById(t){const e=t.additionalSigners?.[0];return B(this.networkConfig,t.assetId,t.from,e??t.from)}async transferAsset(t){if((0,a.s0)(t.from.info.walletType)){const{assetData:e}=await this.getAssetById({assetId:t.assetId,from:t.from,additionalSigners:t.additionalSigners}),n="Nft"===e?.node?.__typename||e?.spendingUtxos?.edges?.some((({node:e})=>x(e,t.assetId)));return n?this.spendingCollectibleTransfer(t):this.spendingBTCTransferTransaction(t)}if((0,a.tb)(t.from.info.walletType))return this.ordinalsTransfer(t);throw new Error("transferAsset:Unable to perform asset transfer")}async ordinalsTransfer(t){const{assetId:e,from:n,additionalSigners:s}=t,{assetData:r}=await this.getAssetById({assetId:e,from:n,additionalSigners:s});if(!r)throw new Error("Unable to fetch asset data.");if("TokenBalance"===r?.node?.__typename&&r?.node?.runeId===this.networkConfig.gasCurrencyAddress)return this.ordinalsBTCTransferTransaction(t);const i=s?.[0];if(!i||!(0,a.s0)(i.info.walletType))throw new Error("Invariant: Transferring ordinals requires additional signer to be a valid spending wallet.");if(!r.node){const n=r.ordinalUtxos.edges.some((({node:t})=>x(t,e)));if(n)return this.utxoTransfer(t,i);throw new Error("Asset not found in UTXOs")}switch(r.node.__typename){case"TokenBalance":return this.runesTransfer(t,i);case"Nft":return this.utxoTransfer(t,i);default:throw new Error("Unknown asset type. Unable to perform asset transfer")}}async spendingCollectibleTransfer(t){const{assetId:e,from:n,to:a}=t,[{assetData:s,estimateSmartFee:r},i]=await Promise.all([this.getAssetById({assetId:e,from:n}),(0,o.W)(this.secureBvmClient.getAddressInfo({blockchainId:n.blockchainId,address:n.publicKey}))]);if(!s)throw new Error("Unable to fetch asset data.");const c=t=>t.find((({node:t})=>x(t,e)))?.node,l=c(s.ordinalUtxos.edges)||c(s.spendingUtxos.edges);if(!l)throw new Error("Invariant: UTXO not available for asset Id");const d=S(r),u=await this.createUtxoTransferTransaction({ordinalsAddressInfo:i,spendingAddressInfo:i,ordinalsUtxos:[l],spendingUtxos:s.spendingUtxos.edges.map((({node:t})=>t)).filter((t=>t.id!==l.id)),to:a,feeRate:d});return this.signAndSendPSBT({from:n,psbt:C.from(u),additionalSigners:[],options:{uiOptions:{relevantAccounts:[n.publicKey,a.publicKey]}}})}async runesTransfer(t,e){const{assetId:n,from:s,to:r,amount:i,additionalSigners:c}=t;if([a.Sq.BVM_LEGACY_ORDINALS].includes(s.info.walletType))throw new Error("Unable to tranfer runes. Legacy addresses do not support OP_RETURN outputs.");const[{assetData:l,estimateSmartFee:d},u,m]=await Promise.all([this.getAssetById({assetId:n,from:s,additionalSigners:c}),(0,o.W)(this.secureBvmClient.getAddressInfo({blockchainId:s.blockchainId,address:s.publicKey})),(0,o.W)(this.secureBvmClient.getAddressInfo({blockchainId:e.blockchainId,address:e.publicKey}))]);if(!l)throw new Error("Unable to fetch asset data.");if("TokenBalance"!==l.node?.__typename)throw new Error("Invariant: Expected TokenBalance for rune transfer but got Nft or null");const p=S(d),h={address:r.publicKey,runeId:l.node.runeId,amount:BigInt(i)},g=await this.getSpendableInputs(u,l.ordinalUtxos.edges.map((({node:t})=>t)),h.runeId),f=I.IS(g,[h],"default",{changeAddress:u.publicKey,feePerByte:BigInt(0)});if(!f)throw new Error("Not enough runes to spend.");const w=f?.inputs.map((t=>l.ordinalUtxos.edges.find((({node:e})=>t.txid&&e.hash===("string"==typeof t.txid?t.txid:b.$v.encode(t.txid))&&parseInt(e.index,10)===t.index)).node)).filter(Boolean)??[],y=new Set(w.map((t=>t.id))),k=await this.createUtxoTransferTransaction({ordinalsAddressInfo:u,spendingAddressInfo:m,ordinalsUtxos:w,spendingUtxos:l.spendingUtxos.edges.map((({node:t})=>t)).filter((t=>!y.has(t.id))),to:s,feeRate:p,runeTransfers:[h]});return this.signAndSendPSBT({from:s,psbt:C.from(k),additionalSigners:[e],options:{uiOptions:{relevantAccounts:[u.publicKey,m.publicKey,r.publicKey]}}})}async utxoTransfer(t,e){const{assetId:n,from:a,to:s,additionalSigners:r}=t,[{assetData:i,estimateSmartFee:c},l,d]=await Promise.all([this.getAssetById({assetId:n,from:a,additionalSigners:r}),(0,o.W)(this.secureBvmClient.getAddressInfo({blockchainId:a.blockchainId,address:a.publicKey})),(0,o.W)(this.secureBvmClient.getAddressInfo({blockchainId:e.blockchainId,address:e.publicKey}))]);if(!i)throw new Error("Unable to fetch asset data.");const u=(m=i.ordinalUtxos.edges,m.find((({node:t})=>x(t,n)))?.node);var m;if(!u)throw new Error("Invariant: UTXO not available for asset Id");const p=S(c),h=await this.createUtxoTransferTransaction({ordinalsAddressInfo:l,spendingAddressInfo:d,ordinalsUtxos:[u],spendingUtxos:i.spendingUtxos.edges.map((({node:t})=>t)).filter((t=>t.id!==u.id)),to:s,feeRate:p});return this.signAndSendPSBT({from:a,psbt:C.from(h),additionalSigners:[e],options:{uiOptions:{relevantAccounts:[l.publicKey,d.publicKey,s.publicKey]}}})}async createUtxoTransferTransaction(t){const{ordinalsAddressInfo:e,spendingAddressInfo:n,ordinalsUtxos:a,spendingUtxos:s,to:r,feeRate:i,runeTransfers:o}=t,c=a.map((t=>({address:r.publicKey,amount:BigInt(t.value)}))),l=await this.maybeAddRunestoneOutputs({inputUtxos:a,outputs:c,runeTransfers:o}),d=await this.getSpendableInputs(n,s),u=await this.getSpendableInputs(e,a),m=d[0];if(!m)throw new Error("No spendable UTXOs available in spending wallet to pay for fees.");const p=d.slice(1),h=[...u,m],g=I.IS(p,l,"default",{changeAddress:n.publicKey,requiredInputs:h,allowUnknownOutputs:!0,feePerByte:i,bip69:!1,createTx:!0}),f=g?.tx?.toPSBT();if(!f)throw new Error("Not enough funds available in spending wallet to create transaction.");return f}async maybeAddRunestoneOutputs({inputUtxos:t,outputs:e,runeTransfers:n}){if(t.length!==e.length)throw new Error("Invariant: Expect inputs and outputs the be the same before adding Runestone");const a=[...e],s=[],r={};let i=!1;if(t.forEach(((t,e)=>{s[e]={},t.tokens?.forEach((t=>{i=!0,s[e][t.runeId]=BigInt(t.amount),r[t.runeId]??=BigInt(0),r[t.runeId]+=BigInt(t.amount)}))})),n){const t={},e=[],i=[];n.forEach(((n,a)=>{i[a]={[n.runeId]:BigInt(n.amount)},e[a]={address:n.address,amount:BigInt(546)},t[n.runeId]??=BigInt(0),t[n.runeId]+=BigInt(n.amount)})),Object.entries(t).forEach((([t,e])=>{if(e>r[t])throw new Error("Invariant: Not enough runes available to transfer")}));const o=[...s].reverse();n.forEach((t=>{let e=t.amount;const n=t.runeId;o.find((t=>{const a=t[n]??BigInt(0);return!(a<=BigInt(0)||(e>a?(t[n]=BigInt(0),e-=a,1):(t[n]=a-e,0)))}))})),a.push(...e),s.push(...i)}if(i){const t=[];s.forEach(((e,n)=>{Object.entries(e).forEach((([e,a])=>{if(a>BigInt(0)){const[s,r]=e.split(":");t.push(new A.Edict(new A.RuneId(parseInt(s,10),parseInt(r,10)),a,n+1))}}))}));const e=new A.Runestone(t,(0,A.none)(),(0,A.none)(),(0,A.some)(1));a.unshift({script:Uint8Array.from(e.encipher()),amount:BigInt(0)})}return a}async spendingBTCTransferTransaction({assetId:t,from:e,to:n,amount:s,isMaxAmount:r}){const i=n.publicKey,{assetData:c,estimateSmartFee:l}=await this.getAssetById({assetId:t,from:e}),d=await(0,o.W)(this.secureBvmClient.getAddressInfo({blockchainId:e.blockchainId,address:e.publicKey}));if(!c)throw new Error("Unable to fetch asset data.");if("TokenBalance"!==c.node?.__typename||c.node?.runeId!==this.networkConfig.gasCurrencyAddress)throw new Error('Unable to transfer asset. "Spending Wallets" can only perform bitcoin transactions. Import wallet as "Ordinals Wallet" to transfer Runes or Inscriptions.');const u=S(l),m=P(c.ordinalUtxos.edges.map((({node:t})=>t))),p=await this.getSpendableInputs(d,m),h=r?E(p,m,i,e.publicKey,d.addressType,u):BigInt(s),g=[{address:i,amount:h}],f=I.IS(p,g,"default",{changeAddress:e.publicKey,allowLegacyWitnessUtxo:d.addressType===a.DL.BVM_LEGACY,feePerByte:u,bip69:!1,createTx:!0}),w=f?.tx?.toPSBT();if(!w)throw new Error("Unable to perform transfer.");return this.signAndSendPSBT({from:e,psbt:C.from(w),additionalSigners:[],options:{uiOptions:{relevantAccounts:[e.publicKey,n.publicKey],sendAmount:h.toString()}}})}async ordinalsBTCTransferTransaction({assetId:t,from:e,to:n,amount:s,isMaxAmount:r}){const i=n.publicKey,{assetData:c,estimateSmartFee:l}=await this.getAssetById({assetId:t,from:e}),d=await(0,o.W)(this.secureBvmClient.getAddressInfo({blockchainId:e.blockchainId,address:e.publicKey}));if(!c)throw new Error("Unable to fetch asset data.");const u=S(l),m=P(c.ordinalUtxos.edges.map((({node:t})=>t)));if(0===m.length)throw new Error("No spendable Bitcoin available. All UTXOs contain inscriptions, runes, or rare sats.");const p=await this.getSpendableInputs(d,m),h=r?E(p,m,i,e.publicKey,d.addressType,u):BigInt(s),g=[{address:i,amount:h}],f=I.IS(p,g,"default",{changeAddress:e.publicKey,allowLegacyWitnessUtxo:d.addressType===a.DL.BVM_LEGACY,feePerByte:u,bip69:!1,createTx:!0}),w=f?.tx?.toPSBT();if(!w)throw new Error("Unable to perform transfer. Not enough spendable Bitcoin (excluding ordinals).");return this.signAndSendPSBT({from:e,psbt:C.from(w),additionalSigners:[],options:{uiOptions:{relevantAccounts:[e.publicKey,n.publicKey],sendAmount:h.toString()}}})}async getSpendableInputs(t,e,n){const s=b.$v.decode(t.extendedPublicKey),r=b.$v.decode(t.schnorrPublicKey);switch(t.addressType){case a.DL.BVM_SEGWIT:{const t=k.my(k.Vi(s));return e.map((e=>({...t,txid:b.$v.decode(e.hash),index:parseInt(e.index,10),witnessUtxo:{script:t.script,amount:n?BigInt(e.tokens?.find((t=>t.runeId===n))?.amount??0):BigInt(e.value)}})))}case a.DL.BVM_NATIVE_SEGWIT:{const t=k.Vi(s);return e.map((e=>({...t,txid:b.$v.decode(e.hash),index:parseInt(e.index,10),witnessUtxo:{script:t.script,amount:n?BigInt(e.tokens?.find((t=>t.runeId===n))?.amount??0):BigInt(e.value)}})))}case a.DL.BVM_TAPROOT:{const t=k.Sq(r);return e.map((e=>({...t,txid:b.$v.decode(e.hash),index:parseInt(e.index,10),witnessUtxo:{script:t.script,amount:n?BigInt(e.tokens?.find((t=>t.runeId===n))?.amount??0):BigInt(e.value)}})))}case a.DL.BVM_LEGACY:{if(n)throw new Error("Invariant: Runes not supported for legacy addresses");const t=k.xc(s);return Promise.all(e.map((async e=>{const n=await fetch(this.networkConfig.rpcUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({method:"getrawtransaction",params:[e.hash]})}),a=await n.json();return{...t,txid:b.$v.decode(e.hash),index:parseInt(e.index,10),script:t.script,amount:BigInt(e.value),nonWitnessUtxo:a.result}})))}default:throw new Error("Unsupported bitcoin address type: "+t.addressType)}}async signAndSendPSBT({from:t,psbt:e,additionalSigners:n,options:a}){const{signedPsbt:s}=await(0,o.W)(this.secureBvmClient.signTx({blockchainId:t.blockchainId,address:t.publicKey,additionalSigners:n.map((t=>t.publicKey)),psbt:e},a)),r=T.YW.fromPSBT(C.from(s));r.finalize();const i=b.$v.encode(r.extract()),c=await fetch(this.networkConfig.rpcUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({method:"sendrawtransaction",params:[i]})}),l=await c.json(),d=l?.result;if(!d)throw new Error(l?.error?.message??"Failed to broadcast Transaction");return d}burnAsset(t,e){throw new Error("Not Implemented")}async confirmTransaction(t){return!0}}var M=n(445895),N=n(374196),U=n(438869),_=n(847792),O=n(7806);class R extends _.vH{evmClient;networkConfig;constructor(t,e,n,a){n||(n=new O.Z(e.name,e.caip2Reference)),super(n,{staticNetwork:n,...a}),this.evmClient=t,this.networkConfig=e,this._isProvider=!0}_isProvider;async send(t,e){return await this._start(),await super.send(t,e)}async _send(t){return(await(0,o.W)(this.evmClient.provider_send({blockchainId:this.networkConfig.blockchainId,payload:Array.isArray(t)?t:[t]}))).result}}var D=n(53290),V=n(13668),W=n(192467),L=n(802522),j=n(322492),F=n(660470),H=n(39570);class q extends D.g{secureEvmClient;publicKey;blockchainId;uuid;constructor(t,e,n,a,s){super(e),this.secureEvmClient=t,this.publicKey=n,this.blockchainId=a,this.uuid=s}async getAddress(){return this.publicKey}connect(t){throw new Error("Get connected Signer via EthereumClient.getSigner")}async sendTransaction(t,e){if(!this.provider)throw new Error("Provider Unavailable.");const n=await this.populateTransaction(t);delete n.from;const a=N.Y.from(n);return await this.provider.broadcastTransaction(await this.signTransaction(a,e))}async signTransactionFromTransactionRequest(t,e){if(!this.provider)throw new Error("Provider Unavailable.");const n=await this.populateTransaction(t);delete n.from;const a=N.Y.from(n);return await this.signTransaction(a,e)}async signTransaction(t,e){!function(t){delete t.from;const e=t.gas;delete t.gas,t.gasLimit=e?BigInt(e):t.gasLimit;const n=t.type;t.accessList&&(t.type=1),2!==n&&"0x2"!==n&&null!=n||null==t.maxFeePerGas||null==t.maxPriorityFeePerGas||(t.type=2)}(t);const n=N.Y.from(t);return(await(0,o.W)(this.secureEvmClient.evm_signTransaction({txHex:n.unsignedSerialized,publicKey:this.publicKey,blockchainId:this.blockchainId,uuid:this.uuid},e))).signedTxHex}async signMessage(t,e){let n;if("string"==typeof t)if((0,V.A7)(t))try{n=(0,W.Y0)((0,W.ZN)(t))}catch{n=(0,V.Pw)(t)}else n=(0,W.Y0)(t);else n=t;const a=(0,L.X)(n);return(await(0,o.W)(this.secureEvmClient.evm_signMessage({message58:a,publicKey:this.publicKey,blockchainId:this.blockchainId,uuid:this.uuid},e))).signatureHex}async signTypedData(t,e,n,a){delete e.EIP712Domain;const s=await j.E.resolveNames(t,e,n,(async t=>{const e=await(0,F.ru)(t,this.provider);return(0,H.en)(null!=e,"TypedData does not support null address","value",t),e})),r=j.E.getPayload(s.domain,e,s.value);return(await(0,o.W)(this.secureEvmClient.evm_signTypedData({typedDataPayload:JSON.stringify(r),publicKey:this.publicKey,blockchainId:this.blockchainId,uuid:this.uuid},a))).signatureHex}}var $=n(759813),Y=n(887388),z=n(4151);const G="0x0000000000000000000000000000000000001000",J="0xcA11bde05977b3631167028862bE2a173976CA11",X=[{name:"aggregate3",type:"function",stateMutability:"payable",inputs:[{name:"calls",type:"tuple[]",components:[{name:"target",type:"address"},{name:"allowFailure",type:"bool"},{name:"callData",type:"bytes"}]}],outputs:[{name:"returnData",type:"tuple[]",components:[{name:"success",type:"bool"},{name:"returnData",type:"bytes"}]}]}],Z=[{name:"delegate",type:"function",stateMutability:"payable",inputs:[{name:"valId",type:"uint64"}],outputs:[{name:"",type:"bool"}]},{name:"undelegate",type:"function",stateMutability:"nonpayable",inputs:[{name:"valId",type:"uint64"},{name:"amount",type:"uint256"},{name:"withdrawalId",type:"uint8"}],outputs:[{name:"",type:"bool"}]},{name:"withdraw",type:"function",stateMutability:"nonpayable",inputs:[{name:"valId",type:"uint64"},{name:"withdrawalId",type:"uint8"}],outputs:[{name:"",type:"bool"}]},{name:"claimRewards",type:"function",stateMutability:"nonpayable",inputs:[{name:"valId",type:"uint64"}],outputs:[{name:"",type:"bool"}]},{name:"compound",type:"function",stateMutability:"nonpayable",inputs:[{name:"valId",type:"uint64"}],outputs:[{name:"",type:"bool"}]},{name:"getValidator",type:"function",stateMutability:"view",inputs:[{name:"valId",type:"uint64"}],outputs:[{name:"authAddress",type:"address"},{name:"flags",type:"uint64"},{name:"stake",type:"uint256"},{name:"accRewardPerToken",type:"uint256"},{name:"commission",type:"uint256"},{name:"unclaimedRewards",type:"uint256"},{name:"consensusStake",type:"uint256"},{name:"consensusCommission",type:"uint256"},{name:"snapshotStake",type:"uint256"},{name:"snapshotCommission",type:"uint256"},{name:"secpPubkey",type:"bytes"},{name:"blsPubkey",type:"bytes"}]},{name:"getDelegator",type:"function",stateMutability:"view",inputs:[{name:"valId",type:"uint64"},{name:"delegator",type:"address"}],outputs:[{name:"stake",type:"uint256"},{name:"accRewardPerToken",type:"uint256"},{name:"unclaimedRewards",type:"uint256"},{name:"deltaStake",type:"uint256"},{name:"nextDeltaStake",type:"uint256"},{name:"deltaEpoch",type:"uint64"},{name:"nextDeltaEpoch",type:"uint64"}]},{name:"getWithdrawalRequest",type:"function",stateMutability:"view",inputs:[{name:"valId",type:"uint64"},{name:"delegator",type:"address"},{name:"withdrawalId",type:"uint8"}],outputs:[{name:"withdrawalAmount",type:"uint256"},{name:"accRewardPerToken",type:"uint256"},{name:"withdrawEpoch",type:"uint64"}]},{name:"getDelegations",type:"function",stateMutability:"view",inputs:[{name:"delegator",type:"address"},{name:"startValId",type:"uint64"}],outputs:[{name:"isDone",type:"bool"},{name:"nextValId",type:"uint64"},{name:"valIds",type:"uint64[]"}]},{name:"getConsensusValidatorSet",type:"function",stateMutability:"view",inputs:[{name:"startIndex",type:"uint32"}],outputs:[{name:"isDone",type:"bool"},{name:"nextIndex",type:"uint32"},{name:"valIds",type:"uint64[]"}]},{name:"getSnapshotValidatorSet",type:"function",stateMutability:"view",inputs:[{name:"startIndex",type:"uint32"}],outputs:[{name:"isDone",type:"bool"},{name:"nextIndex",type:"uint32"},{name:"valIds",type:"uint64[]"}]},{name:"getExecutionValidatorSet",type:"function",stateMutability:"view",inputs:[{name:"startIndex",type:"uint32"}],outputs:[{name:"isDone",type:"bool"},{name:"nextIndex",type:"uint32"},{name:"valIds",type:"uint64[]"}]},{name:"getEpoch",type:"function",stateMutability:"view",inputs:[],outputs:[{name:"epoch",type:"uint64"},{name:"isBoundary",type:"bool"}]},{name:"Delegated",type:"event",anonymous:!1,inputs:[{indexed:!0,name:"valId",type:"uint64"},{indexed:!0,name:"delegator",type:"address"},{indexed:!1,name:"amount",type:"uint256"}]},{name:"Undelegated",type:"event",anonymous:!1,inputs:[{indexed:!0,name:"valId",type:"uint64"},{indexed:!0,name:"delegator",type:"address"},{indexed:!1,name:"amount",type:"uint256"},{indexed:!1,name:"withdrawalId",type:"uint8"}]},{name:"Withdrawn",type:"event",anonymous:!1,inputs:[{indexed:!0,name:"valId",type:"uint64"},{indexed:!0,name:"delegator",type:"address"},{indexed:!1,name:"amount",type:"uint256"},{indexed:!1,name:"withdrawalId",type:"uint8"}]},{name:"RewardsClaimed",type:"event",anonymous:!1,inputs:[{indexed:!0,name:"valId",type:"uint64"},{indexed:!0,name:"delegator",type:"address"},{indexed:!1,name:"amount",type:"uint256"}]},{name:"Compounded",type:"event",anonymous:!1,inputs:[{indexed:!0,name:"valId",type:"uint64"},{indexed:!0,name:"delegator",type:"address"},{indexed:!1,name:"amount",type:"uint256"}]}];class Q{getClient;constructor(t){this.getClient=t}async delegate(t){const e=this.getClient().getSigner(t.authority),n=new $.CH(G,Z,e),a=(0,Y.fi)(t.amount);return(await n.delegate(t.validatorId,{value:a})).hash}async undelegate(t){const e=this.getClient().getSigner(t.authority),n=new $.CH(G,Z,e),a=(0,Y.fi)(t.amount),s=t.withdrawalId??1;return(await n.undelegate(t.validatorId,a,s)).hash}async withdraw(t){const e=this.getClient().getSigner(t.authority),n=new $.CH(G,Z,e),a=t.withdrawalId??1;return(await n.withdraw(t.validatorId,a)).hash}async claimRewards(t){const e=this.getClient().getSigner(t.authority),n=new $.CH(G,Z,e);return(await n.claimRewards(t.validatorId)).hash}async compound(t){const e=this.getClient().getSigner(t.authority),n=new $.CH(G,Z,e);return(await n.compound(t.validatorId)).hash}async getValidator(t){const e=this.getClient().getProvider(),n=new $.CH(G,Z,e);try{const e=await n.getValidator(t.validatorId);return{authAddress:e.authAddress,flags:e.flags,stake:e.stake,accRewardPerToken:e.accRewardPerToken,commission:e.commission,unclaimedRewards:e.unclaimedRewards,consensusStake:e.consensusStake,consensusCommission:e.consensusCommission,snapshotStake:e.snapshotStake,snapshotCommission:e.snapshotCommission,secpPubkey:e.secpPubkey,blsPubkey:e.blsPubkey}}catch(e){throw console.error("getValidator failed for ID",t.validatorId,":",e),e}}async getValidatorsBatch(t){const e=this.getClient().getProvider();try{const n=new z.vU(Z),a=t.validatorIds.map((t=>({target:G,allowFailure:!0,callData:n.encodeFunctionData("getValidator",[t])}))),s=new $.CH(J,X,e);return(await s.aggregate3.staticCall(a)).map(((e,a)=>{if(!e.success)return console.error(`getValidator failed for ID ${t.validatorIds[a]}`),null;try{const t=n.decodeFunctionResult("getValidator",e.returnData);return{authAddress:t.authAddress,flags:t.flags,stake:t.stake,accRewardPerToken:t.accRewardPerToken,commission:t.commission,unclaimedRewards:t.unclaimedRewards,consensusStake:t.consensusStake,consensusCommission:t.consensusCommission,snapshotStake:t.snapshotStake,snapshotCommission:t.snapshotCommission,secpPubkey:t.secpPubkey,blsPubkey:t.blsPubkey}}catch(e){return console.error(`Failed to decode validator ${t.validatorIds[a]}:`,e),null}}))}catch(e){return console.warn("Multicall3 not available, falling back to individual calls:",e),await Promise.all(t.validatorIds.map((async t=>{try{return await this.getValidator({validatorId:t})}catch(e){return console.error(`getValidator failed for ID ${t}:`,e),null}})))}}async getDelegator(t){const e=this.getClient().getProvider(),n=new $.CH(G,Z,e),a=await n.getDelegator(t.validatorId,t.delegatorAddress);return{stake:a.stake,accRewardPerToken:a.accRewardPerToken,unclaimedRewards:a.unclaimedRewards,deltaStake:a.deltaStake,nextDeltaStake:a.nextDeltaStake,deltaEpoch:a.deltaEpoch,nextDeltaEpoch:a.nextDeltaEpoch}}async getWithdrawalRequest(t){const e=this.getClient().getProvider(),n=new $.CH(G,Z,e),a=await n.getWithdrawalRequest(t.validatorId,t.delegatorAddress,t.withdrawalId);return{withdrawalAmount:a.withdrawalAmount,accRewardPerToken:a.accRewardPerToken,withdrawEpoch:a.withdrawEpoch}}async getEpoch(){const t=this.getClient().getProvider(),e=new $.CH(G,Z,t),n=await e.getEpoch();return{epoch:n.epoch,isBoundary:n.isBoundary}}async getDelegations(t){const e=this.getClient().getProvider(),n=new $.CH(G,Z,e),a=t.startValidatorId??"0";return(await n.getDelegations(t.delegatorAddress,a)).valIds}async getConsensusValidatorSet(t){const e=this.getClient().getProvider(),n=new $.CH(G,Z,e),a=t?.startIndex??0,s=await n.getConsensusValidatorSet(a);return{isDone:s.isDone,nextIndex:Number(s.nextIndex),valIds:s.valIds}}async getSnapshotValidatorSet(t){const e=this.getClient().getProvider(),n=new $.CH(G,Z,e),a=t?.startIndex??0,s=await n.getSnapshotValidatorSet(a);return{isDone:s.isDone,nextIndex:Number(s.nextIndex),valIds:s.valIds}}async getExecutionValidatorSet(t){const e=this.getClient().getProvider(),n=new $.CH(G,Z,e),a=t?.startIndex??0,s=await n.getExecutionValidatorSet(a);return{isDone:s.isDone,nextIndex:Number(s.nextIndex),valIds:s.valIds}}async getAllValidatorIds(t="execution"){const e=[];let n=0,a=!1;const s={consensus:this.getConsensusValidatorSet.bind(this),snapshot:this.getSnapshotValidatorSet.bind(this),execution:this.getExecutionValidatorSet.bind(this)}[t];for(;!a;){const t=await s({startIndex:n});if(e.push(...t.valIds),a=t.isDone,n=t.nextIndex,!a&&0===t.valIds.length)break}return e}async getAllWithdrawalsBatched(t){const e=t.maxWithdrawalSlots??10;if(0===t.validatorIds.length)return[];try{const n=this.getClient().getProvider(),a=new z.vU(Z),s=[],r=[];for(const n of t.validatorIds)for(let i=1;i<=e;i++)s.push({target:G,allowFailure:!0,callData:a.encodeFunctionData("getWithdrawalRequest",[n,t.delegatorAddress,i])}),r.push({validatorId:n,withdrawalId:i});const i=new $.CH(J,X,n),o=await i.aggregate3.staticCall(s),c=[];for(let t=0;t<o.length;t++){const e=o[t];if(e.success)try{const n=a.decodeFunctionResult("getWithdrawalRequest",e.returnData);n.withdrawalAmount>BigInt(0)&&c.push({validatorId:r[t].validatorId,withdrawalId:r[t].withdrawalId,withdrawalAmount:n.withdrawalAmount,withdrawEpoch:n.withdrawEpoch})}catch{}}return c}catch(t){return console.error("Error fetching withdrawals batched:",t),[]}}async getValidatorsWithPotentialWithdrawals(t){try{const e=t.validatorIds;if(!e||0===e.length)return[];const n=this.getClient().getProvider(),a=new z.vU(Z),s=e.map((e=>({target:G,allowFailure:!0,callData:a.encodeFunctionData("getWithdrawalRequest",[e,t.delegatorAddress,1])}))),r=new $.CH(J,X,n),i=await r.aggregate3.staticCall(s),o=[];for(let t=0;t<i.length;t++){const n=i[t];if(n.success)try{a.decodeFunctionResult("getWithdrawalRequest",n.returnData).withdrawalAmount>BigInt(0)&&o.push(BigInt(e[t]))}catch{}}return o}catch(t){return console.error("Error checking validators for withdrawals:",t),[]}}}async function tt(t,e){if(!t)throw new Error("Received empty asset identifier for lookup");const n=(0,i.qZ)(e.blockchainId),a=(0,d.zY)(e,n?.rpcUrl),s=(0,d.im)(d.el,{assetId:t}),r=await(0,d.HL)(s),o=await fetch(`${l.Fv}/v3/graphql`,{method:"POST",headers:{Accept:"application/json","apollographql-client-name":"backpack-secure-clients","Content-Type":"application/json",...a,...r},body:JSON.stringify(s)});return(await o.json()).data.node}var et=n(477851);class nt extends c{blockchainId;config;secureEvmClient;provider;Stake;constructor(t,e){super(),this.blockchainId=e.blockchainId,this.secureEvmClient=new M.l(t),this.provider=new R(this.secureEvmClient,e,void 0,{pollingInterval:e.blockchainId===a.Ek.ETHEREUM_MAINNET?4e3:750}),this.config=(0,i.X2)(a.$O.ETHEREUM),this.networkConfig=e,this.Stake=new Q((()=>this))}prefetchedAssets={};prefetch({assetId:t}){this.prefetchedAssets[t]=tt(t,this.networkConfig)}async getPriorityFee(){try{const t=await this.provider.send("eth_feeHistory",[1,"latest",[65]]),[[e]]=t.reward;return BigInt(parseInt(e,16))}catch(t){return console.warn("eth_feeHistory failed, using fallback",t),(await this.provider.getFeeData()).maxPriorityFeePerGas??BigInt(0)}}async estimateGas(t){const e=N.Y.from(t),[n,a]=await Promise.all([this.provider.getFeeData(),this.provider.estimateGas(e)]);return(a??BigInt(0))*(n.maxFeePerGas??BigInt(0))+(a??BigInt(0))*(n.maxPriorityFeePerGas??BigInt(0))}async fetchBalances({publicKeys:t}){const e=new N.Y;e.to=t[0],e.value=BigInt(1),e.chainId=this.networkConfig.caip2Reference;const[n,a]=await Promise.all([this.estimateGas(e.unsignedSerialized),Promise.all(t.map((t=>this.provider.getBalance(t))))]);return t.map(((t,e)=>{const s=a[e]??BigInt(0);return{publicKey:t,balance:s,transferrableBalance:s>n?s-n:BigInt(0),index:e}}))}async validateAddress(t){let e;if(""===t)return{isValid:!1,isWallet:!1};if(t.endsWith(".eth"))try{e=await this.provider.resolveName(t)}catch(t){return{isValid:!1,isWallet:!1}}if(!e)try{e=U.K(t)}catch(t){return{isValid:!1,isWallet:!1}}return{funded:!0,isValid:!0,isWallet:!0,publicKey:e}}getAssetById({assetId:t}){return this.prefetchedAssets[t]??=tt(t,this.networkConfig),this.prefetchedAssets[t]}async transferAsset(t){const{from:e,to:n,amount:a}=t,s=await this.getAssetById(t),r={walletPublicKey:e.publicKey,provider:this.provider,ethereumClient:this,chainId:parseInt(this.networkConfig.caip2Reference)};if(!s)throw new Error("Asset not available");let i;const o={relevantAccounts:[e.publicKey,n.publicKey]};if("TokenBalance"===s.__typename)if(s.contractAddress===this.networkConfig.gasCurrencyAddress)i=await et.tB.transferEthTransaction(r,{to:n.publicKey.toLocaleLowerCase(),value:a.toString()});else{if(!s.contractAddress)throw new Error("Contract address not available");i=await et.tB.transferErc20Transaction(r,{to:n.publicKey.toLocaleLowerCase(),contractAddress:s.contractAddress.toLocaleLowerCase(),amount:a.toString()})}else if("Nft"===s.__typename)if("erc1155"===s.type)i=await et.tB.transferErc1155Transaction(r,{to:n.publicKey.toLocaleLowerCase(),from:e.publicKey.toLocaleLowerCase(),contractAddress:s.contract.address.toLocaleLowerCase(),tokenId:s.tokenId,amount:a});else{if("erc721"!==s.type)throw new Error("Unknown NFT type");i=await et.tB.transferErc721Transaction(r,{to:n.publicKey.toLocaleLowerCase(),from:e.publicKey.toLocaleLowerCase(),contractAddress:s.contract.address.toLocaleLowerCase(),tokenId:s.tokenId})}const c=this.getSigner(e.publicKey);return(await c.sendTransaction(i,{uiOptions:o,transactionType:t.transactionType})).hash}async burnAsset(t,e){throw new Error("burnAsset not implemented for Ethereum")}async confirmTransaction(t){await this.provider.waitForTransaction(t);const e=await this.provider.getTransaction(t);if(!e)throw new Error("Unable to fetch Ethereum transaction");return await e.wait(),!0}getSigner(t,e){return new q(this.secureEvmClient,this.provider,t,this.blockchainId,e)}getProvider(){return this.provider}}var at=n(476155),st=n(338263),rt=n(861326),it=n(830324),ot=n(623823),ct=n(248985),lt=n(139809),dt=n(358542),ut=n(627158),mt=n(817022),pt=n.n(mt),ht=n(797465),gt=n(406013),ft=n(162197),wt=n.n(ft),yt=n(127942),bt=n(348834).Buffer;const It=new TextEncoder;async function kt(t){const e=It.encode(t),n=new Uint8Array(e),a=await crypto.subtle.digest("SHA-256",n);return bt.from(a).toString("base64")}class Tt extends ut.Connection{cache=new Map;solanaRpc;constructor(t,e){super(t,{..."string"==typeof e?{commitment:e}:e||{},fetchMiddleware:vt})}setSolanaRpc(t){this.solanaRpc=t}async customSplTokenAccounts(t){const e="string"==typeof t?(0,rt.u)(t):t,n=JSON.stringify({url:this.rpcEndpoint,method:"customSplTokenAccounts",args:[e.toString()]}),a=this.cache.get(n);if(a&&a.ts+15e3>Date.now())return a.value;const s=await(0,yt.dP)(this,e,this.solanaRpc);return this.cache.set(n,{ts:Date.now(),value:s}),Tt.customSplTokenAccountsFromJson(Tt.customSplTokenAccountsToJson(s))}static customSplTokenAccountsFromJson(t){return{mintsMap:t.mintsMap.map((t=>[t[0],{...t[1],supply:BigInt(t[1].supply)}])),fts:{...t.fts,fungibleTokens:t.fts.fungibleTokens.map((t=>({...t,amount:new(wt())(t.amount)})))},nfts:{...t.nfts,nftTokens:t.nfts.nftTokens.map((t=>({...t,amount:new(wt())(t.amount)})))}}}static customSplTokenAccountsToJson(t){return{mintsMap:t.mintsMap.map((([t,e])=>[t,null!==e?{...e,supply:e.supply.toString(),mintAuthority:e.mintAuthority?.toString(),freezeAuthority:e.freezeAuthority?.toString(),programId:e.programId?.toString()}:null])),fts:{fungibleTokens:t.fts.fungibleTokens.map((t=>Tt.solanaTokenAccountWithKeyToJson(t))),fungibleTokenMetadata:t.fts.fungibleTokenMetadata.map((t=>t?Tt.tokenMetadataToJson(t):null))},nfts:{nftTokens:t.nfts.nftTokens.map((t=>Tt.solanaTokenAccountWithKeyToJson(t))),nftTokenMetadata:t.nfts.nftTokenMetadata.map((t=>t?Tt.tokenMetadataToJson(t):null))}}}static solanaTokenAccountWithKeyToJson(t){return{...t,mint:t.mint.toString(),key:t.key.toString(),programId:t.programId.toString(),amount:t.amount.toString(),delegate:t.delegate?.toString(),delegatedAmount:t.delegatedAmount.toString(),owner:t.owner.toString(),closeAuthority:t.closeAuthority?.toString()}}static tokenMetadataToJson(t){return{...t,publicKey:t.publicKey.toString(),account:{...t.account,updateAuthority:t.account.updateAuthority.toString(),mint:t.account.mint.toString(),collection:t.account.collection?{...t.account.collection,key:t.account.collection.key.toString()}:null,uses:t.account.uses?{...t.account.uses,remaining:t.account.uses.remaining.toString(),total:t.account.uses.total.toString()}:null,data:{...t.account.data,creators:(t.account.data.creators??[]).map((t=>({...t,address:t.address.toString()})))}}}}}async function vt(t,e,n){if(!(()=>{try{const e="string"==typeof t?t:t.url,{hostname:n}=new URL(e);if(["backpack.app","bpinfra.xyz","madlads.com","xnftdata.com","xnfts.dev"].some((t=>n.endsWith(`.${t}`))))return!0}catch(e){console.error("fetch middleware error",{err:e,input:t})}return!1})())return n(t,e);const a=[Math.floor(Date.now()),Math.floor(1e4*(0,gt.n)())].join("-"),s=await(async()=>{try{return await kt(JSON.stringify([e?.body?.toString()||"",a,ht.B]))}catch(t){return console.error("Error generating backpack token header",t),"default"}})();return n(t,{...e,headers:{...e?.headers,"X-Backpack-Nonce":a,"X-Backpack-Token":s,"X-Backpack-Version":ht.B}})}var At=n(25492);async function Bt(t,e,n){return new Promise(((a,s)=>{const r="string"==typeof n?{commitment:n}:n,i=e.startsWith(At.SI),o=e.replace(At.SI,""),c="string"==typeof n?n:t.commitment;let l=!1;const d=t=>{l=!0,a(t)},u=t=>{l=!0,s(t)},m=async e=>{if(l)return;const n=Date.now()-e;if(n>=9e4)u(new Error("90 second timeout: unable to confirm transaction"));else{try{if(i){const t=await fetch("https://mainnet.block-engine.jito.wtf/api/v1/getBundleStatuses",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",id:1,method:"getBundleStatuses",params:[[o]]})}).then((t=>t.json())).then((async t=>{if(t.error)throw new Error(t.error.message);return t.result.value[0]||await fetch("https://mainnet.block-engine.jito.wtf/api/v1/getInflightBundleStatuses",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",id:1,method:"getInflightBundleStatuses",params:[[o]]})}).then((t=>t.json())).then((t=>{if(t.error)throw new Error(t.error.message);if("Failed"===t.result.value[0]?.status)throw new Error("Bundle failed.")})),t.result.value[0]?.confirmation_status===c})).catch((t=>{throw u(t),t}));if(t)return d(t)}else{const e=await t.getTransaction(o,r).then((t=>{if(!t)return!1;if(t.meta?.err)throw"string"==typeof t.meta.err?new Error(t.meta.err):t.meta.err;return!0})).catch((t=>{throw u(t),t}));if(e)return d(e)}}catch(t){console.error("Error confirming transaction",t)}let a;a=n<2e3?300:n<5e3?500:n<15e3?1e3:3e3,await new Promise((t=>setTimeout(t,i?Math.max(1e3,a):a))),await m(e)}};(async()=>{await new Promise((t=>setTimeout(t,400))),await m(Date.now())})()}))}var Ct=n(348834).Buffer;async function St(t,e,n){if(Array.isArray(t)){const e=t.map((t=>Ct.from(pt().decode(t.signedTx)).toString("base64"))),n=await fetch("https://jito.workers.madlads.com/bundle",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",id:Math.floor(1e4*(0,gt.n)()),method:"sendBundle",params:[e,{encoding:"base64"}]})}),a=await n.json();if(a.error)throw new Error(a.error.message);const s=At.SI+a.result;return{txHash:(t.find((t=>t.metadata?.isExecuteTx))??t[t.length-1]).txHash,jitoBundleId:s}}const a=Ct.from(pt().decode(t.signedTx)).toString("base64");if(t.metadata?.hasJitoTip){const t=await fetch("https://jito.workers.madlads.com/tx",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",id:Math.floor(1e4*(0,gt.n)()),method:"sendTransaction",params:[a,{encoding:"base64"}]})}),e=await t.json();if(e.error)throw new Error(e.error.message);return{txHash:e.result}}if(!e)throw new Error("SolanaRpc required for regular transaction");const s=pt().decode(t.signedTx),r=n?{...n,preflightCommitment:"recent"===n.preflightCommitment?"confirmed":n.preflightCommitment}:void 0;return{txHash:await e.sendRawTransaction(s,r)}}var xt=n(57572),Pt=n(467996),Et=n(348834).Buffer;const{base58:Kt}=Pt,Mt=t=>"version"in t,Nt=t=>{try{return ut.Transaction.from(Kt.decode(t))}catch{return ut.VersionedTransaction.deserialize(Kt.decode(t))}};class Ut{secureSvmClient;networkConfig;connection;solanaRpc;constructor(t,e,n,a){this.secureSvmClient=t,this.networkConfig=e,this.connection=n,this.solanaRpc=a}static async prepareSolanaOffchainMessage({message:t,encoding:e="UTF-8",maxLength:n=1212,signerAddress:a}){if(t.length>n)throw new Error(`Max message length (${n}) exceeded!`);const s=new Uint8Array([255,...Array.from("solana offchain",(t=>t.charCodeAt(0)))]),r=new Uint8Array([0]),i=new Uint8Array(32),o=new Uint8Array(["ASCII"===e?0:1212===n?1:2]),c=new Uint8Array([1]),l=a.toBytes(),d=new Uint16Array([t.length]),u=new Uint8Array(d.buffer,d.byteOffset,d.byteLength);return new Uint8Array([...s,...r,...i,...o,...c,...l,...u,...t])}async signMessage(t,e){const n=await this.secureSvmClient.signMessage({blockchainId:this.networkConfig.blockchainId,publicKey:t.publicKey.toBase58(),message:(0,mt.encode)(t.message),uuid:t.uuid},e);if(!n.response)throw n.error;return(0,mt.decode)(n.response.signedMessage)}async prepareTransaction(t){const e=t.tx,n=t.publicKey,a=t.signers,s=t.commitment,r=t.customConnection??this.solanaRpc;a&&(Mt(e)?e.sign(a):a.forEach((t=>{e.partialSign(t)}))),Mt(e)||e.feePayer||(e.feePayer=n);const i="recent"===s?"confirmed":s;if(Mt(e)){if(!e.message.recentBlockhash){const{blockhash:t}=await r.getLatestBlockhash(i);e.message.recentBlockhash=t}}else if(!e.recentBlockhash){const{blockhash:t}=await r.getLatestBlockhash(i);e.recentBlockhash=t}return e}async getTransactionSignature(t,e){const n=t.publicKey,a=await this.prepareTransaction(t),s=(0,mt.encode)(a.serialize({requireAllSignatures:!1})),r=await this.secureSvmClient.signTransaction({blockchainId:this.networkConfig.blockchainId,publicKey:n.toBase58(),tx:s,uuid:t.uuid,disableTxMutation:t.disableTxMutation},e),i=r.response?.signatures;if(!i)throw r.error;return i}async signTransaction(t,e){const n=await this.getTransactionSignature(t,e),a=n[0];if(n.length>1||Array.isArray(a))throw await(0,o.W)(this.secureSvmClient.sendAndConfirmTransactions({txs:n,blockchainId:this.networkConfig.blockchainId,signOnlyApi:!0})),new Error("Success! Transaction submitted as jito bundle from Backpack.");return Mt(t.tx)?ut.VersionedTransaction.deserialize((0,mt.decode)(a.signedTx)):Nt(a.signedTx)}async signAndSendAllTransactions(t,e){const n=await this.getAllTransactionSignatures(t,e);if(!0===t.skipConfirmationDialog){const e=[],a=n,s="confirmed"===t.commitment||"finalized"===t.commitment?t.commitment:"confirmed";for(const t of a){const n=await this.sendAndConfirmTransaction(t,s,{skipPreflight:!1});e.push(n.txHash)}return e}return(await(0,o.W)(this.secureSvmClient.sendAndConfirmTransactions({txs:n,blockchainId:this.networkConfig.blockchainId,signOnlyApi:!1}))).confirmed.map((t=>t.txHash))}async getAllTransactionSignatures(t,e){const n=t.publicKey,a=await Promise.all(t.txs.map((async e=>{const n=await this.prepareTransaction({publicKey:t.publicKey,tx:e,signers:t.signers,customConnection:t.customConnection,commitment:t.commitment});return(0,mt.encode)(n.serialize({requireAllSignatures:!1}))}))),s=await this.secureSvmClient.signAllTransactions({blockchainId:this.networkConfig.blockchainId,publicKey:n.toBase58(),txs:a,uuid:t.uuid,disableTxMutation:t.disableTxMutation},e);if(!s.response?.signatures)throw s.error;return s.response.signatures}async signAllTransactions(t,e){const n=await this.getAllTransactionSignatures(t,e);if(!this.isSingleTransactions(n))throw await(0,o.W)(this.secureSvmClient.sendAndConfirmTransactions({txs:n,blockchainId:this.networkConfig.blockchainId,signOnlyApi:!0})),new Error("Success! Transactions submitted from Backpack.");return n.map(((e,n)=>Mt(t.txs[n])?ut.VersionedTransaction.deserialize((0,mt.decode)(e.signedTx)):Nt(e.signedTx)))}isSingleTransactions(t){return!t.find((t=>Array.isArray(t)))}async signAndSendTransaction(t,e){const n=t.options,a=n&&"commitment"in n?n.commitment:void 0,s=await this.getTransactionSignature({...t,commitment:a},e);if(s.length>1){const t=await(0,o.W)(this.secureSvmClient.sendAndConfirmTransactions({txs:s,blockchainId:this.networkConfig.blockchainId}));return t.confirmed[t.confirmed.length-1]}return St(s[0],this.solanaRpc)}async sendAndConfirmTransaction(t,e,n){const a=await St(t,this.solanaRpc,n);return{...a,confirmed:await this.confirmTransaction(a.jitoBundleId??a.txHash,e)}}async signSendAndConfirmTransaction(t,e){const n=t.confirmOptions,a=n&&"commitment"in n?n.commitment:void 0,s="finalized"===a?"finalized":"confirmed",r=await this.getTransactionSignature({...t,commitment:a},e),i=await this.secureSvmClient.sendAndConfirmTransactions({txs:r,blockchainId:this.networkConfig.blockchainId,finality:s,autoClose:!0});if(i.error&&i.error.message.includes("Plugin Closed"))throw i.error;if(i.response&&i.response.confirmed.length>0)return i.response.confirmed[i.response.confirmed.length-1];const o=r.flat(),c=o.find((t=>t.metadata?.isExecuteTx))??o[o.length-1];return await Bt(this.solanaRpc,c.txHash,s),{txHash:c.txHash}}async simulate(t){const e=t.publicKey,n=t.options,a=n&&"commitment"in n?n.commitment:void 0,s=await this.prepareTransaction({...t,commitment:a}),r=t.customConnection??this.solanaRpc,i=function(t){if("messageBytes"in t)return(0,xt.oU)(t);const e=t.serialize({requireAllSignatures:!1});return Et.from(e).toString("base64")}(s),o=t.includedAccounts?[...t.includedAccounts,e.toString()].map((t=>(0,lt.Lk)(t))):[(0,lt.Lk)(e.toString())],c=await r.rpc.simulateTransaction(i,{encoding:"base64",accounts:{encoding:"base64",addresses:o},commitment:a||r.commitment}).send();return{err:c.value.err,logs:c.value.logs,accounts:c.value.accounts?.map((t=>t?{executable:t.executable,owner:t.owner,lamports:Number(t.lamports),data:[t.data[0],t.data[1]],rentEpoch:0}:null))||null,unitsConsumed:c.value.unitsConsumed?Number(c.value.unitsConsumed):void 0,returnData:c.value.returnData?{programId:c.value.returnData.programId,data:[c.value.returnData.data[0],"base64"]}:null,preBalances:c.value.preBalances,postBalances:c.value.postBalances,preTokenBalances:c.value.preTokenBalances,postTokenBalances:c.value.postTokenBalances}}async confirmTransaction(t,e){const n="finalized"===this.connection.commitment?this.connection.commitment:"confirmed";return Bt(this.solanaRpc,t,e??n)}}var _t=n(567798),Ot=n(606048),Rt=n(370558),Dt=n(995037),Vt=n(135629),Wt=n(348834).Buffer;class Lt{rpc;rpcSubscriptions;commitment;constructor(t,e="confirmed"){this.commitment=e;const n=function(t){const e=(0,Rt.M)({url:t});return async n=>{if(!(()=>{try{const{hostname:e}=new URL(t);if(["backpack.app","bpinfra.xyz","madlads.com","xnftdata.com","xnfts.dev"].some((t=>e.endsWith(`.${t}`))))return!0}catch(e){console.error("backpack auth transport error",{err:e,url:t})}return!1})())return e(n);const a=[Math.floor(Date.now()),Math.floor(1e4*(0,gt.n)())].join("-"),s=await(async()=>{try{const t=JSON.stringify(n.payload);return await kt(JSON.stringify([t,a,ht.B]))}catch(t){return console.error("Error generating backpack token header",t),"default"}})();return(0,Rt.M)({url:t,headers:{"X-Backpack-Nonce":a,"X-Backpack-Token":s,"X-Backpack-Version":ht.B}})(n)}}(t);this.rpc=(0,_t.Ks)(n);const a=t.replace(/^http/,"ws");this.rpcSubscriptions=(0,Ot.WZ)(a)}async getLatestBlockhash(t){const e=await this.rpc.getLatestBlockhash({commitment:t||this.commitment}).send();return{blockhash:e.value.blockhash,lastValidBlockHeight:e.value.lastValidBlockHeight}}async getAccountInfo(t,e){const n=await this.rpc.getAccountInfo(t,{commitment:e||this.commitment,encoding:"base64"}).send();return n.value?{executable:n.value.executable,owner:n.value.owner,lamports:Number(n.value.lamports),data:Wt.from(n.value.data[0],"base64"),rentEpoch:0}:null}async getMultipleAccountsInfo(t,e){return(await this.rpc.getMultipleAccounts(t,{commitment:e||this.commitment,encoding:"base64"}).send()).value.map((t=>t?{executable:t.executable,owner:t.owner,lamports:Number(t.lamports),data:Wt.from(t.data[0],"base64"),rentEpoch:0}:null))}async getBalance(t,e){const n=await this.rpc.getBalance(t,{commitment:e||this.commitment}).send();return Number(n.value)}async getMinimumBalanceForRentExemption(t,e){const n=await this.rpc.getMinimumBalanceForRentExemption(BigInt(t),{commitment:e||this.commitment}).send();return Number(n)}async getParsedTokenAccountInfo(t,e){const n=await this.getAccountInfo(t,e);if(!n)return null;const a=Dt.p0.decode(n.data);return{programId:n.owner,amount:Number(a.amount)}}async getParsedMintInfo(t,e){const n=await this.getAccountInfo(t,e);if(!n)return null;const a=Vt.qT.decode(n.data);return{mintAuthority:a.mintAuthorityOption?(0,mt.encode)(Uint8Array.from(a.mintAuthority)):"",freezeAuthority:a.freezeAuthorityOption?(0,mt.encode)(Uint8Array.from(a.freezeAuthority)):"",decimals:a.decimals}}async getTokenAccountsByOwner(t,e,n){return{value:(await this.rpc.getTokenAccountsByOwner(t,e,{commitment:n||this.commitment,encoding:"base64"}).send()).value.map((t=>({pubkey:t.pubkey,account:{executable:t.account.executable,owner:t.account.owner,lamports:Number(t.account.lamports),data:Wt.from(t.account.data[0],"base64"),rentEpoch:0}})))}}async getTransaction(t,e){const n=await this.rpc.getTransaction(t,{commitment:e?.commitment||this.commitment,encoding:"json",maxSupportedTransactionVersion:0}).send();return n?{blockTime:n.blockTime?Number(n.blockTime):null,meta:n.meta?{err:n.meta.err,fee:Number(n.meta.fee),preBalances:n.meta.preBalances.map((t=>Number(t))),postBalances:n.meta.postBalances.map((t=>Number(t))),innerInstructions:n.meta.innerInstructions,logMessages:n.meta.logMessages,preTokenBalances:n.meta.preTokenBalances,postTokenBalances:n.meta.postTokenBalances,rewards:n.meta.rewards}:null,slot:Number(n.slot),transaction:n.transaction,version:n.version}:null}async sendRawTransaction(t,e){const n=Wt.from(t).toString("base64");return await this.rpc.sendTransaction(n,{encoding:"base64",skipPreflight:e?.skipPreflight,preflightCommitment:e?.preflightCommitment||this.commitment,maxRetries:e?.maxRetries?BigInt(e.maxRetries):void 0,minContextSlot:e?.minContextSlot?BigInt(e.minContextSlot):void 0}).send()}async getAddressLookupTable(t,e){const n=await this.rpc.getAccountInfo(t,{commitment:e||this.commitment,encoding:"base64"}).send();return n.value?{value:{address:t,data:Wt.from(n.value.data[0],"base64")}}:{value:null}}async getSlot(t){const e=await this.rpc.getSlot({commitment:t||this.commitment}).send();return Number(e)}async getFeeForMessage(t,e){const n=await this.rpc.getFeeForMessage(t,{commitment:e||this.commitment}).send();return{value:null!==n.value?Number(n.value):null}}async getEpochInfo(t){const e=await this.rpc.getEpochInfo({commitment:t||this.commitment}).send();return{epoch:Number(e.epoch),slotIndex:Number(e.slotIndex),slotsInEpoch:Number(e.slotsInEpoch),absoluteSlot:Number(e.absoluteSlot),blockHeight:e.blockHeight?Number(e.blockHeight):void 0,transactionCount:e.transactionCount?Number(e.transactionCount):void 0}}async getProgramAccounts(t,e){return(await this.rpc.getProgramAccounts(t,{commitment:e?.commitment||this.commitment,encoding:"base64",filters:e?.filters?.map((t=>"memcmp"in t?{memcmp:{offset:BigInt(t.memcmp.offset),bytes:t.memcmp.bytes,encoding:"base58"}}:{dataSize:BigInt(t.dataSize)}))}).send()).map((t=>({pubkey:t.pubkey,account:{executable:t.account.executable,owner:t.account.owner,lamports:Number(t.account.lamports),data:Wt.from(t.account.data[0],"base64"),rentEpoch:0}})))}async getInflationReward(t,e){return(await this.rpc.getInflationReward(t,{commitment:e?.commitment||this.commitment,epoch:e?.epoch?BigInt(e.epoch):void 0,minContextSlot:e?.minContextSlot?BigInt(e.minContextSlot):void 0}).send()).map((t=>t?{epoch:Number(t.epoch),effectiveSlot:Number(t.effectiveSlot),amount:Number(t.amount),postBalance:Number(t.postBalance),commission:t.commission??void 0}:null))}async getParsedAccountInfo(t,e){const n=await this.rpc.getAccountInfo(t,{commitment:e||this.commitment,encoding:"jsonParsed"}).send();return n.value?{value:{data:n.value.data,executable:n.value.executable,lamports:Number(n.value.lamports),owner:n.value.owner,rentEpoch:0}}:{value:null}}}var jt=n(325603);const Ft=1e6;class Ht{buildCtx;constructor(t){this.buildCtx=t}async createAndDelegate(t){return await qt.createAndDelegate(await this.buildCtx(t.authority),{lamports:Number(t.lamports),validatorVoteAccount:(0,rt.u)(t.validatorVoteAccount)})}async deactivate(t){return await qt.deactivate(await this.buildCtx(t.authority),{stakeAccount:(0,rt.u)(t.stakeAccount)})}async merge(t){return await qt.merge(await this.buildCtx(t.authority),{stakeAccountToMergeInto:(0,rt.u)(t.stakeAccountToMergeInto),stakeAccountToClose:(0,rt.u)(t.stakeAccountToClose)})}async withdraw(t){return await qt.withdraw(await this.buildCtx(t.authority),{stakeAccount:(0,rt.u)(t.stakeAccount)})}}const qt={async createAndDelegate(t,e){const{solanaClient:n,walletPublicKey:a}=t,{validatorVoteAccount:s,lamports:r}=e,i=ut.Keypair.generate(),o=new ut.Transaction;return o.add(ut.ComputeBudgetProgram.setComputeUnitPrice({microLamports:Ft})),o.add(ut.StakeProgram.createAccount({authorized:new ut.Authorized(a,a),lockup:new ut.Lockup(0,0,a),fromPubkey:a,lamports:r,stakePubkey:i.publicKey})),ut.StakeProgram.delegate({stakePubkey:i.publicKey,authorizedPubkey:a,votePubkey:s}).instructions.forEach((t=>{o.add(new ut.TransactionInstruction(t))})),o.feePayer=a,o.recentBlockhash=await n.getBlockhash(),o.sign(i),await jt.Q.signAndSendTransaction(t,o,{uiOptions:{relevantAccounts:[a.toBase58()]}})},async deactivate(t,e){const{walletPublicKey:n,solanaClient:a}=t,s=ut.StakeProgram.deactivate({stakePubkey:e.stakeAccount,authorizedPubkey:n});return s.add(ut.ComputeBudgetProgram.setComputeUnitPrice({microLamports:Ft})),s.feePayer=n,s.recentBlockhash=await a.getBlockhash(),await jt.Q.signAndSendTransaction(t,s,{uiOptions:{relevantAccounts:[n.toBase58()]}})},async merge(t,e){const{walletPublicKey:n,solanaClient:a}=t,s=ut.StakeProgram.merge({stakePubkey:e.stakeAccountToMergeInto,sourceStakePubKey:e.stakeAccountToClose,authorizedPubkey:n});return s.add(ut.ComputeBudgetProgram.setComputeUnitPrice({microLamports:Ft})),s.feePayer=n,s.recentBlockhash=await a.getBlockhash(),await jt.Q.signAndSendTransaction(t,s,{uiOptions:{relevantAccounts:[n.toBase58()]}})},async withdraw(t,e){const{walletPublicKey:n,solanaClient:a}=t,s=ut.StakeProgram.withdraw({stakePubkey:e.stakeAccount,authorizedPubkey:n,toPubkey:n,lamports:await a.solanaRpc.getBalance((0,dt.IY)(e.stakeAccount))});return s.add(ut.ComputeBudgetProgram.setComputeUnitPrice({microLamports:Ft})),s.feePayer="string"==typeof n?(0,rt.u)(n):n,s.recentBlockhash=await a.getBlockhash(),await jt.Q.signAndSendTransaction(t,s,{uiOptions:{relevantAccounts:[n.toBase58()]}})}};var $t=n(697800);async function Yt(t,e){const n=(0,i.qZ)(e.blockchainId),a=(0,d.zY)(e,n?.rpcUrl),s=(0,d.im)(d.T2,{assetId:t}),r=await(0,d.HL)(s),o=await fetch(`${l.Fv}/v3/graphql`,{method:"POST",headers:{Accept:"application/json","apollographql-client-name":"backpack-secure-clients","Content-Type":"application/json",...a,...r},body:JSON.stringify(s)});return(await o.json()).data.assetProof}n(886266);var zt=n(401642),Gt=n(126249),Jt=n(809535);const Xt=async(t,e)=>{const[n]=await zt.O2.gN.c.findTokenManagerAddress((0,rt.u)(e)),a=await(0,zt.Jo)((()=>zt.O2.gN.MI.getTokenManager(t,n)));if(!a?.parsed)return!1;try{return await zt.O2.WF.MI.getTransferAuthority(t,a?.parsed.transferAuthority||(0,rt.u)("")),!0}catch(t){console.log("Invalid transfer authority")}return!1};async function Zt(t,e){const n=(0,Gt.findMintStatePk)(e),a=await t.getAccountInfo((0,dt.IY)(n));return null!==a?Gt.MintState.fromAccountInfo({...a,owner:(0,rt.u)(a.owner)})[0]:null}async function Qt(t,e){try{return(await Jt.Metadata.fromAccountAddress(t,await(0,yt.HX)((0,rt.u)(e)))).tokenStandard==Jt.TokenStandard.ProgrammableNonFungible}catch(t){return console.log(t),!1}}class te extends c{static prepareSolanaOffchainMessage=Ut.prepareSolanaOffchainMessage;blockchain;secureSvmClient;tokenInterface;connection;solanaRpc;wallet;Stake=new Ht(this.buildCtx.bind(this));recentBlockhash;constructor(t,e){super(),this.secureSvmClient=new it.t(t),this.blockchain=e.blockchain,this.config=(0,i.X2)(a.$O.SOLANA),this.connection=new Tt(e.rpcUrl,e.settings.commitment),this.solanaRpc=new Lt(e.rpcUrl,e.settings.commitment),this.connection.setSolanaRpc(this.solanaRpc),this.wallet=new Ut(this.secureSvmClient,e,this.connection,this.solanaRpc),this.networkConfig=e;const n=ut.Keypair.generate(),s=new st.Y7(this.connection,n,{skipPreflight:!0,commitment:this.connection.commitment});this.tokenInterface=new yt.f1(s)}async buildCtx(t,e){return{walletPublicKey:(0,rt.u)(t),tokenInterface:this.tokenInterface,solanaClient:this,transactionType:e}}async sendAuthenticatedExchangeRequest(t,e={}){return this.secureSvmClient.sendAuthenticatedExchangeRequest(t,e)}async getBlockhash(){const t=async()=>{const{blockhash:t}=await this.solanaRpc.getLatestBlockhash();return t&&(this.recentBlockhash={blockhash:t,ts:Date.now()}),t};return this.recentBlockhash&&this.recentBlockhash?.ts>Date.now()-5e3?(t(),this.recentBlockhash.blockhash):t()}async estimateGas(t){try{const e=ut.Transaction.from((0,mt.decode)(t)),n=(0,i.qZ)(this.networkConfig.blockchainId),a=(0,d.zY)(this.networkConfig,n?.rpcUrl),s=(0,d.im)(d.dF,{transaction:t,caip2:{namespace:this.networkConfig.caip2Namespace,reference:this.networkConfig.caip2Reference}}),r=await(0,d.HL)(s),[o,c]=await Promise.all([e.getEstimatedFee(this.connection),fetch(`${l.Fv}/v3/graphql`,{method:"POST",headers:{Accept:"application/json","apollographql-client-name":"backpack-secure-clients","Content-Type":"application/json",...a,...r},body:JSON.stringify(s)})]),u=await c.json(),m=BigInt(u.data?.priorityFeeEstimate??0);return BigInt(o??5e3)+m+BigInt(l.nN)}catch(t){return BigInt(5e3)}}async fetchBalances({publicKeys:t}){const e=[];for(let n=0;n<Math.ceil(t.length/100);n++)e.push(t.slice(100*n,Math.min(100*n+100,t.length)));const[n,a]=await Promise.all([this.fetchTransferPriorityFee(),Promise.all(e.map((t=>this.solanaRpc.getMultipleAccountsInfo(t.map((t=>(0,lt.Lk)(t)))))))]);return a.flat().map(((e,n)=>{const a=e?BigInt(e.lamports):BigInt(0),s=a;return{publicKey:t[n],balance:a,transferrableBalance:s,index:n}}))}async validateAddress(t,e){let n;if(""===t)return{isValid:!1,isWallet:!1};if(/\.[a-z]{2,}$/.test(t))if(t.endsWith(".sol"))try{n=await(0,at.DB)(this.connection,t)}catch(t){return{isValid:!1,isWallet:!1}}else if(e)try{const e=new ot.TldParser(this.connection);n=await e.getOwnerFromDomainTld(t)}catch(t){return{isValid:!1,isWallet:!1}}if(!n)try{n=(0,rt.u)(t)}catch(t){return{isValid:!1,isWallet:!1}}try{const t=await this.solanaRpc.getAccountInfo((0,dt.IY)(n));if(!t)return{funded:!1,isValid:!0,isWallet:!0,publicKey:n.toString()};const e=(0,dt.IY)(ut.SystemProgram.programId);if(t.owner!==e){const e=t.owner===(0,dt.IY)(yt.H_)||t.owner===(0,dt.IY)(yt.nA),a=82,s=e&&t.data.length===a;return{funded:t.lamports>0,isValid:!0,isWallet:!1,isTokenMintAddress:s,publicKey:n.toString()}}return{funded:t.lamports>0,isValid:!0,isWallet:!0,publicKey:n.toString()}}catch(t){return{rpcFailed:!0,isValid:!0,publicKey:n.toString(),isWallet:!1,funded:!1}}}prefetchedAssets={};prefetch({assetId:t}){this.getBlockhash(),this.prefetchedAssets[t]=Promise.resolve().then((async()=>{const e=await async function(t,e){if(!t)throw new Error("Received empty asset identifier for lookup");const n=(0,i.qZ)(e.blockchainId),a=(0,d.zY)(e,n?.rpcUrl),s=(0,d.im)(d.qv,{assetId:t,assetIdStr:t}),r=await(0,d.HL)(s),o=await fetch(`${l.Fv}/v3/graphql`,{method:"POST",headers:{Accept:"application/json","apollographql-client-name":"backpack-secure-clients","Content-Type":"application/json",...a,...r},body:JSON.stringify(s)}),c=await o.json();return{...c.data?.node,proofData:c.data?.assetProof}}(t,this.networkConfig);if(!e.mint||e.mint===yt.VU.toString())return e;const[n,a,s,r,o,c,u]=await Promise.all([Yt(e.mint,this.networkConfig),(async t=>{const e=await this.solanaRpc.getParsedTokenAccountInfo((0,lt.Lk)(t));if(!e)throw new Error("Asset associated token account not found");return e})("Nft"===e.__typename?e.nonFungibleAta:e.fungibleAta).catch((()=>{})),(async()=>{if("TokenBalance"===e.__typename||"Nft"===e.__typename&&!e.solana?.compressed){const t=await this.solanaRpc.getParsedMintInfo((0,lt.Lk)(e.mint));if(!t)throw new Error("Asset account not found");return t}})().catch((()=>{})),(async()=>{if("Nft"===e.__typename&&e.solana?.compressed&&e.solana?.compression?.tree)return ct.ConcurrentMerkleTreeAccount.fromAccountAddress(this.connection,(0,rt.u)(e.solana.compression.tree),{commitment:this.connection.commitment??"confirmed"})})().catch((()=>{})),Xt(this.connection,(0,rt.u)(e.mint)).catch((()=>!1)),Qt(this.connection,e.mint).catch((()=>!1)),Zt(this.solanaRpc,(0,rt.u)(e.mint)).catch((()=>null))]);return{...e,..."Nft"===e.__typename?{proofData:n}:{},parsedAta:a,parsedMint:s,merkleTree:r,isCardinalWrappedToken:o,isProgrammableNftToken:c,isCreatorStandardToken:!1,isMplCore:"Nft"===e.__typename?"mplcore"===e.type:void 0,openCreatorProtocolMintState:u}}))}getAssetById(t){return this.prefetchedAssets[t]||this.prefetch({assetId:t}),this.prefetchedAssets[t]}async transferAsset(t){const{from:e,to:n,amount:a,assetId:s,memo:r,transactionType:i}=t,o=await this.getAssetById(s),c=await this.buildCtx(e.publicKey,i),l=c.solanaClient;if(!l)throw new Error("SolanaClient not available.");if(!o.mint)throw new Error("Mint Unavailable");let d;try{if(o.mint&&"TokenBalance"!==o.__typename)if(o.solana?.compressed&&o.solana?.compression){if(!o.proofData)throw new Error("No Proof data found.");d=await $t.YP.transferCompressedNft(c,{assetId:s,mint:(0,rt.u)(o.mint),creatorHash:o.solana.compression.creatorHash,dataHash:o.solana.compression.dataHash,leafId:o.solana.compression.leaf,merkleTree:(0,rt.u)(o.solana.compression.tree),proof:o.proofData.proof,recipient:(0,rt.u)(n.publicKey),root:o.proofData.root})}else if(o.isProgrammableNftToken){if(!o.parsedMint||!o.parsedAta)throw new Error("Account data not available");d=await $t.YP.transferProgrammableNft(c,{assetId:s,destination:(0,rt.u)(n.publicKey),mint:(0,rt.u)(o.mint),programId:(0,rt.u)(o.parsedAta.programId),amount:Number(a),decimals:o.parsedMint.decimals,source:(0,rt.u)(o.nonFungibleAta)})}else if(o.openCreatorProtocolMintState){if(!o.parsedAta||!o.parsedMint)throw new Error("Account data not available");d=await $t.YP.transferOpenCreatorProtocol(c,{assetId:s,destination:(0,rt.u)(n.publicKey),amount:Number(a),decimals:o.parsedMint.decimals,mint:(0,rt.u)(o.mint),programId:(0,rt.u)(o.parsedAta.programId)},o.openCreatorProtocolMintState)}else if(o.isCreatorStandardToken){if(!o.parsedMint||!o.parsedAta)throw new Error("Account data not available");d=await $t.YP.transferCreatorStandardToken(c,{assetId:s,destination:(0,rt.u)(n.publicKey),mint:(0,rt.u)(o.mint),programId:(0,rt.u)(o.parsedAta.programId),amount:Number(a),decimals:o.parsedMint.decimals})}else if(o.isCardinalWrappedToken){if(!o.parsedMint||!o.parsedAta)throw new Error("Account data not available");d=await $t.YP.transferCardinalManagedToken(c,{assetId:s,destination:(0,rt.u)(n.publicKey),mint:(0,rt.u)(o.mint),programId:(0,rt.u)(o.parsedAta.programId),amount:Number(a),decimals:o.parsedMint.decimals})}else d=o.isMplCore?await $t.YP.transferMplCoreNft(c,{asset:(0,rt.u)(o.mint),collection:o.collection?(0,rt.u)(o.collection.address):void 0,destination:(0,rt.u)(n.publicKey)}):await $t.YP.transferToken(l,o,e,n,a);else if(o.mint&&o.mint!==this.networkConfig.gasCurrencyAddress)if(o.solana?.compressed){if(!o.parsedMint)throw new Error("Account data not available");d=await $t.YP.transferCompressedToken(c,{amount:a,mint:(0,rt.u)(o.mint),recipient:(0,rt.u)(n.publicKey)})}else{if(!o.parsedAta||!o.parsedMint)throw new Error("Account data not available");d=await $t.YP.transferToken(l,o,e,n,a,r)}else d=await $t.YP.transferSol(c,{source:(0,rt.u)(e.publicKey),destination:(0,rt.u)(n.publicKey),amount:Number(a),memo:r,isMaxAmount:t.isMaxAmount??!1})}catch(t){throw t instanceof Error?t:new Error(t.message??"Solana Send Asset Failed")}return d}async burnAsset(t,e){const{from:n,assetId:a,transactionType:s}=t,r=await this.buildCtx(n.publicKey,s),i=a,o=await this.getAssetById(i);if("Nft"!==o.__typename)throw new Error("Can't burn Fungible token");if(o.solana?.compressed&&o.solana?.compression&&o.proofData){const t=o.proofData;return await $t.YP.burnCompressedNft(r,{assetId:i,mint:(0,rt.u)(o.mint),creatorHash:o.solana.compression.creatorHash,dataHash:o.solana.compression.dataHash,leafId:o.solana.compression.leaf,merkleTree:(0,rt.u)(o.solana.compression.tree),proof:t.proof,root:t.root,tree:o.merkleTree})}if(o.isMplCore)return await $t.YP.burnMetaplexCoreNft(r,{asset:(0,rt.u)(o.mint),collection:o.collection?(0,rt.u)(o.collection.address):void 0});if(!o.parsedAta)throw new Error("Could not parse ATA");return await $t.YP.burnAndCloseNft(r,{assetId:i,solDestination:r.walletPublicKey,mint:(0,rt.u)(o.mint),programId:(0,rt.u)(o.parsedAta.programId),source:o.nonFungibleAta?(0,rt.u)(o.nonFungibleAta):void 0,amount:o.parsedAta.amount})}confirmTransaction(t,e){return this.wallet.confirmTransaction(t,e)}async compressTokenBalance(t,e){const n=await this.buildCtx(t.wallet);return await $t.YP.compressOrDecompressTokenBalance(n,{action:"compress",amount:t.amount,tokenMint:t.tokenMint,tokenProgram:t.tokenProgram})}async decompressTokenBalance(t,e){const n=await this.buildCtx(t.wallet);return await $t.YP.compressOrDecompressTokenBalance(n,{action:"decompress",amount:t.amount,tokenMint:t.tokenMint,tokenProgram:t.tokenProgram})}async fetchTransferPriorityFee(){try{const t=ut.Keypair.generate(),e=(new ut.Transaction).add(ut.SystemProgram.transfer({fromPubkey:t.publicKey,toPubkey:t.publicKey,lamports:1}));return e.recentBlockhash=await this.getBlockhash(),e.feePayer=t.publicKey,this.estimateGas((0,mt.encode)(e.serialize({requireAllSignatures:!1})))}catch{return BigInt(0)}}}var ee=n(199977),ne=n(71093),ae=n(464413),se=n(771229),re=n(380688),ie=n(313929),oe=n(684142),ce=n(341478),le=n(55855);async function de(t,e){if(!t)throw new Error("Received empty asset identifier for lookup");const n=(0,i.qZ)(e.blockchainId),a=(0,d.zY)(e,n?.rpcUrl),s=(0,d.im)(d.vb,{assetId:t}),r=await(0,d.HL)(s),o=await fetch(`${l.Fv}/v3/graphql`,{method:"POST",headers:{Accept:"application/json","apollographql-client-name":"backpack-secure-clients","Content-Type":"application/json",...a,...r},body:JSON.stringify(s)});return(await o.json()).data.node}var ue=n(461763);class me extends c{blockchain;provider;secureSuivmClient;kioskClient;prefetchedAssets={};constructor(t,e){super(),this.secureSuivmClient=new ee.z(t),this.blockchain=e.blockchain,this.config=(0,i.X2)(a.$O.SUI),this.networkConfig=e,this.provider=new re.u({url:e.rpcUrl}),this.kioskClient=new ae.l({client:this.provider,network:e.caip2Reference})}getProvider(){return this.provider}async fetchBalances(t){return(await Promise.all(t.publicKeys.map((async(t,e)=>{const n=await this.provider.getBalance({owner:t}),a=BigInt(n.totalBalance);let s=a-Object.values(n.lockedBalance).reduce(((t,e)=>t+BigInt(e)),BigInt(0));return n.coinType===ce.uq&&(s-=ue.iw),s<BigInt(0)&&(s=BigInt(0)),{publicKey:t,balance:a,transferrableBalance:s,index:e}})))).flat()}estimateGas(t){throw new Error("Method not implemented.")}async validateAddress(t){return(0,le.oI)(t)?{funded:!0,isValid:!0,isWallet:!0,publicKey:t}:{isValid:!1,isWallet:!1}}prefetch({assetId:t}){this.prefetchedAssets[t]=de(t,this.networkConfig)}async transferAsset(t){const{from:e,to:n,amount:a}=t,s=await this.getAssetById(t);if(!s)throw new Error("Asset not available");let r;if("TokenBalance"===s.__typename){if(!s.contractAddress)throw new Error("Contract address not available");const t=new ie.Y;t.setSender(e.publicKey),t.setGasBudget(ue.iw);const i=()=>s.contractAddress===this.networkConfig.gasCurrencyAddress?(0,oe.R)({balance:BigInt(a),useGasCoin:!0}):(0,oe.R)({balance:Number(a),type:s.contractAddress});t.transferObjects([i()],t.pure.address(n.publicKey)),r=await t.build({client:this.provider})}else{if("Nft"!==s.__typename)throw new Error("Unknown asset");if("kiosk"===s.type){const t=s.sui?.kioskOwnerCap;if(!s.sui||!t)throw new Error("No sui data or kioskOwnerCap available");if(!s.objectId)throw new Error("Object Id not available for kiosk NFT transfer");const a={objectId:s.objectId,type:s.sui.objectType};if(s.sui.locked)throw new Error("Unable to transfer locked assets");{const s=new ie.Y;s.setSender(e.publicKey),s.setGasBudget(ue.iw),new se.G({transaction:s,kioskClient:this.kioskClient,cap:{...t,isPersonal:!0}}).transfer({itemId:a.objectId,itemType:a.type,address:n.publicKey}).finalize(),r=await s.build({client:this.provider})}}else{if(!s.objectId)throw new Error("Object Id not available");const t=new ie.Y;t.setSender(e.publicKey),t.setGasBudget(ue.iw),t.transferObjects([t.object(s.objectId)],t.pure.address(n.publicKey)),r=await t.build({client:this.provider})}}const{signature:i,tx:c}=await(0,o.W)(this.secureSuivmClient.signTransaction({tx:(0,ne.s3)(r),publicKey:e.publicKey,blockchainId:this.networkConfig.blockchainId},{uiOptions:{relevantAccounts:[e.publicKey,n.publicKey]},transactionType:t.transactionType}));return(await this.executeTransaction({transactionBlock:c,signature:i,requestType:"WaitForLocalExecution"})).digest}async burnAsset(t){throw new Error("Method not implemented.")}async confirmTransaction(t){try{const e=await this.provider.waitForTransaction({digest:t,options:{showEffects:!0}});if(!e)throw new Error("Unable to confirm transaction");if(t!==e.digest)throw new Error("Unknown digest");if("success"!==e.effects?.status.status)throw new Error(`Transaction failed: ${e.effects?.status.error??"Unknown error"}`);return!0}catch(t){throw new Error(t)}}async executeTransaction(t){return await this.provider.executeTransactionBlock({...t})}async simTransaction({tx:t,senderAddress:e}){const{gasBudget:n,simulationStatus:a,balanceChanges:s,estimatedGasCost:r}=await this._simTransaction(t,e),i=ie.Y.from(t),o=await this.updateTransaction(i,n,e),c=o.getData();return{preparedTx:(0,ne.s3)(await o.build({client:this.provider})),gasBudget:c.gasData.budget?BigInt(c.gasData.budget):void 0,simulationStatus:a,estimatedGasCost:r,balanceChanges:s}}async signTransaction(t,e={}){return await this.secureSuivmClient.signTransaction(t,{...e})}getAssetById({assetId:t}){return this.prefetchedAssets[t]??=de(t,this.networkConfig),this.prefetchedAssets[t]}async updateTransaction(t,e,n){const a=t.getData();return n&&t.setSenderIfNotSet(n),a.gasData.owner&&a.gasData.owner!==a.sender||t.setGasBudgetIfNotSet(e),t}async _simTransaction(t,e){const n=ie.Y.from(t),a=n.getData();n.setSenderIfNotSet(e),n.setGasBudgetIfNotSet(ue.u5),a.gasData.owner&&a.gasData.owner!==a.sender||n.setGasPayment([]);const s=await n.build({client:this.provider}),r=await this.provider.dryRunTransactionBlock({transactionBlock:s}),i=r.effects?.gasUsed,o=r.input.gasData.price,c=this.calculateGasBudget(i,o);return{gasBudget:c>ue.fC?c:ue.fC,estimatedGasCost:BigInt(i.computationCost)+ue.Q6+BigInt(i.storageCost)-BigInt(i.storageRebate),simulationStatus:r.effects.status,balanceChanges:r.balanceChanges}}calculateGasBudget({computationCost:t,storageCost:e,storageRebate:n},a){const s=ue.Q6*BigInt(a||1);return BigInt(t)+s+BigInt(e)-BigInt(n)}}var pe=n(215498),he=n(870201);const ge="transfer(address,uint256)";class fe extends c{blockchain;secureTronVMClient;tron;prefetchedAssets={};constructor(t,e){super(),this.blockchain=e.blockchain,this.config=(0,i.X2)(a.$O.TRON),this.networkConfig=e,this.secureTronVMClient=new pe.H(t),this.tron=new he.CU({fullHost:e.rpcUrl})}async burnAsset(t){throw new Error("Method not implemented.")}async confirmTransaction(t){await new Promise((t=>setTimeout(t,1e3)));try{const e=await this.tron.trx.getTransaction(t);if(!e)throw new Error("Unable to confirm transaction");const n=e.ret?.[0]?.contractRet;if("SUCCESS"!==n)throw new Error(`Transaction failed with status: ${n}`);return!0}catch(t){throw new Error(`Transaction confirmation failed: ${t.message||t}`)}}async fetchBalances(t){return(await Promise.allSettled(t.publicKeys.map((t=>this.tron.trx.getBalance(t))))).map(((e,n)=>{const a="fulfilled"===e.status?e.value:0;return{index:n,balance:BigInt(a),publicKey:t.publicKeys[n],transferrableBalance:BigInt(a)}}))}async estimateGas(t){throw new Error("Method not implemented.")}prefetch({assetId:t}){this.prefetchedAssets[t]=this.getTronAssetById(t,this.networkConfig)}async simulateTransaction(t,e){const n=JSON.parse(t);if(!n.raw_data_hex||!n.raw_data?.contract?.[0])throw new Error("Failed to parse transaction for simulation");const a="TransferContract"===n.raw_data?.contract?.[0]?.type,s=n.raw_data_hex??n.raw_data?.raw_data_hex??"",r=Math.ceil(s.length/2)+3+64+67,[i,o]=await Promise.all([this.tron.trx.getAccount(e),this.tron.trx.getAccountResources(e)]),c=i.balance/10**this.networkConfig.gasCurrencyDecimals,l=.001*r,d=Math.max(0,r-(o.freeNetLimit+(o.NetLimit??0))),u=n.raw_data.contract[0];if(a){const t=this.tron.utils.address.fromHex(u.parameter.value.to_address),n=u.parameter.value.amount,a=await this.validateAddress(t),s=l+(a.isValid&&!a.funded?1:0);return{bandwidth:r,bandwidthShortfall:d,blockaid:{from:e,to:t,value:`0x${n.toString(16)}`},feeEstimate:s,error:c<=s?"Insufficient TRX for transaction fee":void 0}}const m=u.parameter.value;if(!m.data.startsWith("a9059cbb"))return{bandwidth:r,bandwidthShortfall:d,error:"Unknown smart contract trigger discriminant"};const p=this.tron.utils.abi.decodeParams(["to","amount"],["address","uint256"],"0x"+m.data.slice(8)),h=n.raw_data.fee_limit,g=this.tron.address.fromHex(m.contract_address),[f,w]=await Promise.all([this.tron.transactionBuilder.triggerConstantContract(g,ge,{feeLimit:h},we(p),e),this.tron.trx.getChainParameters()]),y=w.find((t=>"getEnergyFee"===t.key))?.value??0;let b;f.result.result&&f.constant_result?.[0]?.endsWith("1")||(b="Transaction failed during simulation");const I=f.energy_used??f.energy_required??0,k=l+I*y/1e6;return!b&&c<=k&&(b="Insufficient TRX for transaction fee"),{bandwidth:r,bandwidthShortfall:d,blockaid:{data:`0x${m.data}`,from:e,to:g},energyEstimate:I,error:b,feeEstimate:k}}async transferAsset(t){const{amount:e,assetId:n,from:a,to:s}=t;try{const t=this.tron.isAddress(a.publicKey),r=this.tron.isAddress(s.publicKey);if(!t)throw new Error("Invalid sender address format");if(!r)throw new Error("Invalid recipient address format");const i=await this.getAssetById({assetId:n});if(!i)throw new Error("Asset not available");let c;if("TokenBalance"!==i.__typename)throw new Error("Unknown asset type");c=i.token===this.networkConfig.gasCurrencyAddress?await this.tron.transactionBuilder.sendTrx(s.publicKey,Number(e),a.publicKey,{blockHeader:{fee_limit:1e6}}):await this.tron.transactionBuilder.triggerSmartContract(i.token,ge,{feeLimit:15e6},we({amount:BigInt(e),to:s.publicKey}),a.publicKey),function(t){return"transaction"in t}(c)&&(c=c.transaction);const l=await(0,o.W)(this.secureTronVMClient.signTransaction({blockchainId:this.networkConfig.blockchainId,publicKey:a.publicKey,tx:JSON.stringify(c)}));return(await this.tron.trx.sendRawTransaction(JSON.parse(l.signedTx))).txid}catch(t){throw new Error(`Transfer failed: ${t||"Unknown error"}`)}}async validateAddress(t){if(!this.tron.isAddress(t))return{isValid:!1,isWallet:!1};try{return{isValid:!0,isWallet:!0,funded:await this.tron.trx.getBalance(t)>0,publicKey:t}}catch{return{isValid:!1,isWallet:!1}}}getAssetById({assetId:t}){return this.prefetchedAssets[t]??=this.getTronAssetById(t,this.networkConfig),this.prefetchedAssets[t]}async getTronAssetById(t,e){if(!t)throw new Error("Received empty asset identifier for lookup");const n=(0,i.qZ)(e.blockchainId),a=(0,d.zY)(e,n?.rpcUrl),s=(0,d.im)(d.dw,{assetId:t}),r=await(0,d.HL)(s),o=await fetch(`${l.Fv}/v3/graphql`,{method:"POST",headers:{Accept:"application/json","apollographql-client-name":"backpack-secure-clients","Content-Type":"application/json",...a,...r},body:JSON.stringify(s)});return(await o.json()).data.node}}const we=({amount:t,to:e})=>[{type:"address",value:e},{type:"uint256",value:t}];function ye(t,e){switch(e.blockchain){case a.$O.SOLANA:return new te(t,e);case a.$O.ETHEREUM:return new nt(t,e);case a.$O.BITCOIN:return new K(t,e);case a.$O.SUI:return new me(t,e);case a.$O.APTOS:return new w(t,e);case a.$O.TRON:return new fe(t,e);default:throw new Error(`Failed to create BlockchainClient. Unknown blockchain: ${e.blockchain}`)}}}}]);