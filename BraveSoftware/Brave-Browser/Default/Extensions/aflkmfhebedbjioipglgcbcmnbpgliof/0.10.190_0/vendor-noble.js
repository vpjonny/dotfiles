/*! For license information please see vendor-noble.js.LICENSE.txt */
"use strict";(globalThis.webpackChunk_coral_xyz_app_extension=globalThis.webpackChunk_coral_xyz_app_extension||[]).push([[6706],{745887:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.getHash=function(t){return{hash:t}},e.createCurve=function(t,e){const n=e=>(0,r.weierstrass)({...t,hash:e});return{...n(e),create:n}};const r=n(57851)},741465:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.wNAF=void 0,e.negateCt=f,e.normalizeZ=function(t,e){const n=(0,o.FpInvertBatch)(t.Fp,e.map((t=>t.Z)));return e.map(((e,r)=>t.fromAffine(e.toAffine(n[r]))))},e.mulEndoUnsafe=function(t,e,n,r){let o=e,f=t.ZERO,a=t.ZERO;for(;n>s||r>s;)n&i&&(f=f.add(o)),r&i&&(a=a.add(o)),o=o.double(),n>>=i,r>>=i;return{p1:f,p2:a}},e.pippenger=function(t,e,n,o){h(n,t),l(o,e);const s=n.length,i=o.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const f=t.ZERO,a=(0,r.bitLen)(BigInt(s));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const u=(0,r.bitMask)(c),d=new Array(Number(u)+1).fill(f);let p=f;for(let t=Math.floor((e.BITS-1)/c)*c;t>=0;t-=c){d.fill(f);for(let e=0;e<i;e++){const r=o[e],s=Number(r>>BigInt(t)&u);d[s]=d[s].add(n[e])}let e=f;for(let t=d.length-1,n=f;t>0;t--)n=n.add(d[t]),e=e.add(n);if(p=p.add(e),0!==t)for(let t=0;t<c;t++)p=p.double()}return p},e.precomputeMSMUnsafe=function(t,e,n,o){a(o,e.BITS),h(n,t);const s=t.ZERO,i=2**o-1,f=Math.ceil(e.BITS/o),c=(0,r.bitMask)(o),u=n.map((t=>{const e=[];for(let n=0,r=t;n<i;n++)e.push(r),r=r.add(t);return e}));return t=>{if(l(t,e),t.length>n.length)throw new Error("array of scalars must be smaller than array of points");let r=s;for(let e=0;e<f;e++){if(r!==s)for(let t=0;t<o;t++)r=r.double();const n=BigInt(f*o-(e+1)*o);for(let e=0;e<t.length;e++){const o=t[e],s=Number(o>>n&c);s&&(r=r.add(u[e][s-1]))}}return r}},e.validateBasic=function(t){return(0,o.validateField)(t.Fp),(0,r.validateObject)(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,o.nLength)(t.n,t.nBitLength),...t,p:t.Fp.ORDER})},e._createCurveFields=function(t,e,n={},r){if(void 0===r&&(r="edwards"===t),!e||"object"!=typeof e)throw new Error(`expected valid ${t} CURVE object`);for(const t of["p","n","h"]){const n=e[t];if(!("bigint"==typeof n&&n>s))throw new Error(`CURVE.${t} must be positive bigint`)}const o=b(e.p,n.Fp,r),i=b(e.n,n.Fn,r),f=["Gx","Gy","a","weierstrass"===t?"b":"d"];for(const t of f)if(!o.isValid(e[t]))throw new Error(`CURVE.${t} must be valid field element of CURVE.Fp`);return{CURVE:e=Object.freeze(Object.assign({},e)),Fp:o,Fn:i}};const r=n(233413),o=n(249530),s=BigInt(0),i=BigInt(1);function f(t,e){const n=e.negate();return t?n:e}function a(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function c(t,e){a(t,e);const n=2**t;return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1),mask:(0,r.bitMask)(t),maxNumber:n,shiftBy:BigInt(t)}}function u(t,e,n){const{windowSize:r,mask:o,maxNumber:s,shiftBy:f}=n;let a=Number(t&o),c=t>>f;a>r&&(a-=s,c+=i);const u=e*r;return{nextN:c,offset:u+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:e%2!=0,offsetF:u}}function h(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach(((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)}))}function l(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach(((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)}))}const d=new WeakMap,p=new WeakMap;function y(t){return p.get(t)||1}function g(t){if(t!==s)throw new Error("invalid wNAF")}function b(t,e,n){if(e){if(e.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return(0,o.validateField)(e),e}return(0,o.Field)(t,{isLE:n})}e.wNAF=class{constructor(t,e){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,n=this.ZERO){let r=t;for(;e>s;)e&i&&(n=n.add(r)),r=r.double(),e>>=i;return n}precomputeWindow(t,e){const{windows:n,windowSize:r}=c(e,this.bits),o=[];let s=t,i=s;for(let t=0;t<n;t++){i=s,o.push(i);for(let t=1;t<r;t++)i=i.add(s),o.push(i);s=i.double()}return o}wNAF(t,e,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let r=this.ZERO,o=this.BASE;const s=c(t,this.bits);for(let t=0;t<s.windows;t++){const{nextN:i,offset:a,isZero:c,isNeg:h,isNegF:l,offsetF:d}=u(n,t,s);n=i,c?o=o.add(f(l,e[d])):r=r.add(f(h,e[a]))}return g(n),{p:r,f:o}}wNAFUnsafe(t,e,n,r=this.ZERO){const o=c(t,this.bits);for(let t=0;t<o.windows&&n!==s;t++){const{nextN:s,offset:i,isZero:f,isNeg:a}=u(n,t,o);if(n=s,!f){const t=e[i];r=r.add(a?t.negate():t)}}return g(n),r}getPrecomputes(t,e,n){let r=d.get(e);return r||(r=this.precomputeWindow(e,t),1!==t&&("function"==typeof n&&(r=n(r)),d.set(e,r))),r}cached(t,e,n){const r=y(t);return this.wNAF(r,this.getPrecomputes(r,t,n),e)}unsafe(t,e,n,r){const o=y(t);return 1===o?this._unsafeLadder(t,e,r):this.wNAFUnsafe(o,this.getPrecomputes(o,t,n),e,r)}createCache(t,e){a(e,this.bits),p.set(t,e),d.delete(t)}hasCache(t){return 1!==y(t)}}},42908:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.PrimeEdwardsPoint=void 0,e.edwards=u,e.eddsa=h,e.twistedEdwards=function(t){const{CURVE:e,curveOpts:n,hash:r,eddsaOpts:o}=function(t){const e={a:t.a,d:t.d,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},n={Fp:t.Fp,Fn:(0,s.Field)(e.n,t.nBitLength,!0),uvRatio:t.uvRatio},r={randomBytes:t.randomBytes,adjustScalarBytes:t.adjustScalarBytes,domain:t.domain,prehash:t.prehash,mapToCurve:t.mapToCurve};return{CURVE:e,curveOpts:n,hash:t.hash,eddsaOpts:r}}(t);return function(t,e){const n=e.Point;return Object.assign({},e,{ExtendedPoint:n,CURVE:t,nBitLength:n.Fn.BITS,nByteLength:n.Fn.BYTES})}(t,h(u(e,n),r,o))};const r=n(233413),o=n(741465),s=n(249530),i=BigInt(0),f=BigInt(1),a=BigInt(2),c=BigInt(8);function u(t,e={}){const n=(0,o._createCurveFields)("edwards",t,e,e.FpFnLE),{Fp:s,Fn:u}=n;let h=n.CURVE;const{h:l}=h;(0,r._validateObject)(e,{},{uvRatio:"function"});const d=a<<BigInt(8*u.BYTES)-f,p=t=>s.create(t),y=e.uvRatio||((t,e)=>{try{return{isValid:!0,value:s.sqrt(s.div(t,e))}}catch(t){return{isValid:!1,value:i}}});if(!function(t,e,n,r){const o=t.sqr(n),s=t.sqr(r),i=t.add(t.mul(e.a,o),s),f=t.add(t.ONE,t.mul(e.d,t.mul(o,s)));return t.eql(i,f)}(s,h,h.Gx,h.Gy))throw new Error("bad curve params: generator point");function g(t,e,n=!1){const o=n?f:i;return(0,r.aInRange)("coordinate "+t,e,o,d),e}function b(t){if(!(t instanceof E))throw new Error("ExtendedPoint expected")}const w=(0,r.memoized)(((t,e)=>{const{X:n,Y:r,Z:o}=t,a=t.is0();null==e&&(e=a?c:s.inv(o));const u=p(n*e),h=p(r*e),l=s.mul(o,e);if(a)return{x:i,y:f};if(l!==f)throw new Error("invZ was invalid");return{x:u,y:h}})),m=(0,r.memoized)((t=>{const{a:e,d:n}=h;if(t.is0())throw new Error("bad point: ZERO");const{X:r,Y:o,Z:s,T:i}=t,f=p(r*r),a=p(o*o),c=p(s*s),u=p(c*c),l=p(f*e);if(p(c*p(l+a))!==p(u+p(n*p(f*a))))throw new Error("bad point: equation left != right (1)");if(p(r*o)!==p(s*i))throw new Error("bad point: equation left != right (2)");return!0}));class E{constructor(t,e,n,r){this.X=g("x",t),this.Y=g("y",e),this.Z=g("z",n,!0),this.T=g("t",r),Object.freeze(this)}static CURVE(){return h}static fromAffine(t){if(t instanceof E)throw new Error("extended point not allowed");const{x:e,y:n}=t||{};return g("x",e),g("y",n),new E(e,n,f,p(e*n))}static fromBytes(t,e=!1){const n=s.BYTES,{a:o,d:a}=h;t=(0,r.copyBytes)((0,r._abytes2)(t,n,"point")),(0,r._abool2)(e,"zip215");const c=(0,r.copyBytes)(t),u=t[n-1];c[n-1]=-129&u;const l=(0,r.bytesToNumberLE)(c),g=e?d:s.ORDER;(0,r.aInRange)("point.y",l,i,g);const b=p(l*l),w=p(b-f),m=p(a*b-o);let{isValid:B,value:v}=y(w,m);if(!B)throw new Error("bad point: invalid y coordinate");const x=(v&f)===f,S=0!=(128&u);if(!e&&v===i&&S)throw new Error("bad point: x=0 and x_0=1");return S!==x&&(v=p(-v)),E.fromAffine({x:v,y:l})}static fromHex(t,e=!1){return E.fromBytes((0,r.ensureBytes)("point",t),e)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(t=8,e=!0){return B.createCache(this,t),e||this.multiply(a),this}assertValidity(){m(this)}equals(t){b(t);const{X:e,Y:n,Z:r}=this,{X:o,Y:s,Z:i}=t,f=p(e*i),a=p(o*r),c=p(n*i),u=p(s*r);return f===a&&c===u}is0(){return this.equals(E.ZERO)}negate(){return new E(p(-this.X),this.Y,this.Z,p(-this.T))}double(){const{a:t}=h,{X:e,Y:n,Z:r}=this,o=p(e*e),s=p(n*n),i=p(a*p(r*r)),f=p(t*o),c=e+n,u=p(p(c*c)-o-s),l=f+s,d=l-i,y=f-s,g=p(u*d),b=p(l*y),w=p(u*y),m=p(d*l);return new E(g,b,m,w)}add(t){b(t);const{a:e,d:n}=h,{X:r,Y:o,Z:s,T:i}=this,{X:f,Y:a,Z:c,T:u}=t,l=p(r*f),d=p(o*a),y=p(i*n*u),g=p(s*c),w=p((r+o)*(f+a)-l-d),m=g-y,B=g+y,v=p(d-e*l),x=p(w*m),S=p(B*v),I=p(w*v),A=p(m*B);return new E(x,S,A,I)}subtract(t){return this.add(t.negate())}multiply(t){if(!u.isValidNot0(t))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:e,f:n}=B.cached(this,t,(t=>(0,o.normalizeZ)(E,t)));return(0,o.normalizeZ)(E,[e,n])[0]}multiplyUnsafe(t,e=E.ZERO){if(!u.isValid(t))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return t===i?E.ZERO:this.is0()||t===f?this:B.unsafe(this,t,(t=>(0,o.normalizeZ)(E,t)),e)}isSmallOrder(){return this.multiplyUnsafe(l).is0()}isTorsionFree(){return B.unsafe(this,h.n).is0()}toAffine(t){return w(this,t)}clearCofactor(){return l===f?this:this.multiplyUnsafe(l)}toBytes(){const{x:t,y:e}=this.toAffine(),n=s.toBytes(e);return n[n.length-1]|=t&f?128:0,n}toHex(){return(0,r.bytesToHex)(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(t){return(0,o.normalizeZ)(E,t)}static msm(t,e){return(0,o.pippenger)(E,u,t,e)}_setWindowSize(t){this.precompute(t)}toRawBytes(){return this.toBytes()}}E.BASE=new E(h.Gx,h.Gy,f,p(h.Gx*h.Gy)),E.ZERO=new E(i,f,f,i),E.Fp=s,E.Fn=u;const B=new o.wNAF(E,u.BITS);return E.BASE.precompute(8),E}function h(t,e,n={}){if("function"!=typeof e)throw new Error('"hash" function param is required');(0,r._validateObject)(n,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:o}=n,{BASE:s,Fp:i,Fn:a}=t,c=n.randomBytes||r.randomBytes,u=n.adjustScalarBytes||(t=>t),h=n.domain||((t,e,n)=>{if((0,r._abool2)(n,"phflag"),e.length||n)throw new Error("Contexts/pre-hash are not supported");return t});function l(t){return a.create((0,r.bytesToNumberLE)(t))}function d(t){const{head:n,prefix:o,scalar:i}=function(t){const n=w.secretKey;t=(0,r.ensureBytes)("private key",t,n);const o=(0,r.ensureBytes)("hashed private key",e(t),2*n),s=u(o.slice(0,n));return{head:s,prefix:o.slice(n,2*n),scalar:l(s)}}(t),f=s.multiply(i),a=f.toBytes();return{head:n,prefix:o,scalar:i,point:f,pointBytes:a}}function p(t){return d(t).pointBytes}function y(t=Uint8Array.of(),...n){const s=(0,r.concatBytes)(...n);return l(e(h(s,(0,r.ensureBytes)("context",t),!!o)))}const g={zip215:!0},b=i.BYTES,w={secretKey:b,publicKey:b,signature:2*b,seed:b};function m(t=c(w.seed)){return(0,r._abytes2)(t,w.seed,"seed")}const E={getExtendedPublicKey:d,randomSecretKey:m,isValidSecretKey:function(t){return(0,r.isBytes)(t)&&t.length===a.BYTES},isValidPublicKey:function(e,n){try{return!!t.fromBytes(e,n)}catch(t){return!1}},toMontgomery(e){const{y:n}=t.fromBytes(e),r=w.publicKey,o=32===r;if(!o&&57!==r)throw new Error("only defined for 25519 and 448");const s=o?i.div(f+n,f-n):i.div(n-f,n+f);return i.toBytes(s)},toMontgomerySecret(t){const n=w.secretKey;(0,r._abytes2)(t,n);const o=e(t.subarray(0,n));return u(o).subarray(0,n)},randomPrivateKey:m,precompute:(e=8,n=t.BASE)=>n.precompute(e,!1)};return Object.freeze({keygen:function(t){const e=E.randomSecretKey(t);return{secretKey:e,publicKey:p(e)}},getPublicKey:p,sign:function(t,e,n={}){t=(0,r.ensureBytes)("message",t),o&&(t=o(t));const{prefix:i,scalar:f,pointBytes:c}=d(e),u=y(n.context,i,t),h=s.multiply(u).toBytes(),l=y(n.context,h,c,t),p=a.create(u+l*f);if(!a.isValid(p))throw new Error("sign failed: invalid s");const g=(0,r.concatBytes)(h,a.toBytes(p));return(0,r._abytes2)(g,w.signature,"result")},verify:function(e,n,i,f=g){const{context:a,zip215:c}=f,u=w.signature;e=(0,r.ensureBytes)("signature",e,u),n=(0,r.ensureBytes)("message",n),i=(0,r.ensureBytes)("publicKey",i,w.publicKey),void 0!==c&&(0,r._abool2)(c,"zip215"),o&&(n=o(n));const h=u/2,l=e.subarray(0,h),d=(0,r.bytesToNumberLE)(e.subarray(h,u));let p,b,m;try{p=t.fromBytes(i,c),b=t.fromBytes(l,c),m=s.multiplyUnsafe(d)}catch(t){return!1}if(!c&&p.isSmallOrder())return!1;const E=y(a,b.toBytes(),p.toBytes(),n);return b.add(p.multiplyUnsafe(E)).subtract(m).clearCofactor().is0()},utils:E,Point:t,lengths:w})}e.PrimeEdwardsPoint=class{constructor(t){this.ep=t}static fromBytes(t){(0,r.notImplemented)()}static fromHex(t){(0,r.notImplemented)()}get x(){return this.toAffine().x}get y(){return this.toAffine().y}clearCofactor(){return this}assertValidity(){this.ep.assertValidity()}toAffine(t){return this.ep.toAffine(t)}toHex(){return(0,r.bytesToHex)(this.toBytes())}toString(){return this.toHex()}isTorsionFree(){return!0}isSmallOrder(){return!1}add(t){return this.assertSame(t),this.init(this.ep.add(t.ep))}subtract(t){return this.assertSame(t),this.init(this.ep.subtract(t.ep))}multiply(t){return this.init(this.ep.multiply(t))}multiplyUnsafe(t){return this.init(this.ep.multiplyUnsafe(t))}double(){return this.init(this.ep.double())}negate(){return this.init(this.ep.negate())}precompute(t,e){return this.init(this.ep.precompute(t,e))}toRawBytes(){return this.toBytes()}}},191322:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e._DST_scalar=void 0,e.expand_message_xmd=u,e.expand_message_xof=h,e.hash_to_field=l,e.isogenyMap=function(t,e){const n=e.map((t=>Array.from(t).reverse()));return(e,r)=>{const[s,i,f,a]=n.map((n=>n.reduce(((n,r)=>t.add(t.mul(n,e),r))))),[c,u]=(0,o.FpInvertBatch)(t,[i,a],!0);return e=t.mul(s,c),r=t.mul(r,t.mul(f,u)),{x:e,y:r}}},e.createHasher=function(t,n,r){if("function"!=typeof n)throw new Error("mapToCurve() must be defined");function o(e){return t.fromAffine(n(e))}function s(e){const n=e.clearCofactor();return n.equals(t.ZERO)?t.ZERO:(n.assertValidity(),n)}return{defaults:r,hashToCurve(t,e){const n=l(t,2,Object.assign({},r,e)),i=o(n[0]),f=o(n[1]);return s(i.add(f))},encodeToCurve(t,e){const n=r.encodeDST?{DST:r.encodeDST}:{};return s(o(l(t,1,Object.assign({},r,n,e))[0]))},mapToCurve(t){if(!Array.isArray(t))throw new Error("expected array of bigints");for(const e of t)if("bigint"!=typeof e)throw new Error("expected array of bigints");return s(o(t))},hashToScalar(n,o){const s=t.Fn.ORDER;return l(n,1,Object.assign({},r,{p:s,m:1,DST:e._DST_scalar},o))[0][0]}}};const r=n(233413),o=n(249530),s=r.bytesToNumberBE;function i(t,e){if(a(t),a(e),t<0||t>=1<<8*e)throw new Error("invalid I2OSP input: "+t);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=255&t,t>>>=8;return new Uint8Array(n)}function f(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function a(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function c(t){if(!(0,r.isBytes)(t)&&"string"!=typeof t)throw new Error("DST must be Uint8Array or string");return"string"==typeof t?(0,r.utf8ToBytes)(t):t}function u(t,e,n,o){(0,r.abytes)(t),a(n),(e=c(e)).length>255&&(e=o((0,r.concatBytes)((0,r.utf8ToBytes)("H2C-OVERSIZE-DST-"),e)));const{outputLen:s,blockLen:u}=o,h=Math.ceil(n/s);if(n>65535||h>255)throw new Error("expand_message_xmd: invalid lenInBytes");const l=(0,r.concatBytes)(e,i(e.length,1)),d=i(0,u),p=i(n,2),y=new Array(h),g=o((0,r.concatBytes)(d,t,p,i(0,1),l));y[0]=o((0,r.concatBytes)(g,i(1,1),l));for(let t=1;t<=h;t++){const e=[f(g,y[t-1]),i(t+1,1),l];y[t]=o((0,r.concatBytes)(...e))}return(0,r.concatBytes)(...y).slice(0,n)}function h(t,e,n,o,s){if((0,r.abytes)(t),a(n),(e=c(e)).length>255){const t=Math.ceil(2*o/8);e=s.create({dkLen:t}).update((0,r.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:n}).update(t).update(i(n,2)).update(e).update(i(e.length,1)).digest()}function l(t,e,n){(0,r._validateObject)(n,{p:"bigint",m:"number",k:"number",hash:"function"});const{p:i,k:f,m:c,hash:l,expand:d,DST:p}=n;if(!(0,r.isHash)(n.hash))throw new Error("expected valid hash");(0,r.abytes)(t),a(e);const y=i.toString(2).length,g=Math.ceil((y+f)/8),b=e*c*g;let w;if("xmd"===d)w=u(t,p,b,l);else if("xof"===d)w=h(t,p,b,f,l);else{if("_internal_pass"!==d)throw new Error('expand must be "xmd" or "xof"');w=t}const m=new Array(e);for(let t=0;t<e;t++){const e=new Array(c);for(let n=0;n<c;n++){const r=g*(n+t*c),f=w.subarray(r,r+g);e[n]=(0,o.mod)(s(f),i)}m[t]=e}return m}e._DST_scalar=(0,r.utf8ToBytes)("HashToScalar-")},249530:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.isNegativeLE=void 0,e.mod=p,e.pow=function(t,e,n){return v(A(n),t,e)},e.pow2=function(t,e,n){let r=t;for(;e-- >o;)r*=r,r%=n;return r},e.invert=y,e.tonelliShanks=m,e.FpSqrt=E,e.validateField=function(t){const e=B.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"});return(0,r._validateObject)(t,e),t},e.FpPow=v,e.FpInvertBatch=x,e.FpDiv=function(t,e,n){return t.mul(e,"bigint"==typeof n?y(n,t.ORDER):t.inv(n))},e.FpLegendre=S,e.FpIsSquare=function(t,e){return 1===S(t,e)},e.nLength=I,e.Field=A,e.FpSqrtOdd=function(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const n=t.sqrt(e);return t.isOdd(n)?n:t.neg(n)},e.FpSqrtEven=function(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const n=t.sqrt(e);return t.isOdd(n)?t.neg(n):n},e.hashToPrivateScalar=function(t,e,n=!1){const o=(t=(0,r.ensureBytes)("privateHash",t)).length,i=I(e).nByteLength+8;if(i<24||o<i||o>1024)throw new Error("hashToPrivateScalar: expected "+i+"-1024 bytes of input, got "+o);return p(n?(0,r.bytesToNumberLE)(t):(0,r.bytesToNumberBE)(t),e-s)+s},e.getFieldBytesLength=O,e.getMinHashLength=_,e.mapHashToField=function(t,e,n=!1){const o=t.length,i=O(e),f=_(e);if(o<16||o<f||o>1024)throw new Error("expected "+f+"-1024 bytes of input, got "+o);const a=p(n?(0,r.bytesToNumberLE)(t):(0,r.bytesToNumberBE)(t),e-s)+s;return n?(0,r.numberToBytesLE)(a,i):(0,r.numberToBytesBE)(a,i)};const r=n(233413),o=BigInt(0),s=BigInt(1),i=BigInt(2),f=BigInt(3),a=BigInt(4),c=BigInt(5),u=BigInt(7),h=BigInt(8),l=BigInt(9),d=BigInt(16);function p(t,e){const n=t%e;return n>=o?n:e+n}function y(t,e){if(t===o)throw new Error("invert: expected non-zero number");if(e<=o)throw new Error("invert: expected positive modulus, got "+e);let n=p(t,e),r=e,i=o,f=s,a=s,c=o;for(;n!==o;){const t=r/n,e=r%n,o=i-a*t,s=f-c*t;r=n,n=e,i=a,f=c,a=o,c=s}if(r!==s)throw new Error("invert: does not exist");return p(i,e)}function g(t,e,n){if(!t.eql(t.sqr(e),n))throw new Error("Cannot find square root")}function b(t,e){const n=(t.ORDER+s)/a,r=t.pow(e,n);return g(t,r,e),r}function w(t,e){const n=(t.ORDER-c)/h,r=t.mul(e,i),o=t.pow(r,n),s=t.mul(e,o),f=t.mul(t.mul(s,i),o),a=t.mul(s,t.sub(f,t.ONE));return g(t,a,e),a}function m(t){if(t<f)throw new Error("sqrt is not defined for small field");let e=t-s,n=0;for(;e%i===o;)e/=i,n++;let r=i;const a=A(t);for(;1===S(a,r);)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===n)return b;let c=a.pow(r,e);const u=(e+s)/i;return function(t,r){if(t.is0(r))return r;if(1!==S(t,r))throw new Error("Cannot find square root");let o=n,i=t.mul(t.ONE,c),f=t.pow(r,e),a=t.pow(r,u);for(;!t.eql(f,t.ONE);){if(t.is0(f))return t.ZERO;let e=1,n=t.sqr(f);for(;!t.eql(n,t.ONE);)if(e++,n=t.sqr(n),e===o)throw new Error("Cannot find square root");const r=s<<BigInt(o-e-1),c=t.pow(i,r);o=e,i=t.sqr(c),f=t.mul(f,i),a=t.mul(a,c)}return a}}function E(t){return t%a===f?b:t%h===c?w:t%d===l?function(t){const e=A(t),n=m(t),r=n(e,e.neg(e.ONE)),o=n(e,r),s=n(e,e.neg(r)),i=(t+u)/d;return(t,e)=>{let n=t.pow(e,i),f=t.mul(n,r);const a=t.mul(n,o),c=t.mul(n,s),u=t.eql(t.sqr(f),e),h=t.eql(t.sqr(a),e);n=t.cmov(n,f,u),f=t.cmov(c,a,h);const l=t.eql(t.sqr(f),e),d=t.cmov(n,f,l);return g(t,d,e),d}}(t):m(t)}e.isNegativeLE=(t,e)=>(p(t,e)&s)===s;const B=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function v(t,e,n){if(n<o)throw new Error("invalid exponent, negatives unsupported");if(n===o)return t.ONE;if(n===s)return e;let r=t.ONE,i=e;for(;n>o;)n&s&&(r=t.mul(r,i)),i=t.sqr(i),n>>=s;return r}function x(t,e,n=!1){const r=new Array(e.length).fill(n?t.ZERO:void 0),o=e.reduce(((e,n,o)=>t.is0(n)?e:(r[o]=e,t.mul(e,n))),t.ONE),s=t.inv(o);return e.reduceRight(((e,n,o)=>t.is0(n)?e:(r[o]=t.mul(e,r[o]),t.mul(e,n))),s),r}function S(t,e){const n=(t.ORDER-s)/i,r=t.pow(e,n),o=t.eql(r,t.ONE),f=t.eql(r,t.ZERO),a=t.eql(r,t.neg(t.ONE));if(!o&&!f&&!a)throw new Error("invalid Legendre symbol result");return o?1:f?0:-1}function I(t,e){void 0!==e&&(0,r.anumber)(e);const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function A(t,e,n=!1,i={}){if(t<=o)throw new Error("invalid field: expected ORDER > 0, got "+t);let f,a,c,u=!1;if("object"==typeof e&&null!=e){if(i.sqrt||n)throw new Error("cannot specify opts in two arguments");const t=e;t.BITS&&(f=t.BITS),t.sqrt&&(a=t.sqrt),"boolean"==typeof t.isLE&&(n=t.isLE),"boolean"==typeof t.modFromBytes&&(u=t.modFromBytes),c=t.allowedLengths}else"number"==typeof e&&(f=e),i.sqrt&&(a=i.sqrt);const{nBitLength:h,nByteLength:l}=I(t,f);if(l>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let d;const g=Object.freeze({ORDER:t,isLE:n,BITS:h,BYTES:l,MASK:(0,r.bitMask)(h),ZERO:o,ONE:s,allowedLengths:c,create:e=>p(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("invalid field element: expected bigint, got "+typeof e);return o<=e&&e<t},is0:t=>t===o,isValidNot0:t=>!g.is0(t)&&g.isValid(t),isOdd:t=>(t&s)===s,neg:e=>p(-e,t),eql:(t,e)=>t===e,sqr:e=>p(e*e,t),add:(e,n)=>p(e+n,t),sub:(e,n)=>p(e-n,t),mul:(e,n)=>p(e*n,t),pow:(t,e)=>v(g,t,e),div:(e,n)=>p(e*y(n,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>y(e,t),sqrt:a||(e=>(d||(d=E(t)),d(g,e))),toBytes:t=>n?(0,r.numberToBytesLE)(t,l):(0,r.numberToBytesBE)(t,l),fromBytes:(e,o=!0)=>{if(c){if(!c.includes(e.length)||e.length>l)throw new Error("Field.fromBytes: expected "+c+" bytes, got "+e.length);const t=new Uint8Array(l);t.set(e,n?0:t.length-e.length),e=t}if(e.length!==l)throw new Error("Field.fromBytes: expected "+l+" bytes, got "+e.length);let s=n?(0,r.bytesToNumberLE)(e):(0,r.bytesToNumberBE)(e);if(u&&(s=p(s,t)),!o&&!g.isValid(s))throw new Error("invalid field element: outside of range 0..ORDER");return s},invertBatch:t=>x(g,t),cmov:(t,e,n)=>n?e:t});return Object.freeze(g)}function O(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function _(t){const e=O(t);return e+Math.ceil(e/2)}},800428:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.montgomery=function(t){const e=(d=t,(0,r._validateObject)(d,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...d})),{P:n,type:a,adjustScalarBytes:c,powPminus2:u,randomBytes:h}=e,l="x25519"===a;var d;if(!l&&"x448"!==a)throw new Error("invalid type");const p=h||r.randomBytes,y=l?255:448,g=l?32:56,b=l?BigInt(9):BigInt(5),w=l?BigInt(121665):BigInt(39081),m=l?f**BigInt(254):f**BigInt(447),E=l?BigInt(8)*f**BigInt(251)-i:BigInt(4)*f**BigInt(445)-i,B=m+E+i,v=t=>(0,o.mod)(t,n),x=S(b);function S(t){return(0,r.numberToBytesLE)(v(t),g)}function I(t,e){const o=function(t,e){(0,r.aInRange)("u",t,s,n),(0,r.aInRange)("scalar",e,m,B);const o=e,f=t;let a=i,c=s,h=t,l=i,d=s;for(let t=BigInt(y-1);t>=s;t--){const e=o>>t&i;d^=e,({x_2:a,x_3:h}=O(d,a,h)),({x_2:c,x_3:l}=O(d,c,l)),d=e;const n=a+c,r=v(n*n),s=a-c,u=v(s*s),p=r-u,y=h+l,g=v((h-l)*n),b=v(y*s),m=g+b,E=g-b;h=v(m*m),l=v(f*v(E*E)),a=v(r*u),c=v(p*(r+v(w*p)))}({x_2:a,x_3:h}=O(d,a,h)),({x_2:c,x_3:l}=O(d,c,l));const p=u(c);return v(a*p)}(function(t){const e=(0,r.ensureBytes)("u coordinate",t,g);return l&&(e[31]&=127),v((0,r.bytesToNumberLE)(e))}(e),function(t){return(0,r.bytesToNumberLE)(c((0,r.ensureBytes)("scalar",t,g)))}(t));if(o===s)throw new Error("invalid private or public key received");return S(o)}function A(t){return I(t,x)}function O(t,e,n){const r=v(t*(e-n));return{x_2:e=v(e-r),x_3:n=v(n+r)}}const _={secretKey:g,publicKey:g,seed:g},R=(t=p(g))=>((0,r.abytes)(t,_.seed),t);return{keygen:function(t){const e=R(t);return{secretKey:e,publicKey:A(e)}},getSharedSecret:(t,e)=>I(t,e),getPublicKey:t=>A(t),scalarMult:I,scalarMultBase:A,utils:{randomSecretKey:R,randomPrivateKey:R},GuBytes:x.slice(),lengths:_}};const r=n(233413),o=n(249530),s=BigInt(0),i=BigInt(1),f=BigInt(2)},57851:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.DER=e.DERErr=void 0,e._splitEndoScalar=c,e._normFnElement=w,e.weierstrassN=m,e.SWUFpSqrtRatio=B,e.mapToCurveSimpleSWU=function(t,e){(0,f.validateField)(t);const{A:n,B:r,Z:o}=e;if(!t.isValid(n)||!t.isValid(r)||!t.isValid(o))throw new Error("mapToCurveSimpleSWU: invalid opts");const s=B(t,o);if(!t.isOdd)throw new Error("Field does not have .isOdd()");return e=>{let i,a,c,u,h,l,d,p;i=t.sqr(e),i=t.mul(i,o),a=t.sqr(i),a=t.add(a,i),c=t.add(a,t.ONE),c=t.mul(c,r),u=t.cmov(o,t.neg(a),!t.eql(a,t.ZERO)),u=t.mul(u,n),a=t.sqr(c),l=t.sqr(u),h=t.mul(l,n),a=t.add(a,h),a=t.mul(a,c),l=t.mul(l,u),h=t.mul(l,r),a=t.add(a,h),d=t.mul(i,c);const{isValid:y,value:g}=s(a,l);p=t.mul(i,e),p=t.mul(p,g),d=t.cmov(d,c,y),p=t.cmov(p,g,y);const b=t.isOdd(e)===t.isOdd(p);p=t.cmov(t.neg(p),p,b);const w=(0,f.FpInvertBatch)(t,[u],!0)[0];return d=t.mul(d,w),{x:d,y:p}}},e.ecdh=x,e.ecdsa=S,e.weierstrassPoints=function(t){const{CURVE:e,curveOpts:n}=I(t);return function(t,e){const{Fp:n,Fn:r}=e;const o=A(n,t.a,t.b);return Object.assign({},{CURVE:t,Point:e,ProjectivePoint:e,normPrivateKeyToScalar:t=>w(r,t),weierstrassEquation:o,isWithinCurveOrder:function(t){return(0,s.inRange)(t,p,r.ORDER)}})}(t,m(e,n))},e._legacyHelperEquat=A,e.weierstrass=function(t){const{CURVE:e,curveOpts:n,hash:r,ecdsaOpts:o}=function(t){const{CURVE:e,curveOpts:n}=I(t),r={hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN};return{CURVE:e,curveOpts:n,hash:t.hash,ecdsaOpts:r}}(t);return function(t,e){const n=e.Point;return Object.assign({},e,{ProjectivePoint:n,CURVE:Object.assign({},t,(0,f.nLength)(n.Fn.ORDER,n.Fn.BITS))})}(t,S(m(e,n),r,o))};const r=n(141377),o=n(870064),s=n(233413),i=n(741465),f=n(249530),a=(t,e)=>(t+(t>=0?e:-e)/y)/e;function c(t,e,n){const[[r,o],[i,f]]=e,c=a(f*t,n),u=a(-o*t,n);let h=t-c*r-u*i,l=-c*o-u*f;const y=h<d,g=l<d;y&&(h=-h),g&&(l=-l);const b=(0,s.bitMask)(Math.ceil((0,s.bitLen)(n)/2))+p;if(h<d||h>=b||l<d||l>=b)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:y,k1:h,k2neg:g,k2:l}}function u(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function h(t,e){const n={};for(let r of Object.keys(e))n[r]=void 0===t[r]?e[r]:t[r];return(0,s._abool2)(n.lowS,"lowS"),(0,s._abool2)(n.prehash,"prehash"),void 0!==n.format&&u(n.format),n}class l extends Error{constructor(t=""){super(t)}}e.DERErr=l,e.DER={Err:l,_tlv:{encode:(t,n)=>{const{Err:r}=e.DER;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(1&n.length)throw new r("tlv.encode: unpadded data");const o=n.length/2,i=(0,s.numberToHexUnpadded)(o);if(i.length/2&128)throw new r("tlv.encode: long form length too big");const f=o>127?(0,s.numberToHexUnpadded)(i.length/2|128):"";return(0,s.numberToHexUnpadded)(t)+f+i+n},decode(t,n){const{Err:r}=e.DER;let o=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(n.length<2||n[o++]!==t)throw new r("tlv.decode: wrong tlv");const s=n[o++];let i=0;if(128&s){const t=127&s;if(!t)throw new r("tlv.decode(long): indefinite length not supported");if(t>4)throw new r("tlv.decode(long): byte length is too big");const e=n.subarray(o,o+t);if(e.length!==t)throw new r("tlv.decode: length bytes not complete");if(0===e[0])throw new r("tlv.decode(long): zero leftmost byte");for(const t of e)i=i<<8|t;if(o+=t,i<128)throw new r("tlv.decode(long): not minimal encoding")}else i=s;const f=n.subarray(o,o+i);if(f.length!==i)throw new r("tlv.decode: wrong value length");return{v:f,l:n.subarray(o+i)}}},_int:{encode(t){const{Err:n}=e.DER;if(t<d)throw new n("integer: negative integers are not allowed");let r=(0,s.numberToHexUnpadded)(t);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new n("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:n}=e.DER;if(128&t[0])throw new n("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new n("invalid signature integer: unnecessary leading zero");return(0,s.bytesToNumberBE)(t)}},toSig(t){const{Err:n,_int:r,_tlv:o}=e.DER,i=(0,s.ensureBytes)("signature",t),{v:f,l:a}=o.decode(48,i);if(a.length)throw new n("invalid signature: left bytes after parsing");const{v:c,l:u}=o.decode(2,f),{v:h,l}=o.decode(2,u);if(l.length)throw new n("invalid signature: left bytes after parsing");return{r:r.decode(c),s:r.decode(h)}},hexFromSig(t){const{_tlv:n,_int:r}=e.DER,o=n.encode(2,r.encode(t.r))+n.encode(2,r.encode(t.s));return n.encode(48,o)}};const d=BigInt(0),p=BigInt(1),y=BigInt(2),g=BigInt(3),b=BigInt(4);function w(t,e){const{BYTES:n}=t;let r;if("bigint"==typeof e)r=e;else{let o=(0,s.ensureBytes)("private key",e);try{r=t.fromBytes(o)}catch(t){throw new Error(`invalid private key: expected ui8a of size ${n}, got ${typeof e}`)}}if(!t.isValidNot0(r))throw new Error("invalid private key: out of range [1..N-1]");return r}function m(t,e={}){const n=(0,i._createCurveFields)("weierstrass",t,e),{Fp:r,Fn:o}=n;let f=n.CURVE;const{h:a,n:u}=f;(0,s._validateObject)(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:h}=e;if(h&&(!r.is0(f.a)||"bigint"!=typeof h.beta||!Array.isArray(h.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const l=v(r,o);function y(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}const m=e.toBytes||function(t,e,n){const{x:o,y:i}=e.toAffine(),f=r.toBytes(o);if((0,s._abool2)(n,"isCompressed"),n){y();const t=!r.isOdd(i);return(0,s.concatBytes)(E(t),f)}return(0,s.concatBytes)(Uint8Array.of(4),f,r.toBytes(i))},B=e.fromBytes||function(t){(0,s._abytes2)(t,void 0,"Point");const{publicKey:e,publicKeyUncompressed:n}=l,o=t.length,i=t[0],f=t.subarray(1);if(o!==e||2!==i&&3!==i){if(o===n&&4===i){const t=r.BYTES,e=r.fromBytes(f.subarray(0,t)),n=r.fromBytes(f.subarray(t,2*t));if(!S(e,n))throw new Error("bad point: is not on curve");return{x:e,y:n}}throw new Error(`bad point: got length ${o}, expected compressed=${e} or uncompressed=${n}`)}{const t=r.fromBytes(f);if(!r.isValid(t))throw new Error("bad point: is not on curve, wrong x");const e=x(t);let n;try{n=r.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("bad point: is not on curve, sqrt error"+e)}return y(),1==(1&i)!==r.isOdd(n)&&(n=r.neg(n)),{x:t,y:n}}};function x(t){const e=r.sqr(t),n=r.mul(e,t);return r.add(r.add(n,r.mul(t,f.a)),f.b)}function S(t,e){const n=r.sqr(e),o=x(t);return r.eql(n,o)}if(!S(f.Gx,f.Gy))throw new Error("bad curve params: generator point");const I=r.mul(r.pow(f.a,g),b),A=r.mul(r.sqr(f.b),BigInt(27));if(r.is0(r.add(I,A)))throw new Error("bad curve params: a or b");function O(t,e,n=!1){if(!r.isValid(e)||n&&r.is0(e))throw new Error(`bad point coordinate ${t}`);return e}function _(t){if(!(t instanceof T))throw new Error("ProjectivePoint expected")}function R(t){if(!h||!h.basises)throw new Error("no endo");return c(t,h.basises,o.ORDER)}const F=(0,s.memoized)(((t,e)=>{const{X:n,Y:o,Z:s}=t;if(r.eql(s,r.ONE))return{x:n,y:o};const i=t.is0();null==e&&(e=i?r.ONE:r.inv(s));const f=r.mul(n,e),a=r.mul(o,e),c=r.mul(s,e);if(i)return{x:r.ZERO,y:r.ZERO};if(!r.eql(c,r.ONE))throw new Error("invZ was invalid");return{x:f,y:a}})),H=(0,s.memoized)((t=>{if(t.is0()){if(e.allowInfinityPoint&&!r.is0(t.Y))return;throw new Error("bad point: ZERO")}const{x:n,y:o}=t.toAffine();if(!r.isValid(n)||!r.isValid(o))throw new Error("bad point: x or y not field elements");if(!S(n,o))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0}));function L(t,e,n,o,s){return n=new T(r.mul(n.X,t),n.Y,n.Z),e=(0,i.negateCt)(o,e),n=(0,i.negateCt)(s,n),e.add(n)}class T{constructor(t,e,n){this.X=O("x",t),this.Y=O("y",e,!0),this.Z=O("z",n),Object.freeze(this)}static CURVE(){return f}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof T)throw new Error("projective point not allowed");return r.is0(e)&&r.is0(n)?T.ZERO:new T(e,n,r.ONE)}static fromBytes(t){const e=T.fromAffine(B((0,s._abytes2)(t,void 0,"point")));return e.assertValidity(),e}static fromHex(t){return T.fromBytes((0,s.ensureBytes)("pointHex",t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(t=8,e=!0){return U.createCache(this,t),e||this.multiply(g),this}assertValidity(){H(this)}hasEvenY(){const{y:t}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(t)}equals(t){_(t);const{X:e,Y:n,Z:o}=this,{X:s,Y:i,Z:f}=t,a=r.eql(r.mul(e,f),r.mul(s,o)),c=r.eql(r.mul(n,f),r.mul(i,o));return a&&c}negate(){return new T(this.X,r.neg(this.Y),this.Z)}double(){const{a:t,b:e}=f,n=r.mul(e,g),{X:o,Y:s,Z:i}=this;let a=r.ZERO,c=r.ZERO,u=r.ZERO,h=r.mul(o,o),l=r.mul(s,s),d=r.mul(i,i),p=r.mul(o,s);return p=r.add(p,p),u=r.mul(o,i),u=r.add(u,u),a=r.mul(t,u),c=r.mul(n,d),c=r.add(a,c),a=r.sub(l,c),c=r.add(l,c),c=r.mul(a,c),a=r.mul(p,a),u=r.mul(n,u),d=r.mul(t,d),p=r.sub(h,d),p=r.mul(t,p),p=r.add(p,u),u=r.add(h,h),h=r.add(u,h),h=r.add(h,d),h=r.mul(h,p),c=r.add(c,h),d=r.mul(s,i),d=r.add(d,d),h=r.mul(d,p),a=r.sub(a,h),u=r.mul(d,l),u=r.add(u,u),u=r.add(u,u),new T(a,c,u)}add(t){_(t);const{X:e,Y:n,Z:o}=this,{X:s,Y:i,Z:a}=t;let c=r.ZERO,u=r.ZERO,h=r.ZERO;const l=f.a,d=r.mul(f.b,g);let p=r.mul(e,s),y=r.mul(n,i),b=r.mul(o,a),w=r.add(e,n),m=r.add(s,i);w=r.mul(w,m),m=r.add(p,y),w=r.sub(w,m),m=r.add(e,o);let E=r.add(s,a);return m=r.mul(m,E),E=r.add(p,b),m=r.sub(m,E),E=r.add(n,o),c=r.add(i,a),E=r.mul(E,c),c=r.add(y,b),E=r.sub(E,c),h=r.mul(l,m),c=r.mul(d,b),h=r.add(c,h),c=r.sub(y,h),h=r.add(y,h),u=r.mul(c,h),y=r.add(p,p),y=r.add(y,p),b=r.mul(l,b),m=r.mul(d,m),y=r.add(y,b),b=r.sub(p,b),b=r.mul(l,b),m=r.add(m,b),p=r.mul(y,m),u=r.add(u,p),p=r.mul(E,m),c=r.mul(w,c),c=r.sub(c,p),p=r.mul(w,y),h=r.mul(E,h),h=r.add(h,p),new T(c,u,h)}subtract(t){return this.add(t.negate())}is0(){return this.equals(T.ZERO)}multiply(t){const{endo:n}=e;if(!o.isValidNot0(t))throw new Error("invalid scalar: out of range");let r,s;const f=t=>U.cached(this,t,(t=>(0,i.normalizeZ)(T,t)));if(n){const{k1neg:e,k1:o,k2neg:i,k2:a}=R(t),{p:c,f:u}=f(o),{p:h,f:l}=f(a);s=u.add(l),r=L(n.beta,c,h,e,i)}else{const{p:e,f:n}=f(t);r=e,s=n}return(0,i.normalizeZ)(T,[r,s])[0]}multiplyUnsafe(t){const{endo:n}=e,r=this;if(!o.isValid(t))throw new Error("invalid scalar: out of range");if(t===d||r.is0())return T.ZERO;if(t===p)return r;if(U.hasCache(this))return this.multiply(t);if(n){const{k1neg:e,k1:o,k2neg:s,k2:f}=R(t),{p1:a,p2:c}=(0,i.mulEndoUnsafe)(T,r,o,f);return L(n.beta,a,c,e,s)}return U.unsafe(r,t)}multiplyAndAddUnsafe(t,e,n){const r=this.multiplyUnsafe(e).add(t.multiplyUnsafe(n));return r.is0()?void 0:r}toAffine(t){return F(this,t)}isTorsionFree(){const{isTorsionFree:t}=e;return a===p||(t?t(T,this):U.unsafe(this,u).is0())}clearCofactor(){const{clearCofactor:t}=e;return a===p?this:t?t(T,this):this.multiplyUnsafe(a)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}toBytes(t=!0){return(0,s._abool2)(t,"isCompressed"),this.assertValidity(),m(T,this,t)}toHex(t=!0){return(0,s.bytesToHex)(this.toBytes(t))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(t=!0){return this.toBytes(t)}_setWindowSize(t){this.precompute(t)}static normalizeZ(t){return(0,i.normalizeZ)(T,t)}static msm(t,e){return(0,i.pippenger)(T,o,t,e)}static fromPrivateKey(t){return T.BASE.multiply(w(o,t))}}T.BASE=new T(f.Gx,f.Gy,r.ONE),T.ZERO=new T(r.ZERO,r.ONE,r.ZERO),T.Fp=r,T.Fn=o;const N=o.BITS,U=new i.wNAF(T,e.endo?Math.ceil(N/2):N);return T.BASE.precompute(8),T}function E(t){return Uint8Array.of(t?2:3)}function B(t,e){const n=t.ORDER;let r=d;for(let t=n-p;t%y===d;t/=y)r+=p;const o=r,s=y<<o-p-p,i=s*y,f=(n-p)/i,a=(f-p)/y,c=i-p,u=s,h=t.pow(e,f),l=t.pow(e,(f+p)/y);let w=(e,n)=>{let r=h,s=t.pow(n,c),i=t.sqr(s);i=t.mul(i,n);let f=t.mul(e,i);f=t.pow(f,a),f=t.mul(f,s),s=t.mul(f,n),i=t.mul(f,e);let d=t.mul(i,s);f=t.pow(d,u);let g=t.eql(f,t.ONE);s=t.mul(i,l),f=t.mul(d,r),i=t.cmov(s,i,g),d=t.cmov(f,d,g);for(let e=o;e>p;e--){let n=e-y;n=y<<n-p;let o=t.pow(d,n);const f=t.eql(o,t.ONE);s=t.mul(i,r),r=t.mul(r,r),o=t.mul(d,r),i=t.cmov(s,i,f),d=t.cmov(o,d,f)}return{isValid:g,value:i}};if(t.ORDER%b===g){const n=(t.ORDER-g)/b,r=t.sqrt(t.neg(e));w=(e,o)=>{let s=t.sqr(o);const i=t.mul(e,o);s=t.mul(s,i);let f=t.pow(s,n);f=t.mul(f,i);const a=t.mul(f,r),c=t.mul(t.sqr(f),o),u=t.eql(c,e);return{isValid:u,value:t.cmov(a,f,u)}}}return w}function v(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function x(t,e={}){const{Fn:n}=t,r=e.randomBytes||s.randomBytes,o=Object.assign(v(t.Fp,n),{seed:(0,f.getMinHashLength)(n.ORDER)});function i(t){try{return!!w(n,t)}catch(t){return!1}}function a(t=r(o.seed)){return(0,f.mapHashToField)((0,s._abytes2)(t,o.seed,"seed"),n.ORDER)}function c(e,r=!0){return t.BASE.multiply(w(n,e)).toBytes(r)}function u(e){if("bigint"==typeof e)return!1;if(e instanceof t)return!0;const{secretKey:r,publicKey:i,publicKeyUncompressed:f}=o;if(n.allowedLengths||r===i)return;const a=(0,s.ensureBytes)("key",e).length;return a===i||a===f}const h={isValidSecretKey:i,isValidPublicKey:function(e,n){const{publicKey:r,publicKeyUncompressed:s}=o;try{const o=e.length;return!(!0===n&&o!==r||!1===n&&o!==s||!t.fromBytes(e))}catch(t){return!1}},randomSecretKey:a,isValidPrivateKey:i,randomPrivateKey:a,normPrivateKeyToScalar:t=>w(n,t),precompute:(e=8,n=t.BASE)=>n.precompute(e,!1)};return Object.freeze({getPublicKey:c,getSharedSecret:function(e,r,o=!0){if(!0===u(e))throw new Error("first arg must be private key");if(!1===u(r))throw new Error("second arg must be public key");const s=w(n,e);return t.fromHex(r).multiply(s).toBytes(o)},keygen:function(t){const e=a(t);return{secretKey:e,publicKey:c(e)}},Point:t,utils:h,lengths:o})}function S(t,n,i={}){(0,o.ahash)(n),(0,s._validateObject)(i,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const f=i.randomBytes||s.randomBytes,a=i.hmac||((t,...e)=>(0,r.hmac)(n,t,(0,s.concatBytes)(...e))),{Fp:c,Fn:l}=t,{ORDER:g,BITS:b}=l,{keygen:m,getPublicKey:B,getSharedSecret:v,utils:S,lengths:I}=x(t,i),A={prehash:!1,lowS:"boolean"==typeof i.lowS&&i.lowS,format:void 0,extraEntropy:!1},O="compact";function _(t){return t>g>>p}function R(t,e){if(!l.isValidNot0(e))throw new Error(`invalid signature ${t}: out of range 1..Point.Fn.ORDER`);return e}class F{constructor(t,e,n){this.r=R("r",t),this.s=R("s",e),null!=n&&(this.recovery=n),Object.freeze(this)}static fromBytes(t,n=O){let r;if(function(t,e){u(e);const n=I.signature,r="compact"===e?n:"recovered"===e?n+1:void 0;(0,s._abytes2)(t,r,`${e} signature`)}(t,n),"der"===n){const{r:n,s:r}=e.DER.toSig((0,s._abytes2)(t));return new F(n,r)}"recovered"===n&&(r=t[0],n="compact",t=t.subarray(1));const o=l.BYTES,i=t.subarray(0,o),f=t.subarray(o,2*o);return new F(l.fromBytes(i),l.fromBytes(f),r)}static fromHex(t,e){return this.fromBytes((0,s.hexToBytes)(t),e)}addRecoveryBit(t){return new F(this.r,this.s,t)}recoverPublicKey(e){const n=c.ORDER,{r,s:o,recovery:i}=this;if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");if(g*y<n&&i>1)throw new Error("recovery id is ambiguous for h>1 curve");const f=2===i||3===i?r+g:r;if(!c.isValid(f))throw new Error("recovery id 2 or 3 invalid");const a=c.toBytes(f),u=t.fromBytes((0,s.concatBytes)(E(0==(1&i)),a)),h=l.inv(f),d=L((0,s.ensureBytes)("msgHash",e)),p=l.create(-d*h),b=l.create(o*h),w=t.BASE.multiplyUnsafe(p).add(u.multiplyUnsafe(b));if(w.is0())throw new Error("point at infinify");return w.assertValidity(),w}hasHighS(){return _(this.s)}toBytes(t=O){if(u(t),"der"===t)return(0,s.hexToBytes)(e.DER.hexFromSig(this));const n=l.toBytes(this.r),r=l.toBytes(this.s);if("recovered"===t){if(null==this.recovery)throw new Error("recovery bit must be present");return(0,s.concatBytes)(Uint8Array.of(this.recovery),n,r)}return(0,s.concatBytes)(n,r)}toHex(t){return(0,s.bytesToHex)(this.toBytes(t))}assertValidity(){}static fromCompact(t){return F.fromBytes((0,s.ensureBytes)("sig",t),"compact")}static fromDER(t){return F.fromBytes((0,s.ensureBytes)("sig",t),"der")}normalizeS(){return this.hasHighS()?new F(this.r,l.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return(0,s.bytesToHex)(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return(0,s.bytesToHex)(this.toBytes("compact"))}}const H=i.bits2int||function(t){if(t.length>8192)throw new Error("input is too large");const e=(0,s.bytesToNumberBE)(t),n=8*t.length-b;return n>0?e>>BigInt(n):e},L=i.bits2int_modN||function(t){return l.create(H(t))},T=(0,s.bitMask)(b);function N(t){return(0,s.aInRange)("num < 2^"+b,t,d,T),l.toBytes(t)}function U(t,e){return(0,s._abytes2)(t,void 0,"message"),e?(0,s._abytes2)(n(t),void 0,"prehashed message"):t}return Object.freeze({keygen:m,getPublicKey:B,getSharedSecret:v,utils:S,lengths:I,Point:t,sign:function(e,r,o={}){e=(0,s.ensureBytes)("message",e);const{seed:i,k2sig:c}=function(e,n,r){if(["recovered","canonical"].some((t=>t in r)))throw new Error("sign() legacy options not supported");const{lowS:o,prehash:i,extraEntropy:a}=h(r,A);e=U(e,i);const c=L(e),u=w(l,n),y=[N(u),N(c)];if(null!=a&&!1!==a){const t=!0===a?f(I.secretKey):a;y.push((0,s.ensureBytes)("extraEntropy",t))}const g=(0,s.concatBytes)(...y),b=c;return{seed:g,k2sig:function(e){const n=H(e);if(!l.isValidNot0(n))return;const r=l.inv(n),s=t.BASE.multiply(n).toAffine(),i=l.create(s.x);if(i===d)return;const f=l.create(r*l.create(b+i*u));if(f===d)return;let a=(s.x===i?0:2)|Number(s.y&p),c=f;return o&&_(f)&&(c=l.neg(f),a^=1),new F(i,c,a)}}}(e,r,o);return(0,s.createHmacDrbg)(n.outputLen,l.BYTES,a)(i,c)},verify:function(n,r,o,i={}){const{lowS:f,prehash:a,format:c}=h(i,A);if(o=(0,s.ensureBytes)("publicKey",o),r=U((0,s.ensureBytes)("message",r),a),"strict"in i)throw new Error("options.strict was renamed to lowS");const u=void 0===c?function(t){let n;const r="string"==typeof t||(0,s.isBytes)(t),o=!r&&null!==t&&"object"==typeof t&&"bigint"==typeof t.r&&"bigint"==typeof t.s;if(!r&&!o)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(o)n=new F(t.r,t.s);else if(r){try{n=F.fromBytes((0,s.ensureBytes)("sig",t),"der")}catch(t){if(!(t instanceof e.DER.Err))throw t}if(!n)try{n=F.fromBytes((0,s.ensureBytes)("sig",t),"compact")}catch(t){return!1}}return n||!1}(n):F.fromBytes((0,s.ensureBytes)("sig",n),c);if(!1===u)return!1;try{const e=t.fromBytes(o);if(f&&u.hasHighS())return!1;const{r:n,s}=u,i=L(r),a=l.inv(s),c=l.create(i*a),h=l.create(n*a),d=t.BASE.multiplyUnsafe(c).add(e.multiplyUnsafe(h));return!d.is0()&&l.create(d.x)===n}catch(t){return!1}},recoverPublicKey:function(t,e,n={}){const{prehash:r}=h(n,A);return e=U(e,r),F.fromBytes(t,"recovered").recoverPublicKey(e).toBytes()},Signature:F,hash:n})}function I(t){const e={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},n=t.Fp;let r=t.allowedPrivateKeyLengths?Array.from(new Set(t.allowedPrivateKeyLengths.map((t=>Math.ceil(t/2))))):void 0;return{CURVE:e,curveOpts:{Fp:n,Fn:(0,f.Field)(e.n,{BITS:t.nBitLength,allowedLengths:r,modFromBytes:t.wrapPrivateKey}),allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes}}}function A(t,e,n){return function(r){const o=t.sqr(r),s=t.mul(o,r);return t.add(t.add(s,t.mul(r,e)),n)}}},416836:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.hash_to_ristretto255=e.hashToRistretto255=e.encodeToCurve=e.hashToCurve=e.RistrettoPoint=e.edwardsToMontgomery=e.ED25519_TORSION_SUBGROUP=e.ristretto255_hasher=e.ristretto255=e.ed25519_hasher=e.x25519=e.ed25519ph=e.ed25519ctx=e.ed25519=void 0,e.edwardsToMontgomeryPub=Z,e.edwardsToMontgomeryPriv=function(t){return e.ed25519.utils.toMontgomerySecret((0,u.ensureBytes)("pub",t))};const r=n(695047),o=n(870064),s=n(741465),i=n(42908),f=n(191322),a=n(249530),c=n(800428),u=n(233413),h=BigInt(0),l=BigInt(1),d=BigInt(2),p=BigInt(3),y=BigInt(5),g=BigInt(8),b=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),w=(()=>({p:b,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:g,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")}))();function m(t){const e=BigInt(10),n=BigInt(20),r=BigInt(40),o=BigInt(80),s=b,i=t*t%s*t%s,f=(0,a.pow2)(i,d,s)*i%s,c=(0,a.pow2)(f,l,s)*t%s,u=(0,a.pow2)(c,y,s)*c%s,h=(0,a.pow2)(u,e,s)*u%s,p=(0,a.pow2)(h,n,s)*h%s,g=(0,a.pow2)(p,r,s)*p%s,w=(0,a.pow2)(g,o,s)*g%s,m=(0,a.pow2)(w,o,s)*g%s,E=(0,a.pow2)(m,e,s)*u%s;return{pow_p_5_8:(0,a.pow2)(E,d,s)*t%s,b2:i}}function E(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}const B=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function v(t,e){const n=b,r=(0,a.mod)(e*e*e,n),o=m(t*(0,a.mod)(r*r*e,n)).pow_p_5_8;let s=(0,a.mod)(t*r*o,n);const i=(0,a.mod)(e*s*s,n),f=s,c=(0,a.mod)(s*B,n),u=i===t,h=i===(0,a.mod)(-t,n),l=i===(0,a.mod)(-t*B,n);return u&&(s=f),(h||l)&&(s=c),(0,a.isNegativeLE)(s,n)&&(s=(0,a.mod)(-s,n)),{isValid:u||h,value:s}}const x=(()=>(0,a.Field)(w.p,{isLE:!0}))(),S=(()=>(0,a.Field)(w.n,{isLE:!0}))(),I=(()=>({...w,Fp:x,hash:r.sha512,adjustScalarBytes:E,uvRatio:v}))();function A(t,e,n){if(e.length>255)throw new Error("Context is too big");return(0,o.concatBytes)((0,o.utf8ToBytes)("SigEd25519 no Ed25519 collisions"),new Uint8Array([n?1:0,e.length]),e,t)}e.ed25519=(0,i.twistedEdwards)(I),e.ed25519ctx=(0,i.twistedEdwards)({...I,domain:A}),e.ed25519ph=(0,i.twistedEdwards)(Object.assign({},I,{domain:A,prehash:r.sha512})),e.x25519=(()=>{const t=x.ORDER;return(0,c.montgomery)({P:t,type:"x25519",powPminus2:e=>{const{pow_p_5_8:n,b2:r}=m(e);return(0,a.mod)((0,a.pow2)(n,p,t)*r,t)},adjustScalarBytes:E})})();const O=(()=>(b+p)/g)(),_=(()=>x.pow(d,O))(),R=(()=>x.sqrt(x.neg(x.ONE)))(),F=(()=>(0,a.FpSqrtEven)(x,x.neg(BigInt(486664))))();e.ed25519_hasher=(0,f.createHasher)(e.ed25519.Point,(t=>function(t){const{xMn:e,xMd:n,yMn:r,yMd:o}=function(t){const e=(b-y)/g,n=BigInt(486662);let r=x.sqr(t);r=x.mul(r,d);let o=x.add(r,x.ONE),s=x.neg(n),i=x.sqr(o),f=x.mul(i,o),a=x.mul(r,n);a=x.mul(a,s),a=x.add(a,i),a=x.mul(a,s);let c=x.sqr(f);i=x.sqr(c),c=x.mul(c,f),c=x.mul(c,a),i=x.mul(i,c);let u=x.pow(i,e);u=x.mul(u,c);let h=x.mul(u,R);i=x.sqr(u),i=x.mul(i,f);let p=x.eql(i,a),w=x.cmov(h,u,p),m=x.mul(s,r),E=x.mul(u,t);E=x.mul(E,_);let B=x.mul(E,R),v=x.mul(a,r);i=x.sqr(E),i=x.mul(i,f);let S=x.eql(i,v),I=x.cmov(B,E,S);i=x.sqr(w),i=x.mul(i,f);let A=x.eql(i,a),O=x.cmov(m,s,A),F=x.cmov(I,w,A),H=x.isOdd(F);return F=x.cmov(F,x.neg(F),A!==H),{xMn:O,xMd:o,yMn:F,yMd:l}}(t);let s=x.mul(e,o);s=x.mul(s,F);let i=x.mul(n,r),f=x.sub(e,n),c=x.add(e,n),u=x.mul(i,c),h=x.eql(u,x.ZERO);s=x.cmov(s,x.ZERO,h),i=x.cmov(i,x.ONE,h),f=x.cmov(f,x.ONE,h),c=x.cmov(c,x.ONE,h);const[p,w]=(0,a.FpInvertBatch)(x,[i,c],!0);return{x:x.mul(s,p),y:x.mul(f,w)}}(t[0])),{DST:"edwards25519_XMD:SHA-512_ELL2_RO_",encodeDST:"edwards25519_XMD:SHA-512_ELL2_NU_",p:b,m:1,k:128,expand:"xmd",hash:r.sha512});const H=B,L=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),T=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),N=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),U=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),k=t=>v(l,t),q=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),P=t=>e.ed25519.Point.Fp.create((0,u.bytesToNumberLE)(t)&q);function D(t){const{d:n}=w,r=b,o=t=>x.create(t),s=o(H*t*t),i=o((s+l)*N);let f=BigInt(-1);const c=o((f-n*s)*o(s+n));let{isValid:u,value:h}=v(i,c),d=o(h*t);(0,a.isNegativeLE)(d,r)||(d=o(-d)),u||(h=d),u||(f=s);const p=o(f*(s-l)*U-c),y=h*h,g=o((h+h)*c),m=o(p*L),E=o(l-y),B=o(l+y);return new e.ed25519.Point(o(g*B),o(E*m),o(m*B),o(g*E))}function C(t){(0,o.abytes)(t,64);const e=D(P(t.subarray(0,32))),n=D(P(t.subarray(32,64)));return new V(e.add(n))}class V extends i.PrimeEdwardsPoint{constructor(t){super(t)}static fromAffine(t){return new V(e.ed25519.Point.fromAffine(t))}assertSame(t){if(!(t instanceof V))throw new Error("RistrettoPoint expected")}init(t){return new V(t)}static hashToCurve(t){return C((0,u.ensureBytes)("ristrettoHash",t,64))}static fromBytes(t){(0,o.abytes)(t,32);const{a:n,d:r}=w,s=b,i=t=>x.create(t),f=P(t);if(!(0,u.equalBytes)(x.toBytes(f),t)||(0,a.isNegativeLE)(f,s))throw new Error("invalid ristretto255 encoding 1");const c=i(f*f),d=i(l+n*c),p=i(l-n*c),y=i(d*d),g=i(p*p),m=i(n*r*y-g),{isValid:E,value:B}=k(i(m*g)),v=i(B*p),S=i(B*v*m);let I=i((f+f)*v);(0,a.isNegativeLE)(I,s)&&(I=i(-I));const A=i(d*S),O=i(I*A);if(!E||(0,a.isNegativeLE)(O,s)||A===h)throw new Error("invalid ristretto255 encoding 2");return new V(new e.ed25519.Point(I,A,l,O))}static fromHex(t){return V.fromBytes((0,u.ensureBytes)("ristrettoHex",t,32))}static msm(t,n){return(0,s.pippenger)(V,e.ed25519.Point.Fn,t,n)}toBytes(){let{X:t,Y:e,Z:n,T:r}=this.ep;const o=b,s=t=>x.create(t),i=s(s(n+e)*s(n-e)),f=s(t*e),c=s(f*f),{value:u}=k(s(i*c)),h=s(u*i),l=s(u*f),d=s(h*l*r);let p;if((0,a.isNegativeLE)(r*d,o)){let n=s(e*H),r=s(t*H);t=n,e=r,p=s(h*T)}else p=l;(0,a.isNegativeLE)(t*d,o)&&(e=s(-e));let y=s((n-e)*p);return(0,a.isNegativeLE)(y,o)&&(y=s(-y)),x.toBytes(y)}equals(t){this.assertSame(t);const{X:e,Y:n}=this.ep,{X:r,Y:o}=t.ep,s=t=>x.create(t),i=s(e*o)===s(n*r),f=s(n*o)===s(e*r);return i||f}is0(){return this.equals(V.ZERO)}}function Z(t){return e.ed25519.utils.toMontgomery((0,u.ensureBytes)("pub",t))}V.BASE=(()=>new V(e.ed25519.Point.BASE))(),V.ZERO=(()=>new V(e.ed25519.Point.ZERO))(),V.Fp=(()=>x)(),V.Fn=(()=>S)(),e.ristretto255={Point:V},e.ristretto255_hasher={hashToCurve(t,e){const n=e?.DST||"ristretto255_XMD:SHA-512_R255MAP_RO_";return C((0,f.expand_message_xmd)(t,n,64,r.sha512))},hashToScalar(t,e={DST:f._DST_scalar}){const n=(0,f.expand_message_xmd)(t,e.DST,64,r.sha512);return S.create((0,u.bytesToNumberLE)(n))}},e.ED25519_TORSION_SUBGROUP=["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],e.edwardsToMontgomery=Z,e.RistrettoPoint=V,e.hashToCurve=e.ed25519_hasher.hashToCurve,e.encodeToCurve=e.ed25519_hasher.encodeToCurve,e.hashToRistretto255=e.ristretto255_hasher.hashToCurve,e.hash_to_ristretto255=e.ristretto255_hasher.hashToCurve},992289:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.p521_hasher=e.secp521r1=e.secp384r1=e.secp256r1=e.p521=e.p384_hasher=e.p384=e.p256_hasher=e.p256=void 0;const r=n(695047),o=n(745887),s=n(191322),i=n(249530),f=n(57851),a={p:BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),h:BigInt(1),a:BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),b:BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")},c={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),h:BigInt(1),a:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),b:BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")},u={p:BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),h:BigInt(1),a:BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),b:BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")},h=(0,i.Field)(a.p),l=(0,i.Field)(c.p),d=(0,i.Field)(u.p);function p(t,e){const n=(0,f.mapToCurveSimpleSWU)(t.Fp,e);return t=>n(t[0])}e.p256=(0,o.createCurve)({...a,Fp:h,lowS:!1},r.sha256),e.p256_hasher=(0,s.createHasher)(e.p256.Point,p(e.p256.Point,{A:a.a,B:a.b,Z:e.p256.Point.Fp.create(BigInt("-10"))}),{DST:"P256_XMD:SHA-256_SSWU_RO_",encodeDST:"P256_XMD:SHA-256_SSWU_NU_",p:a.p,m:1,k:128,expand:"xmd",hash:r.sha256}),e.p384=(0,o.createCurve)({...c,Fp:l,lowS:!1},r.sha384),e.p384_hasher=(0,s.createHasher)(e.p384.Point,p(e.p384.Point,{A:c.a,B:c.b,Z:e.p384.Point.Fp.create(BigInt("-12"))}),{DST:"P384_XMD:SHA-384_SSWU_RO_",encodeDST:"P384_XMD:SHA-384_SSWU_NU_",p:c.p,m:1,k:192,expand:"xmd",hash:r.sha384}),e.p521=(0,o.createCurve)({...u,Fp:d,lowS:!1,allowedPrivateKeyLengths:[130,131,132]},r.sha512),e.secp256r1=e.p256,e.secp384r1=e.p384,e.secp521r1=e.p521,e.p521_hasher=(0,s.createHasher)(e.p521.Point,p(e.p521.Point,{A:u.a,B:u.b,Z:e.p521.Point.Fp.create(BigInt("-4"))}),{DST:"P521_XMD:SHA-512_SSWU_RO_",encodeDST:"P521_XMD:SHA-512_SSWU_NU_",p:u.p,m:1,k:256,expand:"xmd",hash:r.sha512})},354842:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.encodeToCurve=e.hashToCurve=e.secp256r1=e.p256=void 0;const r=n(992289);e.p256=r.p256,e.secp256r1=r.p256,e.hashToCurve=r.p256_hasher.hashToCurve,e.encodeToCurve=r.p256_hasher.encodeToCurve},838358:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.encodeToCurve=e.hashToCurve=e.secp256k1_hasher=e.schnorr=e.secp256k1=void 0;const r=n(695047),o=n(870064),s=n(745887),i=n(191322),f=n(249530),a=n(57851),c=n(233413),u={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},h={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},l=BigInt(0),d=BigInt(1),p=BigInt(2),y=(0,f.Field)(u.p,{sqrt:function(t){const e=u.p,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),h=t*t*t%e,l=h*h*t%e,d=(0,f.pow2)(l,n,e)*l%e,g=(0,f.pow2)(d,n,e)*l%e,b=(0,f.pow2)(g,p,e)*h%e,w=(0,f.pow2)(b,o,e)*b%e,m=(0,f.pow2)(w,s,e)*w%e,E=(0,f.pow2)(m,a,e)*m%e,B=(0,f.pow2)(E,c,e)*E%e,v=(0,f.pow2)(B,a,e)*m%e,x=(0,f.pow2)(v,n,e)*l%e,S=(0,f.pow2)(x,i,e)*w%e,I=(0,f.pow2)(S,r,e)*h%e,A=(0,f.pow2)(I,p,e);if(!y.eql(y.sqr(A),t))throw new Error("Cannot find square root");return A}});e.secp256k1=(0,s.createCurve)({...u,Fp:y,lowS:!0,endo:h},r.sha256);const g={};function b(t,...e){let n=g[t];if(void 0===n){const e=(0,r.sha256)((0,c.utf8ToBytes)(t));n=(0,c.concatBytes)(e,e),g[t]=n}return(0,r.sha256)((0,c.concatBytes)(n,...e))}const w=t=>t.toBytes(!0).slice(1),m=(()=>e.secp256k1.Point)(),E=t=>t%p===l;function B(t){const{Fn:e,BASE:n}=m,r=(0,a._normFnElement)(e,t),o=n.multiply(r);return{scalar:E(o.y)?r:e.neg(r),bytes:w(o)}}function v(t){const e=y;if(!e.isValidNot0(t))throw new Error("invalid x: Fail if x  p");const n=e.create(t*t),r=e.create(n*t+BigInt(7));let o=e.sqrt(r);E(o)||(o=e.neg(o));const s=m.fromAffine({x:t,y:o});return s.assertValidity(),s}const x=c.bytesToNumberBE;function S(...t){return m.Fn.create(x(b("BIP0340/challenge",...t)))}function I(t){return B(t).bytes}function A(t,e,n=(0,o.randomBytes)(32)){const{Fn:r}=m,s=(0,c.ensureBytes)("message",t),{bytes:i,scalar:f}=B(e),a=(0,c.ensureBytes)("auxRand",n,32),u=r.toBytes(f^x(b("BIP0340/aux",a))),h=b("BIP0340/nonce",u,i,s),{bytes:l,scalar:d}=B(h),p=S(l,i,s),y=new Uint8Array(64);if(y.set(l,0),y.set(r.toBytes(r.create(d+p*f)),32),!O(y,s,i))throw new Error("sign: Invalid signature produced");return y}function O(t,e,n){const{Fn:r,BASE:o}=m,s=(0,c.ensureBytes)("signature",t,64),i=(0,c.ensureBytes)("message",e),f=(0,c.ensureBytes)("publicKey",n,32);try{const t=v(x(f)),e=x(s.subarray(0,32));if(!(0,c.inRange)(e,d,u.p))return!1;const n=x(s.subarray(32,64));if(!(0,c.inRange)(n,d,u.n))return!1;const a=S(r.toBytes(e),w(t),i),h=o.multiplyUnsafe(n).add(t.multiplyUnsafe(r.neg(a))),{x:l,y:p}=h.toAffine();return!(h.is0()||!E(p)||l!==e)}catch(t){return!1}}e.schnorr=(()=>{const t=(t=(0,o.randomBytes)(48))=>(0,f.mapHashToField)(t,u.n);return e.secp256k1.utils.randomSecretKey,{keygen:function(e){const n=t(e);return{secretKey:n,publicKey:I(n)}},getPublicKey:I,sign:A,verify:O,Point:m,utils:{randomSecretKey:t,randomPrivateKey:t,taggedHash:b,lift_x:v,pointToBytes:w,numberToBytesBE:c.numberToBytesBE,bytesToNumberBE:c.bytesToNumberBE,mod:f.mod},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})();const _=(()=>(0,i.isogenyMap)(y,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map((t=>t.map((t=>BigInt(t)))))))(),R=(()=>(0,a.mapToCurveSimpleSWU)(y,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:y.create(BigInt("-11"))}))();e.secp256k1_hasher=(0,i.createHasher)(e.secp256k1.Point,(t=>{const{x:e,y:n}=R(y.create(t[0]));return _(e,n)}),{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:y.ORDER,m:1,k:128,expand:"xmd",hash:r.sha256}),e.hashToCurve=e.secp256k1_hasher.hashToCurve,e.encodeToCurve=e.secp256k1_hasher.encodeToCurve},233413:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.notImplemented=e.bitMask=e.utf8ToBytes=e.randomBytes=e.isBytes=e.hexToBytes=e.concatBytes=e.bytesToUtf8=e.bytesToHex=e.anumber=e.abytes=void 0,e.abool=function(t,e){if("boolean"!=typeof e)throw new Error(t+" boolean expected, got "+e)},e._abool2=function(t,e=""){if("boolean"!=typeof t)throw new Error((e&&`"${e}"`)+"expected boolean, got type="+typeof t);return t},e._abytes2=function(t,e,n=""){const o=(0,r.isBytes)(t),s=t?.length,i=void 0!==e;if(!o||i&&s!==e)throw new Error((n&&`"${n}" `)+"expected Uint8Array"+(i?` of length ${e}`:"")+", got "+(o?`length=${s}`:"type="+typeof t));return t},e.numberToHexUnpadded=f,e.hexToNumber=a,e.bytesToNumberBE=function(t){return a((0,r.bytesToHex)(t))},e.bytesToNumberLE=function(t){return(0,r.abytes)(t),a((0,r.bytesToHex)(Uint8Array.from(t).reverse()))},e.numberToBytesBE=c,e.numberToBytesLE=function(t,e){return c(t,e).reverse()},e.numberToVarBytesBE=function(t){return(0,r.hexToBytes)(f(t))},e.ensureBytes=function(t,e,n){let o;if("string"==typeof e)try{o=(0,r.hexToBytes)(e)}catch(e){throw new Error(t+" must be hex string or Uint8Array, cause: "+e)}else{if(!(0,r.isBytes)(e))throw new Error(t+" must be hex string or Uint8Array");o=Uint8Array.from(e)}const s=o.length;if("number"==typeof n&&s!==n)throw new Error(t+" of length "+n+" expected, got "+s);return o},e.equalBytes=function(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return 0===n},e.copyBytes=function(t){return Uint8Array.from(t)},e.asciiToBytes=function(t){return Uint8Array.from(t,((e,n)=>{const r=e.charCodeAt(0);if(1!==e.length||r>127)throw new Error(`string contains non-ASCII character "${t[n]}" with code ${r} at position ${n}`);return r}))},e.inRange=h,e.aInRange=function(t,e,n,r){if(!h(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)},e.bitLen=function(t){let e;for(e=0;t>s;t>>=i,e+=1);return e},e.bitGet=function(t,e){return t>>BigInt(e)&i},e.bitSet=function(t,e,n){return t|(n?i:s)<<BigInt(e)},e.createHmacDrbg=function(t,e,n){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");const o=t=>new Uint8Array(t),s=t=>Uint8Array.of(t);let i=o(t),f=o(t),a=0;const c=()=>{i.fill(1),f.fill(0),a=0},u=(...t)=>n(f,i,...t),h=(t=o(0))=>{f=u(s(0),t),i=u(),0!==t.length&&(f=u(s(1),t),i=u())},l=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const n=[];for(;t<e;){i=u();const e=i.slice();n.push(e),t+=i.length}return(0,r.concatBytes)(...n)};return(t,e)=>{let n;for(c(),h(t);!(n=e(l()));)h();return c(),n}},e.validateObject=function(t,e,n={}){const r=(e,n,r)=>{const o=l[n];if("function"!=typeof o)throw new Error("invalid validator function");const s=t[e];if(!(r&&void 0===s||o(s,t)))throw new Error("param "+String(e)+" is invalid. Expected "+n+", got "+s)};for(const[t,n]of Object.entries(e))r(t,n,!1);for(const[t,e]of Object.entries(n))r(t,e,!0);return t},e.isHash=function(t){return"function"==typeof t&&Number.isSafeInteger(t.outputLen)},e._validateObject=function(t,e,n={}){if(!t||"object"!=typeof t)throw new Error("expected valid options object");function r(e,n,r){const o=t[e];if(r&&void 0===o)return;const s=typeof o;if(s!==n||null===o)throw new Error(`param "${e}" is invalid: expected ${n}, got ${s}`)}Object.entries(e).forEach((([t,e])=>r(t,e,!1))),Object.entries(n).forEach((([t,e])=>r(t,e,!0)))},e.memoized=function(t){const e=new WeakMap;return(n,...r)=>{const o=e.get(n);if(void 0!==o)return o;const s=t(n,...r);return e.set(n,s),s}};const r=n(870064);var o=n(870064);Object.defineProperty(e,"abytes",{enumerable:!0,get:function(){return o.abytes}}),Object.defineProperty(e,"anumber",{enumerable:!0,get:function(){return o.anumber}}),Object.defineProperty(e,"bytesToHex",{enumerable:!0,get:function(){return o.bytesToHex}}),Object.defineProperty(e,"bytesToUtf8",{enumerable:!0,get:function(){return o.bytesToUtf8}}),Object.defineProperty(e,"concatBytes",{enumerable:!0,get:function(){return o.concatBytes}}),Object.defineProperty(e,"hexToBytes",{enumerable:!0,get:function(){return o.hexToBytes}}),Object.defineProperty(e,"isBytes",{enumerable:!0,get:function(){return o.isBytes}}),Object.defineProperty(e,"randomBytes",{enumerable:!0,get:function(){return o.randomBytes}}),Object.defineProperty(e,"utf8ToBytes",{enumerable:!0,get:function(){return o.utf8ToBytes}});const s=BigInt(0),i=BigInt(1);function f(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function a(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?s:BigInt("0x"+t)}function c(t,e){return(0,r.hexToBytes)(t.toString(16).padStart(2*e,"0"))}const u=t=>"bigint"==typeof t&&s<=t;function h(t,e,n){return u(t)&&u(e)&&u(n)&&e<=t&&t<n}e.bitMask=t=>(i<<BigInt(t))-i;const l={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||(0,r.isBytes)(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};e.notImplemented=()=>{throw new Error("not implemented")}},136109:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.BSIGMA=void 0,e.G1s=function(t,e,n,o,s){return t=t+e+s|0,n=n+(o=(0,r.rotr)(o^t,16))|0,{a:t,b:e=(0,r.rotr)(e^n,12),c:n,d:o}},e.G2s=function(t,e,n,o,s){return t=t+e+s|0,n=n+(o=(0,r.rotr)(o^t,8))|0,{a:t,b:e=(0,r.rotr)(e^n,7),c:n,d:o}};const r=n(870064);e.BSIGMA=Uint8Array.from([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9,12,5,1,15,14,13,4,10,0,7,6,3,9,2,8,11,13,11,7,14,12,1,3,9,5,0,15,4,8,6,2,10,6,15,14,9,11,3,0,8,12,2,13,7,1,4,10,5,10,2,8,4,7,6,1,5,15,11,9,14,3,12,13,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9])},98469:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.SHA512_IV=e.SHA384_IV=e.SHA224_IV=e.SHA256_IV=e.HashMD=void 0,e.setBigUint64=o,e.Chi=function(t,e,n){return t&e^~t&n},e.Maj=function(t,e,n){return t&e^t&n^e&n};const r=n(870064);function o(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),i=Number(n>>o&s),f=Number(n&s),a=r?4:0,c=r?0:4;t.setUint32(e+a,i,r),t.setUint32(e+c,f,r)}class s extends r.Hash{constructor(t,e,n,o){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=o,this.buffer=new Uint8Array(t),this.view=(0,r.createView)(this.buffer)}update(t){(0,r.aexists)(this),t=(0,r.toBytes)(t),(0,r.abytes)(t);const{view:e,buffer:n,blockLen:o}=this,s=t.length;for(let i=0;i<s;){const f=Math.min(o-this.pos,s-i);if(f!==o)n.set(t.subarray(i,i+f),this.pos),this.pos+=f,i+=f,this.pos===o&&(this.process(e,0),this.pos=0);else{const e=(0,r.createView)(t);for(;o<=s-i;i+=o)this.process(e,i)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){(0,r.aexists)(this),(0,r.aoutput)(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:s,isLE:i}=this;let{pos:f}=this;e[f++]=128,(0,r.clean)(this.buffer.subarray(f)),this.padOffset>s-f&&(this.process(n,0),f=0);for(let t=f;t<s;t++)e[t]=0;o(n,s-8,BigInt(8*this.length),i),this.process(n,0);const a=(0,r.createView)(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,h=this.get();if(u>h.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<u;t++)a.setUint32(4*t,h[t],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:o,destroyed:s,pos:i}=this;return t.destroyed=s,t.finished=o,t.length=r,t.pos=i,r%e&&t.buffer.set(n),t}clone(){return this._cloneInto()}}e.HashMD=s,e.SHA256_IV=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),e.SHA224_IV=Uint32Array.from([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]),e.SHA384_IV=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),e.SHA512_IV=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209])},411655:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.toBig=e.shrSL=e.shrSH=e.rotrSL=e.rotrSH=e.rotrBL=e.rotrBH=e.rotr32L=e.rotr32H=e.rotlSL=e.rotlSH=e.rotlBL=e.rotlBH=e.add5L=e.add5H=e.add4L=e.add4H=e.add3L=e.add3H=void 0,e.add=m,e.fromBig=o,e.split=s;const n=BigInt(2**32-1),r=BigInt(32);function o(t,e=!1){return e?{h:Number(t&n),l:Number(t>>r&n)}:{h:0|Number(t>>r&n),l:0|Number(t&n)}}function s(t,e=!1){const n=t.length;let r=new Uint32Array(n),s=new Uint32Array(n);for(let i=0;i<n;i++){const{h:n,l:f}=o(t[i],e);[r[i],s[i]]=[n,f]}return[r,s]}const i=(t,e)=>BigInt(t>>>0)<<r|BigInt(e>>>0);e.toBig=i;const f=(t,e,n)=>t>>>n;e.shrSH=f;const a=(t,e,n)=>t<<32-n|e>>>n;e.shrSL=a;const c=(t,e,n)=>t>>>n|e<<32-n;e.rotrSH=c;const u=(t,e,n)=>t<<32-n|e>>>n;e.rotrSL=u;const h=(t,e,n)=>t<<64-n|e>>>n-32;e.rotrBH=h;const l=(t,e,n)=>t>>>n-32|e<<64-n;e.rotrBL=l;const d=(t,e)=>e;e.rotr32H=d;const p=(t,e)=>t;e.rotr32L=p;const y=(t,e,n)=>t<<n|e>>>32-n;e.rotlSH=y;const g=(t,e,n)=>e<<n|t>>>32-n;e.rotlSL=g;const b=(t,e,n)=>e<<n-32|t>>>64-n;e.rotlBH=b;const w=(t,e,n)=>t<<n-32|e>>>64-n;function m(t,e,n,r){const o=(e>>>0)+(r>>>0);return{h:t+n+(o/2**32|0)|0,l:0|o}}e.rotlBL=w;const E=(t,e,n)=>(t>>>0)+(e>>>0)+(n>>>0);e.add3L=E;const B=(t,e,n,r)=>e+n+r+(t/2**32|0)|0;e.add3H=B;const v=(t,e,n,r)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0);e.add4L=v;const x=(t,e,n,r,o)=>e+n+r+o+(t/2**32|0)|0;e.add4H=x;const S=(t,e,n,r,o)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0)+(o>>>0);e.add5L=S;const I=(t,e,n,r,o,s)=>e+n+r+o+s+(t/2**32|0)|0;e.add5H=I;const A={fromBig:o,split:s,toBig:i,shrSH:f,shrSL:a,rotrSH:c,rotrSL:u,rotrBH:h,rotrBL:l,rotr32H:d,rotr32L:p,rotlSH:y,rotlSL:g,rotlBH:b,rotlBL:w,add:m,add3L:E,add3H:B,add4L:v,add4H:x,add5H:I,add5L:S};e.default=A},542263:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.blake2s=e.BLAKE2s=e.blake2b=e.BLAKE2b=e.BLAKE2=void 0,e.compress=p;const r=n(136109),o=n(98469),s=n(411655),i=n(870064),f=Uint32Array.from([4089235720,1779033703,2227873595,3144134277,4271175723,1013904242,1595750129,2773480762,2917565137,1359893119,725511199,2600822924,4215389547,528734635,327033209,1541459225]),a=new Uint32Array(32);function c(t,e,n,r,o,i){const f=o[i],c=o[i+1];let u=a[2*t],h=a[2*t+1],l=a[2*e],d=a[2*e+1],p=a[2*n],y=a[2*n+1],g=a[2*r],b=a[2*r+1],w=s.add3L(u,l,f);h=s.add3H(w,h,d,c),u=0|w,({Dh:b,Dl:g}={Dh:b^h,Dl:g^u}),({Dh:b,Dl:g}={Dh:s.rotr32H(b,g),Dl:s.rotr32L(b,g)}),({h:y,l:p}=s.add(y,p,b,g)),({Bh:d,Bl:l}={Bh:d^y,Bl:l^p}),({Bh:d,Bl:l}={Bh:s.rotrSH(d,l,24),Bl:s.rotrSL(d,l,24)}),a[2*t]=u,a[2*t+1]=h,a[2*e]=l,a[2*e+1]=d,a[2*n]=p,a[2*n+1]=y,a[2*r]=g,a[2*r+1]=b}function u(t,e,n,r,o,i){const f=o[i],c=o[i+1];let u=a[2*t],h=a[2*t+1],l=a[2*e],d=a[2*e+1],p=a[2*n],y=a[2*n+1],g=a[2*r],b=a[2*r+1],w=s.add3L(u,l,f);h=s.add3H(w,h,d,c),u=0|w,({Dh:b,Dl:g}={Dh:b^h,Dl:g^u}),({Dh:b,Dl:g}={Dh:s.rotrSH(b,g,16),Dl:s.rotrSL(b,g,16)}),({h:y,l:p}=s.add(y,p,b,g)),({Bh:d,Bl:l}={Bh:d^y,Bl:l^p}),({Bh:d,Bl:l}={Bh:s.rotrBH(d,l,63),Bl:s.rotrBL(d,l,63)}),a[2*t]=u,a[2*t+1]=h,a[2*e]=l,a[2*e+1]=d,a[2*n]=p,a[2*n+1]=y,a[2*r]=g,a[2*r+1]=b}function h(t,e={},n,r,o){if((0,i.anumber)(n),t<0||t>n)throw new Error("outputLen bigger than keyLen");const{key:s,salt:f,personalization:a}=e;if(void 0!==s&&(s.length<1||s.length>n))throw new Error("key length must be undefined or 1.."+n);if(void 0!==f&&f.length!==r)throw new Error("salt must be undefined or "+r);if(void 0!==a&&a.length!==o)throw new Error("personalization must be undefined or "+o)}class l extends i.Hash{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,this.length=0,this.pos=0,(0,i.anumber)(t),(0,i.anumber)(e),this.blockLen=t,this.outputLen=e,this.buffer=new Uint8Array(t),this.buffer32=(0,i.u32)(this.buffer)}update(t){(0,i.aexists)(this),t=(0,i.toBytes)(t),(0,i.abytes)(t);const{blockLen:e,buffer:n,buffer32:r}=this,o=t.length,s=t.byteOffset,f=t.buffer;for(let a=0;a<o;){this.pos===e&&((0,i.swap32IfBE)(r),this.compress(r,0,!1),(0,i.swap32IfBE)(r),this.pos=0);const c=Math.min(e-this.pos,o-a),u=s+a;if(c!==e||u%4||!(a+c<o))n.set(t.subarray(a,a+c),this.pos),this.pos+=c,this.length+=c,a+=c;else{const t=new Uint32Array(f,u,Math.floor((o-a)/4));(0,i.swap32IfBE)(t);for(let n=0;a+e<o;n+=r.length,a+=e)this.length+=e,this.compress(t,n,!1);(0,i.swap32IfBE)(t)}}return this}digestInto(t){(0,i.aexists)(this),(0,i.aoutput)(t,this);const{pos:e,buffer32:n}=this;this.finished=!0,(0,i.clean)(this.buffer.subarray(e)),(0,i.swap32IfBE)(n),this.compress(n,0,!0),(0,i.swap32IfBE)(n);const r=(0,i.u32)(t);this.get().forEach(((t,e)=>r[e]=(0,i.swap8IfBE)(t)))}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){const{buffer:e,length:n,finished:r,destroyed:o,outputLen:s,pos:i}=this;return t||(t=new this.constructor({dkLen:s})),t.set(...this.get()),t.buffer.set(e),t.destroyed=o,t.finished=r,t.length=n,t.pos=i,t.outputLen=s,t}clone(){return this._cloneInto()}}e.BLAKE2=l;class d extends l{constructor(t={}){const e=void 0===t.dkLen?64:t.dkLen;super(128,e),this.v0l=0|f[0],this.v0h=0|f[1],this.v1l=0|f[2],this.v1h=0|f[3],this.v2l=0|f[4],this.v2h=0|f[5],this.v3l=0|f[6],this.v3h=0|f[7],this.v4l=0|f[8],this.v4h=0|f[9],this.v5l=0|f[10],this.v5h=0|f[11],this.v6l=0|f[12],this.v6h=0|f[13],this.v7l=0|f[14],this.v7h=0|f[15],h(e,t,64,16,16);let{key:n,personalization:r,salt:o}=t,s=0;if(void 0!==n&&(n=(0,i.toBytes)(n),s=n.length),this.v0l^=this.outputLen|s<<8|65536|1<<24,void 0!==o){o=(0,i.toBytes)(o);const t=(0,i.u32)(o);this.v4l^=(0,i.swap8IfBE)(t[0]),this.v4h^=(0,i.swap8IfBE)(t[1]),this.v5l^=(0,i.swap8IfBE)(t[2]),this.v5h^=(0,i.swap8IfBE)(t[3])}if(void 0!==r){r=(0,i.toBytes)(r);const t=(0,i.u32)(r);this.v6l^=(0,i.swap8IfBE)(t[0]),this.v6h^=(0,i.swap8IfBE)(t[1]),this.v7l^=(0,i.swap8IfBE)(t[2]),this.v7h^=(0,i.swap8IfBE)(t[3])}if(void 0!==n){const t=new Uint8Array(this.blockLen);t.set(n),this.update(t)}}get(){let{v0l:t,v0h:e,v1l:n,v1h:r,v2l:o,v2h:s,v3l:i,v3h:f,v4l:a,v4h:c,v5l:u,v5h:h,v6l:l,v6h:d,v7l:p,v7h:y}=this;return[t,e,n,r,o,s,i,f,a,c,u,h,l,d,p,y]}set(t,e,n,r,o,s,i,f,a,c,u,h,l,d,p,y){this.v0l=0|t,this.v0h=0|e,this.v1l=0|n,this.v1h=0|r,this.v2l=0|o,this.v2h=0|s,this.v3l=0|i,this.v3h=0|f,this.v4l=0|a,this.v4h=0|c,this.v5l=0|u,this.v5h=0|h,this.v6l=0|l,this.v6h=0|d,this.v7l=0|p,this.v7h=0|y}compress(t,e,n){this.get().forEach(((t,e)=>a[e]=t)),a.set(f,16);let{h:o,l:h}=s.fromBig(BigInt(this.length));a[24]=f[8]^h,a[25]=f[9]^o,n&&(a[28]=~a[28],a[29]=~a[29]);let l=0;const d=r.BSIGMA;for(let n=0;n<12;n++)c(0,4,8,12,t,e+2*d[l++]),u(0,4,8,12,t,e+2*d[l++]),c(1,5,9,13,t,e+2*d[l++]),u(1,5,9,13,t,e+2*d[l++]),c(2,6,10,14,t,e+2*d[l++]),u(2,6,10,14,t,e+2*d[l++]),c(3,7,11,15,t,e+2*d[l++]),u(3,7,11,15,t,e+2*d[l++]),c(0,5,10,15,t,e+2*d[l++]),u(0,5,10,15,t,e+2*d[l++]),c(1,6,11,12,t,e+2*d[l++]),u(1,6,11,12,t,e+2*d[l++]),c(2,7,8,13,t,e+2*d[l++]),u(2,7,8,13,t,e+2*d[l++]),c(3,4,9,14,t,e+2*d[l++]),u(3,4,9,14,t,e+2*d[l++]);this.v0l^=a[0]^a[16],this.v0h^=a[1]^a[17],this.v1l^=a[2]^a[18],this.v1h^=a[3]^a[19],this.v2l^=a[4]^a[20],this.v2h^=a[5]^a[21],this.v3l^=a[6]^a[22],this.v3h^=a[7]^a[23],this.v4l^=a[8]^a[24],this.v4h^=a[9]^a[25],this.v5l^=a[10]^a[26],this.v5h^=a[11]^a[27],this.v6l^=a[12]^a[28],this.v6h^=a[13]^a[29],this.v7l^=a[14]^a[30],this.v7h^=a[15]^a[31],(0,i.clean)(a)}destroy(){this.destroyed=!0,(0,i.clean)(this.buffer32),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}function p(t,e,n,o,s,i,f,a,c,u,h,l,d,p,y,g,b,w,m,E){let B=0;for(let v=0;v<o;v++)({a:s,b:c,c:d,d:b}=(0,r.G1s)(s,c,d,b,n[e+t[B++]])),({a:s,b:c,c:d,d:b}=(0,r.G2s)(s,c,d,b,n[e+t[B++]])),({a:i,b:u,c:p,d:w}=(0,r.G1s)(i,u,p,w,n[e+t[B++]])),({a:i,b:u,c:p,d:w}=(0,r.G2s)(i,u,p,w,n[e+t[B++]])),({a:f,b:h,c:y,d:m}=(0,r.G1s)(f,h,y,m,n[e+t[B++]])),({a:f,b:h,c:y,d:m}=(0,r.G2s)(f,h,y,m,n[e+t[B++]])),({a,b:l,c:g,d:E}=(0,r.G1s)(a,l,g,E,n[e+t[B++]])),({a,b:l,c:g,d:E}=(0,r.G2s)(a,l,g,E,n[e+t[B++]])),({a:s,b:u,c:y,d:E}=(0,r.G1s)(s,u,y,E,n[e+t[B++]])),({a:s,b:u,c:y,d:E}=(0,r.G2s)(s,u,y,E,n[e+t[B++]])),({a:i,b:h,c:g,d:b}=(0,r.G1s)(i,h,g,b,n[e+t[B++]])),({a:i,b:h,c:g,d:b}=(0,r.G2s)(i,h,g,b,n[e+t[B++]])),({a:f,b:l,c:d,d:w}=(0,r.G1s)(f,l,d,w,n[e+t[B++]])),({a:f,b:l,c:d,d:w}=(0,r.G2s)(f,l,d,w,n[e+t[B++]])),({a,b:c,c:p,d:m}=(0,r.G1s)(a,c,p,m,n[e+t[B++]])),({a,b:c,c:p,d:m}=(0,r.G2s)(a,c,p,m,n[e+t[B++]]));return{v0:s,v1:i,v2:f,v3:a,v4:c,v5:u,v6:h,v7:l,v8:d,v9:p,v10:y,v11:g,v12:b,v13:w,v14:m,v15:E}}e.BLAKE2b=d,e.blake2b=(0,i.createOptHasher)((t=>new d(t)));const y=o.SHA256_IV;class g extends l{constructor(t={}){const e=void 0===t.dkLen?32:t.dkLen;super(64,e),this.v0=0|y[0],this.v1=0|y[1],this.v2=0|y[2],this.v3=0|y[3],this.v4=0|y[4],this.v5=0|y[5],this.v6=0|y[6],this.v7=0|y[7],h(e,t,32,8,8);let{key:n,personalization:r,salt:o}=t,s=0;if(void 0!==n&&(n=(0,i.toBytes)(n),s=n.length),this.v0^=this.outputLen|s<<8|65536|1<<24,void 0!==o){o=(0,i.toBytes)(o);const t=(0,i.u32)(o);this.v4^=(0,i.swap8IfBE)(t[0]),this.v5^=(0,i.swap8IfBE)(t[1])}if(void 0!==r){r=(0,i.toBytes)(r);const t=(0,i.u32)(r);this.v6^=(0,i.swap8IfBE)(t[0]),this.v7^=(0,i.swap8IfBE)(t[1])}if(void 0!==n){(0,i.abytes)(n);const t=new Uint8Array(this.blockLen);t.set(n),this.update(t)}}get(){const{v0:t,v1:e,v2:n,v3:r,v4:o,v5:s,v6:i,v7:f}=this;return[t,e,n,r,o,s,i,f]}set(t,e,n,r,o,s,i,f){this.v0=0|t,this.v1=0|e,this.v2=0|n,this.v3=0|r,this.v4=0|o,this.v5=0|s,this.v6=0|i,this.v7=0|f}compress(t,e,n){const{h:o,l:i}=s.fromBig(BigInt(this.length)),{v0:f,v1:a,v2:c,v3:u,v4:h,v5:l,v6:d,v7:g,v8:b,v9:w,v10:m,v11:E,v12:B,v13:v,v14:x,v15:S}=p(r.BSIGMA,e,t,10,this.v0,this.v1,this.v2,this.v3,this.v4,this.v5,this.v6,this.v7,y[0],y[1],y[2],y[3],i^y[4],o^y[5],n?~y[6]:y[6],y[7]);this.v0^=f^b,this.v1^=a^w,this.v2^=c^m,this.v3^=u^E,this.v4^=h^B,this.v5^=l^v,this.v6^=d^x,this.v7^=g^S}destroy(){this.destroyed=!0,(0,i.clean)(this.buffer32),this.set(0,0,0,0,0,0,0,0)}}e.BLAKE2s=g,e.blake2s=(0,i.createOptHasher)((t=>new g(t)))},513806:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.blake2b=e.BLAKE2b=void 0;const r=n(542263);e.BLAKE2b=r.BLAKE2b,e.blake2b=r.blake2b},270825:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.crypto=void 0,e.crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},141377:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.hmac=e.HMAC=void 0;const r=n(870064);class o extends r.Hash{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,(0,r.ahash)(t);const n=(0,r.toBytes)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(n.length>o?t.create().update(n).digest():n);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),(0,r.clean)(s)}update(t){return(0,r.aexists)(this),this.iHash.update(t),this}digestInto(t){(0,r.aexists)(this),(0,r.abytes)(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:o,blockLen:s,outputLen:i}=this;return t.finished=r,t.destroyed=o,t.blockLen=s,t.outputLen=i,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}e.HMAC=o,e.hmac=(t,e,n)=>new o(t,e).update(n).digest(),e.hmac.create=(t,e)=>new o(t,e)},196178:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ripemd160=e.RIPEMD160=e.md5=e.MD5=e.sha1=e.SHA1=void 0;const r=n(98469),o=n(870064),s=Uint32Array.from([1732584193,4023233417,2562383102,271733878,3285377520]),i=new Uint32Array(80);class f extends r.HashMD{constructor(){super(64,20,8,!1),this.A=0|s[0],this.B=0|s[1],this.C=0|s[2],this.D=0|s[3],this.E=0|s[4]}get(){const{A:t,B:e,C:n,D:r,E:o}=this;return[t,e,n,r,o]}set(t,e,n,r,o){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|o}process(t,e){for(let n=0;n<16;n++,e+=4)i[n]=t.getUint32(e,!1);for(let t=16;t<80;t++)i[t]=(0,o.rotl)(i[t-3]^i[t-8]^i[t-14]^i[t-16],1);let{A:n,B:s,C:f,D:a,E:c}=this;for(let t=0;t<80;t++){let e,u;t<20?(e=(0,r.Chi)(s,f,a),u=1518500249):t<40?(e=s^f^a,u=1859775393):t<60?(e=(0,r.Maj)(s,f,a),u=2400959708):(e=s^f^a,u=3395469782);const h=(0,o.rotl)(n,5)+e+c+u+i[t]|0;c=a,a=f,f=(0,o.rotl)(s,30),s=n,n=h}n=n+this.A|0,s=s+this.B|0,f=f+this.C|0,a=a+this.D|0,c=c+this.E|0,this.set(n,s,f,a,c)}roundClean(){(0,o.clean)(i)}destroy(){this.set(0,0,0,0,0),(0,o.clean)(this.buffer)}}e.SHA1=f,e.sha1=(0,o.createHasher)((()=>new f));const a=Math.pow(2,32),c=Array.from({length:64},((t,e)=>Math.floor(a*Math.abs(Math.sin(e+1))))),u=s.slice(0,4),h=new Uint32Array(16);class l extends r.HashMD{constructor(){super(64,16,8,!0),this.A=0|u[0],this.B=0|u[1],this.C=0|u[2],this.D=0|u[3]}get(){const{A:t,B:e,C:n,D:r}=this;return[t,e,n,r]}set(t,e,n,r){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r}process(t,e){for(let n=0;n<16;n++,e+=4)h[n]=t.getUint32(e,!0);let{A:n,B:s,C:i,D:f}=this;for(let t=0;t<64;t++){let e,a,u;t<16?(e=(0,r.Chi)(s,i,f),a=t,u=[7,12,17,22]):t<32?(e=(0,r.Chi)(f,s,i),a=(5*t+1)%16,u=[5,9,14,20]):t<48?(e=s^i^f,a=(3*t+5)%16,u=[4,11,16,23]):(e=i^(s|~f),a=7*t%16,u=[6,10,15,21]),e=e+n+c[t]+h[a],n=f,f=i,i=s,s+=(0,o.rotl)(e,u[t%4])}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,f=f+this.D|0,this.set(n,s,i,f)}roundClean(){(0,o.clean)(h)}destroy(){this.set(0,0,0,0),(0,o.clean)(this.buffer)}}e.MD5=l,e.md5=(0,o.createHasher)((()=>new l));const d=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),p=(()=>Uint8Array.from(new Array(16).fill(0).map(((t,e)=>e))))(),y=(()=>p.map((t=>(9*t+5)%16)))(),g=(()=>{const t=[[p],[y]];for(let e=0;e<4;e++)for(let n of t)n.push(n[e].map((t=>d[t])));return t})(),b=(()=>g[0])(),w=(()=>g[1])(),m=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((t=>Uint8Array.from(t))),E=b.map(((t,e)=>t.map((t=>m[e][t])))),B=w.map(((t,e)=>t.map((t=>m[e][t])))),v=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),x=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function S(t,e,n,r){return 0===t?e^n^r:1===t?e&n|~e&r:2===t?(e|~n)^r:3===t?e&r|n&~r:e^(n|~r)}const I=new Uint32Array(16);class A extends r.HashMD{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:n,h3:r,h4:o}=this;return[t,e,n,r,o]}set(t,e,n,r,o){this.h0=0|t,this.h1=0|e,this.h2=0|n,this.h3=0|r,this.h4=0|o}process(t,e){for(let n=0;n<16;n++,e+=4)I[n]=t.getUint32(e,!0);let n=0|this.h0,r=n,s=0|this.h1,i=s,f=0|this.h2,a=f,c=0|this.h3,u=c,h=0|this.h4,l=h;for(let t=0;t<5;t++){const e=4-t,d=v[t],p=x[t],y=b[t],g=w[t],m=E[t],A=B[t];for(let e=0;e<16;e++){const r=(0,o.rotl)(n+S(t,s,f,c)+I[y[e]]+d,m[e])+h|0;n=h,h=c,c=0|(0,o.rotl)(f,10),f=s,s=r}for(let t=0;t<16;t++){const n=(0,o.rotl)(r+S(e,i,a,u)+I[g[t]]+p,A[t])+l|0;r=l,l=u,u=0|(0,o.rotl)(a,10),a=i,i=n}}this.set(this.h1+f+u|0,this.h2+c+l|0,this.h3+h+r|0,this.h4+n+i|0,this.h0+s+a|0)}roundClean(){(0,o.clean)(I)}destroy(){this.destroyed=!0,(0,o.clean)(this.buffer),this.set(0,0,0,0,0)}}e.RIPEMD160=A,e.ripemd160=(0,o.createHasher)((()=>new A))},399179:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.pbkdf2=function(t,e,n,r){const{c:f,dkLen:a,DK:c,PRF:u,PRFSalt:h}=s(t,e,n,r);let l;const d=new Uint8Array(4),p=(0,o.createView)(d),y=new Uint8Array(u.outputLen);for(let t=1,e=0;e<a;t++,e+=u.outputLen){const n=c.subarray(e,e+u.outputLen);p.setInt32(0,t,!1),(l=h._cloneInto(l)).update(d).digestInto(y),n.set(y.subarray(0,n.length));for(let t=1;t<f;t++){u._cloneInto(l).update(y).digestInto(y);for(let t=0;t<n.length;t++)n[t]^=y[t]}}return i(u,h,c,l,y)},e.pbkdf2Async=async function(t,e,n,r){const{c:f,dkLen:a,asyncTick:c,DK:u,PRF:h,PRFSalt:l}=s(t,e,n,r);let d;const p=new Uint8Array(4),y=(0,o.createView)(p),g=new Uint8Array(h.outputLen);for(let t=1,e=0;e<a;t++,e+=h.outputLen){const n=u.subarray(e,e+h.outputLen);y.setInt32(0,t,!1),(d=l._cloneInto(d)).update(p).digestInto(g),n.set(g.subarray(0,n.length)),await(0,o.asyncLoop)(f-1,c,(()=>{h._cloneInto(d).update(g).digestInto(g);for(let t=0;t<n.length;t++)n[t]^=g[t]}))}return i(h,l,u,d,g)};const r=n(141377),o=n(870064);function s(t,e,n,s){(0,o.ahash)(t);const i=(0,o.checkOpts)({dkLen:32,asyncTick:10},s),{c:f,dkLen:a,asyncTick:c}=i;if((0,o.anumber)(f),(0,o.anumber)(a),(0,o.anumber)(c),f<1)throw new Error("iterations (c) should be >= 1");const u=(0,o.kdfInputToBytes)(e),h=(0,o.kdfInputToBytes)(n),l=new Uint8Array(a),d=r.hmac.create(t,u),p=d._cloneInto().update(h);return{c:f,dkLen:a,asyncTick:c,DK:l,PRF:d,PRFSalt:p}}function i(t,e,n,r,s){return t.destroy(),e.destroy(),r&&r.destroy(),(0,o.clean)(s),n}},980590:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ripemd160=e.RIPEMD160=void 0;const r=n(196178);e.RIPEMD160=r.RIPEMD160,e.ripemd160=r.ripemd160},768460:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.sha1=e.SHA1=void 0;const r=n(196178);e.SHA1=r.SHA1,e.sha1=r.sha1},695047:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.sha512_224=e.sha512_256=e.sha384=e.sha512=e.sha224=e.sha256=e.SHA512_256=e.SHA512_224=e.SHA384=e.SHA512=e.SHA224=e.SHA256=void 0;const r=n(98469),o=n(411655),s=n(870064),i=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),f=new Uint32Array(64);class a extends r.HashMD{constructor(t=32){super(64,t,8,!1),this.A=0|r.SHA256_IV[0],this.B=0|r.SHA256_IV[1],this.C=0|r.SHA256_IV[2],this.D=0|r.SHA256_IV[3],this.E=0|r.SHA256_IV[4],this.F=0|r.SHA256_IV[5],this.G=0|r.SHA256_IV[6],this.H=0|r.SHA256_IV[7]}get(){const{A:t,B:e,C:n,D:r,E:o,F:s,G:i,H:f}=this;return[t,e,n,r,o,s,i,f]}set(t,e,n,r,o,s,i,f){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|o,this.F=0|s,this.G=0|i,this.H=0|f}process(t,e){for(let n=0;n<16;n++,e+=4)f[n]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=f[t-15],n=f[t-2],r=(0,s.rotr)(e,7)^(0,s.rotr)(e,18)^e>>>3,o=(0,s.rotr)(n,17)^(0,s.rotr)(n,19)^n>>>10;f[t]=o+f[t-7]+r+f[t-16]|0}let{A:n,B:o,C:a,D:c,E:u,F:h,G:l,H:d}=this;for(let t=0;t<64;t++){const e=d+((0,s.rotr)(u,6)^(0,s.rotr)(u,11)^(0,s.rotr)(u,25))+(0,r.Chi)(u,h,l)+i[t]+f[t]|0,p=((0,s.rotr)(n,2)^(0,s.rotr)(n,13)^(0,s.rotr)(n,22))+(0,r.Maj)(n,o,a)|0;d=l,l=h,h=u,u=c+e|0,c=a,a=o,o=n,n=e+p|0}n=n+this.A|0,o=o+this.B|0,a=a+this.C|0,c=c+this.D|0,u=u+this.E|0,h=h+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(n,o,a,c,u,h,l,d)}roundClean(){(0,s.clean)(f)}destroy(){this.set(0,0,0,0,0,0,0,0),(0,s.clean)(this.buffer)}}e.SHA256=a;class c extends a{constructor(){super(28),this.A=0|r.SHA224_IV[0],this.B=0|r.SHA224_IV[1],this.C=0|r.SHA224_IV[2],this.D=0|r.SHA224_IV[3],this.E=0|r.SHA224_IV[4],this.F=0|r.SHA224_IV[5],this.G=0|r.SHA224_IV[6],this.H=0|r.SHA224_IV[7]}}e.SHA224=c;const u=(()=>o.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((t=>BigInt(t)))))(),h=(()=>u[0])(),l=(()=>u[1])(),d=new Uint32Array(80),p=new Uint32Array(80);class y extends r.HashMD{constructor(t=64){super(128,t,16,!1),this.Ah=0|r.SHA512_IV[0],this.Al=0|r.SHA512_IV[1],this.Bh=0|r.SHA512_IV[2],this.Bl=0|r.SHA512_IV[3],this.Ch=0|r.SHA512_IV[4],this.Cl=0|r.SHA512_IV[5],this.Dh=0|r.SHA512_IV[6],this.Dl=0|r.SHA512_IV[7],this.Eh=0|r.SHA512_IV[8],this.El=0|r.SHA512_IV[9],this.Fh=0|r.SHA512_IV[10],this.Fl=0|r.SHA512_IV[11],this.Gh=0|r.SHA512_IV[12],this.Gl=0|r.SHA512_IV[13],this.Hh=0|r.SHA512_IV[14],this.Hl=0|r.SHA512_IV[15]}get(){const{Ah:t,Al:e,Bh:n,Bl:r,Ch:o,Cl:s,Dh:i,Dl:f,Eh:a,El:c,Fh:u,Fl:h,Gh:l,Gl:d,Hh:p,Hl:y}=this;return[t,e,n,r,o,s,i,f,a,c,u,h,l,d,p,y]}set(t,e,n,r,o,s,i,f,a,c,u,h,l,d,p,y){this.Ah=0|t,this.Al=0|e,this.Bh=0|n,this.Bl=0|r,this.Ch=0|o,this.Cl=0|s,this.Dh=0|i,this.Dl=0|f,this.Eh=0|a,this.El=0|c,this.Fh=0|u,this.Fl=0|h,this.Gh=0|l,this.Gl=0|d,this.Hh=0|p,this.Hl=0|y}process(t,e){for(let n=0;n<16;n++,e+=4)d[n]=t.getUint32(e),p[n]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|d[t-15],n=0|p[t-15],r=o.rotrSH(e,n,1)^o.rotrSH(e,n,8)^o.shrSH(e,n,7),s=o.rotrSL(e,n,1)^o.rotrSL(e,n,8)^o.shrSL(e,n,7),i=0|d[t-2],f=0|p[t-2],a=o.rotrSH(i,f,19)^o.rotrBH(i,f,61)^o.shrSH(i,f,6),c=o.rotrSL(i,f,19)^o.rotrBL(i,f,61)^o.shrSL(i,f,6),u=o.add4L(s,c,p[t-7],p[t-16]),h=o.add4H(u,r,a,d[t-7],d[t-16]);d[t]=0|h,p[t]=0|u}let{Ah:n,Al:r,Bh:s,Bl:i,Ch:f,Cl:a,Dh:c,Dl:u,Eh:y,El:g,Fh:b,Fl:w,Gh:m,Gl:E,Hh:B,Hl:v}=this;for(let t=0;t<80;t++){const e=o.rotrSH(y,g,14)^o.rotrSH(y,g,18)^o.rotrBH(y,g,41),x=o.rotrSL(y,g,14)^o.rotrSL(y,g,18)^o.rotrBL(y,g,41),S=y&b^~y&m,I=g&w^~g&E,A=o.add5L(v,x,I,l[t],p[t]),O=o.add5H(A,B,e,S,h[t],d[t]),_=0|A,R=o.rotrSH(n,r,28)^o.rotrBH(n,r,34)^o.rotrBH(n,r,39),F=o.rotrSL(n,r,28)^o.rotrBL(n,r,34)^o.rotrBL(n,r,39),H=n&s^n&f^s&f,L=r&i^r&a^i&a;B=0|m,v=0|E,m=0|b,E=0|w,b=0|y,w=0|g,({h:y,l:g}=o.add(0|c,0|u,0|O,0|_)),c=0|f,u=0|a,f=0|s,a=0|i,s=0|n,i=0|r;const T=o.add3L(_,F,L);n=o.add3H(T,O,R,H),r=0|T}({h:n,l:r}=o.add(0|this.Ah,0|this.Al,0|n,0|r)),({h:s,l:i}=o.add(0|this.Bh,0|this.Bl,0|s,0|i)),({h:f,l:a}=o.add(0|this.Ch,0|this.Cl,0|f,0|a)),({h:c,l:u}=o.add(0|this.Dh,0|this.Dl,0|c,0|u)),({h:y,l:g}=o.add(0|this.Eh,0|this.El,0|y,0|g)),({h:b,l:w}=o.add(0|this.Fh,0|this.Fl,0|b,0|w)),({h:m,l:E}=o.add(0|this.Gh,0|this.Gl,0|m,0|E)),({h:B,l:v}=o.add(0|this.Hh,0|this.Hl,0|B,0|v)),this.set(n,r,s,i,f,a,c,u,y,g,b,w,m,E,B,v)}roundClean(){(0,s.clean)(d,p)}destroy(){(0,s.clean)(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}e.SHA512=y;class g extends y{constructor(){super(48),this.Ah=0|r.SHA384_IV[0],this.Al=0|r.SHA384_IV[1],this.Bh=0|r.SHA384_IV[2],this.Bl=0|r.SHA384_IV[3],this.Ch=0|r.SHA384_IV[4],this.Cl=0|r.SHA384_IV[5],this.Dh=0|r.SHA384_IV[6],this.Dl=0|r.SHA384_IV[7],this.Eh=0|r.SHA384_IV[8],this.El=0|r.SHA384_IV[9],this.Fh=0|r.SHA384_IV[10],this.Fl=0|r.SHA384_IV[11],this.Gh=0|r.SHA384_IV[12],this.Gl=0|r.SHA384_IV[13],this.Hh=0|r.SHA384_IV[14],this.Hl=0|r.SHA384_IV[15]}}e.SHA384=g;const b=Uint32Array.from([2352822216,424955298,1944164710,2312950998,502970286,855612546,1738396948,1479516111,258812777,2077511080,2011393907,79989058,1067287976,1780299464,286451373,2446758561]),w=Uint32Array.from([573645204,4230739756,2673172387,3360449730,596883563,1867755857,2520282905,1497426621,2519219938,2827943907,3193839141,1401305490,721525244,746961066,246885852,2177182882]);class m extends y{constructor(){super(28),this.Ah=0|b[0],this.Al=0|b[1],this.Bh=0|b[2],this.Bl=0|b[3],this.Ch=0|b[4],this.Cl=0|b[5],this.Dh=0|b[6],this.Dl=0|b[7],this.Eh=0|b[8],this.El=0|b[9],this.Fh=0|b[10],this.Fl=0|b[11],this.Gh=0|b[12],this.Gl=0|b[13],this.Hh=0|b[14],this.Hl=0|b[15]}}e.SHA512_224=m;class E extends y{constructor(){super(32),this.Ah=0|w[0],this.Al=0|w[1],this.Bh=0|w[2],this.Bl=0|w[3],this.Ch=0|w[4],this.Cl=0|w[5],this.Dh=0|w[6],this.Dl=0|w[7],this.Eh=0|w[8],this.El=0|w[9],this.Fh=0|w[10],this.Fl=0|w[11],this.Gh=0|w[12],this.Gl=0|w[13],this.Hh=0|w[14],this.Hl=0|w[15]}}e.SHA512_256=E,e.sha256=(0,s.createHasher)((()=>new a)),e.sha224=(0,s.createHasher)((()=>new c)),e.sha512=(0,s.createHasher)((()=>new y)),e.sha384=(0,s.createHasher)((()=>new g)),e.sha512_256=(0,s.createHasher)((()=>new E)),e.sha512_224=(0,s.createHasher)((()=>new m))},596053:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.sha224=e.SHA224=e.sha256=e.SHA256=void 0;const r=n(695047);e.SHA256=r.SHA256,e.sha256=r.sha256,e.SHA224=r.SHA224,e.sha224=r.sha224},280125:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.shake256=e.shake128=e.keccak_512=e.keccak_384=e.keccak_256=e.keccak_224=e.sha3_512=e.sha3_384=e.sha3_256=e.sha3_224=e.Keccak=void 0,e.keccakP=m;const r=n(411655),o=n(870064),s=BigInt(0),i=BigInt(1),f=BigInt(2),a=BigInt(7),c=BigInt(256),u=BigInt(113),h=[],l=[],d=[];for(let t=0,e=i,n=1,r=0;t<24;t++){[n,r]=[r,(2*n+3*r)%5],h.push(2*(5*r+n)),l.push((t+1)*(t+2)/2%64);let o=s;for(let t=0;t<7;t++)e=(e<<i^(e>>a)*u)%c,e&f&&(o^=i<<(i<<BigInt(t))-i);d.push(o)}const p=(0,r.split)(d,!0),y=p[0],g=p[1],b=(t,e,n)=>n>32?(0,r.rotlBH)(t,e,n):(0,r.rotlSH)(t,e,n),w=(t,e,n)=>n>32?(0,r.rotlBL)(t,e,n):(0,r.rotlSL)(t,e,n);function m(t,e=24){const n=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let e=0;e<10;e++)n[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const r=(e+8)%10,o=(e+2)%10,s=n[o],i=n[o+1],f=b(s,i,1)^n[r],a=w(s,i,1)^n[r+1];for(let n=0;n<50;n+=10)t[e+n]^=f,t[e+n+1]^=a}let e=t[2],o=t[3];for(let n=0;n<24;n++){const r=l[n],s=b(e,o,r),i=w(e,o,r),f=h[n];e=t[f],o=t[f+1],t[f]=s,t[f+1]=i}for(let e=0;e<50;e+=10){for(let r=0;r<10;r++)n[r]=t[e+r];for(let r=0;r<10;r++)t[e+r]^=~n[(r+2)%10]&n[(r+4)%10]}t[0]^=y[r],t[1]^=g[r]}(0,o.clean)(n)}class E extends o.Hash{constructor(t,e,n,r=!1,s=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=e,this.outputLen=n,this.enableXOF=r,this.rounds=s,(0,o.anumber)(n),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=(0,o.u32)(this.state)}clone(){return this._cloneInto()}keccak(){(0,o.swap32IfBE)(this.state32),m(this.state32,this.rounds),(0,o.swap32IfBE)(this.state32),this.posOut=0,this.pos=0}update(t){(0,o.aexists)(this),t=(0,o.toBytes)(t),(0,o.abytes)(t);const{blockLen:e,state:n}=this,r=t.length;for(let o=0;o<r;){const s=Math.min(e-this.pos,r-o);for(let e=0;e<s;e++)n[this.pos++]^=t[o++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:n,blockLen:r}=this;t[n]^=e,0!=(128&e)&&n===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){(0,o.aexists)(this,!1),(0,o.abytes)(t),this.finish();const e=this.state,{blockLen:n}=this;for(let r=0,o=t.length;r<o;){this.posOut>=n&&this.keccak();const s=Math.min(n-this.posOut,o-r);t.set(e.subarray(this.posOut,this.posOut+s),r),this.posOut+=s,r+=s}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return(0,o.anumber)(t),this.xofInto(new Uint8Array(t))}digestInto(t){if((0,o.aoutput)(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,(0,o.clean)(this.state)}_cloneInto(t){const{blockLen:e,suffix:n,outputLen:r,rounds:o,enableXOF:s}=this;return t||(t=new E(e,n,r,s,o)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=o,t.suffix=n,t.outputLen=r,t.enableXOF=s,t.destroyed=this.destroyed,t}}e.Keccak=E;const B=(t,e,n)=>(0,o.createHasher)((()=>new E(e,t,n)));e.sha3_224=B(6,144,28),e.sha3_256=B(6,136,32),e.sha3_384=B(6,104,48),e.sha3_512=B(6,72,64),e.keccak_224=B(1,144,28),e.keccak_256=B(1,136,32),e.keccak_384=B(1,104,48),e.keccak_512=B(1,72,64);const v=(t,e,n)=>(0,o.createXOFer)(((r={})=>new E(e,t,void 0===r.dkLen?n:r.dkLen,!0)));e.shake128=v(31,168,16),e.shake256=v(31,136,32)},312540:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.sha512_256=e.SHA512_256=e.sha512_224=e.SHA512_224=e.sha384=e.SHA384=e.sha512=e.SHA512=void 0;const r=n(695047);e.SHA512=r.SHA512,e.sha512=r.sha512,e.SHA384=r.SHA384,e.sha384=r.sha384,e.SHA512_224=r.SHA512_224,e.sha512_224=r.sha512_224,e.SHA512_256=r.SHA512_256,e.sha512_256=r.sha512_256},870064:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.wrapXOFConstructorWithOpts=e.wrapConstructorWithOpts=e.wrapConstructor=e.Hash=e.nextTick=e.swap32IfBE=e.byteSwapIfBE=e.swap8IfBE=e.isLE=void 0,e.isBytes=o,e.anumber=s,e.abytes=i,e.ahash=function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.createHasher");s(t.outputLen),s(t.blockLen)},e.aexists=function(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")},e.aoutput=function(t,e){i(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)},e.u8=function(t){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)},e.u32=function(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))},e.clean=function(...t){for(let e=0;e<t.length;e++)t[e].fill(0)},e.createView=function(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)},e.rotr=function(t,e){return t<<32-e|t>>>e},e.rotl=function(t,e){return t<<e|t>>>32-e>>>0},e.byteSwap=f,e.byteSwap32=a,e.bytesToHex=function(t){if(i(t),c)return t.toHex();let e="";for(let n=0;n<t.length;n++)e+=u[t[n]];return e},e.hexToBytes=function(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(c)return Uint8Array.fromHex(t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let e=0,o=0;e<n;e++,o+=2){const n=l(t.charCodeAt(o)),s=l(t.charCodeAt(o+1));if(void 0===n||void 0===s){const e=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+o)}r[e]=16*n+s}return r},e.asyncLoop=async function(t,n,r){let o=Date.now();for(let s=0;s<t;s++){r(s);const t=Date.now()-o;t>=0&&t<n||(await(0,e.nextTick)(),o+=t)}},e.utf8ToBytes=d,e.bytesToUtf8=function(t){return(new TextDecoder).decode(t)},e.toBytes=p,e.kdfInputToBytes=function(t){return"string"==typeof t&&(t=d(t)),i(t),t},e.concatBytes=function(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];i(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n},e.checkOpts=function(t,e){if(void 0!==e&&"[object Object]"!=={}.toString.call(e))throw new Error("options should be object or undefined");return Object.assign(t,e)},e.createHasher=y,e.createOptHasher=g,e.createXOFer=b,e.randomBytes=function(t=32){if(r.crypto&&"function"==typeof r.crypto.getRandomValues)return r.crypto.getRandomValues(new Uint8Array(t));if(r.crypto&&"function"==typeof r.crypto.randomBytes)return Uint8Array.from(r.crypto.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")};const r=n(270825);function o(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function s(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function i(t,...e){if(!o(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function f(t){return t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255}function a(t){for(let e=0;e<t.length;e++)t[e]=f(t[e]);return t}e.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],e.swap8IfBE=e.isLE?t=>t:t=>f(t),e.byteSwapIfBE=e.swap8IfBE,e.swap32IfBE=e.isLE?t=>t:a;const c=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),u=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0"))),h={_0:48,_9:57,A:65,F:70,a:97,f:102};function l(t){return t>=h._0&&t<=h._9?t-h._0:t>=h.A&&t<=h.F?t-(h.A-10):t>=h.a&&t<=h.f?t-(h.a-10):void 0}function d(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}function p(t){return"string"==typeof t&&(t=d(t)),i(t),t}function y(t){const e=e=>t().update(p(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function g(t){const e=(e,n)=>t(n).update(p(e)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=e=>t(e),e}function b(t){const e=(e,n)=>t(n).update(p(e)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=e=>t(e),e}e.nextTick=async()=>{},e.Hash=class{},e.wrapConstructor=y,e.wrapConstructorWithOpts=g,e.wrapXOFConstructorWithOpts=b},41019:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.getHash=i,e.createCurve=function(t,e){const n=e=>(0,s.weierstrass)({...t,...i(e)});return Object.freeze({...n(e),create:n})};const r=n(170520),o=n(850300),s=n(380551);function i(t){return{hash:t,hmac:(e,...n)=>(0,r.hmac)(t,e,(0,o.concatBytes)(...n)),randomBytes:o.randomBytes}}},807824:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.wNAF=function(t,e){const n=(t,e)=>{const n=e.negate();return t?n:e},r=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:n,unsafeLadder(e,n){let r=t.ZERO,o=e;for(;n>s;)n&i&&(r=r.add(o)),o=o.double(),n>>=i;return r},precomputeWindow(t,e){const{windows:n,windowSize:o}=r(e),s=[];let i=t,f=i;for(let t=0;t<n;t++){f=i,s.push(f);for(let t=1;t<o;t++)f=f.add(i),s.push(f);i=f.double()}return s},wNAF(e,o,s){const{windows:f,windowSize:a}=r(e);let c=t.ZERO,u=t.BASE;const h=BigInt(2**e-1),l=2**e,d=BigInt(e);for(let t=0;t<f;t++){const e=t*a;let r=Number(s&h);s>>=d,r>a&&(r-=l,s+=i);const f=e,p=e+Math.abs(r)-1,y=t%2!=0,g=r<0;0===r?u=u.add(n(y,o[f])):c=c.add(n(g,o[p]))}return{p:c,f:u}},wNAFCached(t,e,n,r){const o=t._WINDOW_SIZE||1;let s=e.get(t);return s||(s=this.precomputeWindow(t,o),1!==o&&e.set(t,r(s))),this.wNAF(o,s,n)}}},e.validateBasic=function(t){return(0,r.validateField)(t.Fp),(0,o.validateObject)(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,r.nLength)(t.n,t.nBitLength),...t,p:t.Fp.ORDER})};const r=n(208767),o=n(647367),s=BigInt(0),i=BigInt(1)},129173:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.expand_message_xmd=c,e.expand_message_xof=u,e.hash_to_field=h,e.isogenyMap=function(t,e){const n=e.map((t=>Array.from(t).reverse()));return(e,r)=>{const[o,s,i,f]=n.map((n=>n.reduce(((n,r)=>t.add(t.mul(n,e),r)))));return e=t.div(o,s),r=t.mul(r,t.div(i,f)),{x:e,y:r}}},e.createHasher=function(t,e,n){if("function"!=typeof e)throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const s=h(r,2,{...n,DST:n.DST,...o}),i=t.fromAffine(e(s[0])),f=t.fromAffine(e(s[1])),a=i.add(f).clearCofactor();return a.assertValidity(),a},encodeToCurve(r,o){const s=h(r,1,{...n,DST:n.encodeDST,...o}),i=t.fromAffine(e(s[0])).clearCofactor();return i.assertValidity(),i},mapToCurve(n){if(!Array.isArray(n))throw new Error("mapToCurve: expected array of bigints");for(const t of n)if("bigint"!=typeof t)throw new Error(`mapToCurve: expected array of bigints, got ${t} in array`);const r=t.fromAffine(e(n)).clearCofactor();return r.assertValidity(),r}}};const r=n(208767),o=n(647367),s=o.bytesToNumberBE;function i(t,e){if(t<0||t>=1<<8*e)throw new Error(`bad I2OSP call: value=${t} length=${e}`);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=255&t,t>>>=8;return new Uint8Array(n)}function f(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function a(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function c(t,e,n,r){(0,o.abytes)(t),(0,o.abytes)(e),a(n),e.length>255&&(e=r((0,o.concatBytes)((0,o.utf8ToBytes)("H2C-OVERSIZE-DST-"),e)));const{outputLen:s,blockLen:c}=r,u=Math.ceil(n/s);if(u>255)throw new Error("Invalid xmd length");const h=(0,o.concatBytes)(e,i(e.length,1)),l=i(0,c),d=i(n,2),p=new Array(u),y=r((0,o.concatBytes)(l,t,d,i(0,1),h));p[0]=r((0,o.concatBytes)(y,i(1,1),h));for(let t=1;t<=u;t++){const e=[f(y,p[t-1]),i(t+1,1),h];p[t]=r((0,o.concatBytes)(...e))}return(0,o.concatBytes)(...p).slice(0,n)}function u(t,e,n,r,s){if((0,o.abytes)(t),(0,o.abytes)(e),a(n),e.length>255){const t=Math.ceil(2*r/8);e=s.create({dkLen:t}).update((0,o.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:n}).update(t).update(i(n,2)).update(e).update(i(e.length,1)).digest()}function h(t,e,n){(0,o.validateObject)(n,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:i,k:f,m:h,hash:l,expand:d,DST:p}=n;(0,o.abytes)(t),a(e);const y="string"==typeof p?(0,o.utf8ToBytes)(p):p,g=i.toString(2).length,b=Math.ceil((g+f)/8),w=e*h*b;let m;if("xmd"===d)m=c(t,y,w,l);else if("xof"===d)m=u(t,y,w,f,l);else{if("_internal_pass"!==d)throw new Error('expand must be "xmd" or "xof"');m=t}const E=new Array(e);for(let t=0;t<e;t++){const e=new Array(h);for(let n=0;n<h;n++){const o=b*(n+t*h),f=m.subarray(o,o+b);e[n]=(0,r.mod)(s(f),i)}E[t]=e}return E}},208767:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.isNegativeLE=void 0,e.mod=h,e.pow=l,e.pow2=function(t,e,n){let r=t;for(;e-- >o;)r*=r,r%=n;return r},e.invert=d,e.tonelliShanks=p,e.FpSqrt=y,e.validateField=function(t){const e=g.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return(0,r.validateObject)(t,e)},e.FpPow=b,e.FpInvertBatch=w,e.FpDiv=function(t,e,n){return t.mul(e,"bigint"==typeof n?d(n,t.ORDER):t.inv(n))},e.FpIsSquare=function(t){const e=(t.ORDER-s)/i;return n=>{const r=t.pow(n,e);return t.eql(r,t.ZERO)||t.eql(r,t.ONE)}},e.nLength=m,e.Field=function(t,e,n=!1,i={}){if(t<=o)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:f,nByteLength:a}=m(t,e);if(a>2048)throw new Error("Field lengths over 2048 bytes are not supported");const c=y(t),u=Object.freeze({ORDER:t,BITS:f,BYTES:a,MASK:(0,r.bitMask)(f),ZERO:o,ONE:s,create:e=>h(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return o<=e&&e<t},is0:t=>t===o,isOdd:t=>(t&s)===s,neg:e=>h(-e,t),eql:(t,e)=>t===e,sqr:e=>h(e*e,t),add:(e,n)=>h(e+n,t),sub:(e,n)=>h(e-n,t),mul:(e,n)=>h(e*n,t),pow:(t,e)=>b(u,t,e),div:(e,n)=>h(e*d(n,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>d(e,t),sqrt:i.sqrt||(t=>c(u,t)),invertBatch:t=>w(u,t),cmov:(t,e,n)=>n?e:t,toBytes:t=>n?(0,r.numberToBytesLE)(t,a):(0,r.numberToBytesBE)(t,a),fromBytes:t=>{if(t.length!==a)throw new Error(`Fp.fromBytes: expected ${a}, got ${t.length}`);return n?(0,r.bytesToNumberLE)(t):(0,r.bytesToNumberBE)(t)}});return Object.freeze(u)},e.FpSqrtOdd=function(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const n=t.sqrt(e);return t.isOdd(n)?n:t.neg(n)},e.FpSqrtEven=function(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const n=t.sqrt(e);return t.isOdd(n)?t.neg(n):n},e.hashToPrivateScalar=function(t,e,n=!1){const o=(t=(0,r.ensureBytes)("privateHash",t)).length,i=m(e).nByteLength+8;if(i<24||o<i||o>1024)throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${o}`);return h(n?(0,r.bytesToNumberLE)(t):(0,r.bytesToNumberBE)(t),e-s)+s},e.getFieldBytesLength=E,e.getMinHashLength=B,e.mapHashToField=function(t,e,n=!1){const o=t.length,i=E(e),f=B(e);if(o<16||o<f||o>1024)throw new Error(`expected ${f}-1024 bytes of input, got ${o}`);const a=h(n?(0,r.bytesToNumberBE)(t):(0,r.bytesToNumberLE)(t),e-s)+s;return n?(0,r.numberToBytesLE)(a,i):(0,r.numberToBytesBE)(a,i)};const r=n(647367),o=BigInt(0),s=BigInt(1),i=BigInt(2),f=BigInt(3),a=BigInt(4),c=BigInt(5),u=BigInt(8);function h(t,e){const n=t%e;return n>=o?n:e+n}function l(t,e,n){if(n<=o||e<o)throw new Error("Expected power/modulo > 0");if(n===s)return o;let r=s;for(;e>o;)e&s&&(r=r*t%n),t=t*t%n,e>>=s;return r}function d(t,e){if(t===o||e<=o)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=h(t,e),r=e,i=o,f=s,a=s,c=o;for(;n!==o;){const t=r/n,e=r%n,o=i-a*t,s=f-c*t;r=n,n=e,i=a,f=c,a=o,c=s}if(r!==s)throw new Error("invert: does not exist");return h(i,e)}function p(t){const e=(t-s)/i;let n,r,f;for(n=t-s,r=0;n%i===o;n/=i,r++);for(f=i;f<t&&l(f,e,t)!==t-s;f++);if(1===r){const e=(t+s)/a;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}const c=(n+s)/i;return function(t,o){if(t.pow(o,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let i=r,a=t.pow(t.mul(t.ONE,f),n),u=t.pow(o,c),h=t.pow(o,n);for(;!t.eql(h,t.ONE);){if(t.eql(h,t.ZERO))return t.ZERO;let e=1;for(let n=t.sqr(h);e<i&&!t.eql(n,t.ONE);e++)n=t.sqr(n);const n=t.pow(a,s<<BigInt(i-e-1));a=t.sqr(n),u=t.mul(u,n),h=t.mul(h,a),i=e}return u}}function y(t){if(t%a===f){const e=(t+s)/a;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}if(t%u===c){const e=(t-c)/u;return function(t,n){const r=t.mul(n,i),o=t.pow(r,e),s=t.mul(n,o),f=t.mul(t.mul(s,i),o),a=t.mul(s,t.sub(f,t.ONE));if(!t.eql(t.sqr(a),n))throw new Error("Cannot find square root");return a}}return p(t)}BigInt(9),BigInt(16),e.isNegativeLE=(t,e)=>(h(t,e)&s)===s;const g=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function b(t,e,n){if(n<o)throw new Error("Expected power > 0");if(n===o)return t.ONE;if(n===s)return e;let r=t.ONE,i=e;for(;n>o;)n&s&&(r=t.mul(r,i)),i=t.sqr(i),n>>=s;return r}function w(t,e){const n=new Array(e.length),r=e.reduce(((e,r,o)=>t.is0(r)?e:(n[o]=e,t.mul(e,r))),t.ONE),o=t.inv(r);return e.reduceRight(((e,r,o)=>t.is0(r)?e:(n[o]=t.mul(e,n[o]),t.mul(e,r))),o),n}function m(t,e){const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function E(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function B(t){const e=E(t);return e+Math.ceil(e/2)}},647367:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.bitMask=void 0,e.isBytes=s,e.abytes=i,e.bytesToHex=a,e.numberToHexUnpadded=c,e.hexToNumber=u,e.hexToBytes=d,e.bytesToNumberBE=function(t){return u(a(t))},e.bytesToNumberLE=function(t){return i(t),u(a(Uint8Array.from(t).reverse()))},e.numberToBytesBE=p,e.numberToBytesLE=function(t,e){return p(t,e).reverse()},e.numberToVarBytesBE=function(t){return d(c(t))},e.ensureBytes=function(t,e,n){let r;if("string"==typeof e)try{r=d(e)}catch(n){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${n}`)}else{if(!s(e))throw new Error(`${t} must be hex string or Uint8Array`);r=Uint8Array.from(e)}const o=r.length;if("number"==typeof n&&o!==n)throw new Error(`${t} expected ${n} bytes, got ${o}`);return r},e.concatBytes=y,e.equalBytes=function(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return 0===n},e.utf8ToBytes=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))},e.bitLen=function(t){let e;for(e=0;t>n;t>>=r,e+=1);return e},e.bitGet=function(t,e){return t>>BigInt(e)&r},e.bitSet=function(t,e,o){return t|(o?r:n)<<BigInt(e)},e.createHmacDrbg=function(t,e,n){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let r=g(t),o=g(t),s=0;const i=()=>{r.fill(1),o.fill(0),s=0},f=(...t)=>n(o,r,...t),a=(t=g())=>{o=f(b([0]),t),r=f(),0!==t.length&&(o=f(b([1]),t),r=f())},c=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const n=[];for(;t<e;){r=f();const e=r.slice();n.push(e),t+=r.length}return y(...n)};return(t,e)=>{let n;for(i(),a(t);!(n=e(c()));)a();return i(),n}},e.validateObject=function(t,e,n={}){const r=(e,n,r)=>{const o=w[n];if("function"!=typeof o)throw new Error(`Invalid validator "${n}", expected function`);const s=t[e];if(!(r&&void 0===s||o(s,t)))throw new Error(`Invalid param ${String(e)}=${s} (${typeof s}), expected ${n}`)};for(const[t,n]of Object.entries(e))r(t,n,!1);for(const[t,e]of Object.entries(n))r(t,e,!0);return t};const n=BigInt(0),r=BigInt(1),o=BigInt(2);function s(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}function i(t){if(!s(t))throw new Error("Uint8Array expected")}const f=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function a(t){i(t);let e="";for(let n=0;n<t.length;n++)e+=f[t[n]];return e}function c(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function u(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}const h={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function l(t){return t>=h._0&&t<=h._9?t-h._0:t>=h._A&&t<=h._F?t-(h._A-10):t>=h._a&&t<=h._f?t-(h._a-10):void 0}function d(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let e=0,o=0;e<n;e++,o+=2){const n=l(t.charCodeAt(o)),s=l(t.charCodeAt(o+1));if(void 0===n||void 0===s){const e=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+o)}r[e]=16*n+s}return r}function p(t,e){return d(t.toString(16).padStart(2*e,"0"))}function y(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];i(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n}e.bitMask=t=>(o<<BigInt(t-1))-r;const g=t=>new Uint8Array(t),b=t=>Uint8Array.from(t),w={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||s(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)}},380551:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.DER=void 0,e.weierstrassPoints=p,e.weierstrass=function(t){const n=function(t){const e=(0,r.validateBasic)(t);return s.validateObject(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:f,n:a}=n,h=f.BYTES+1,l=2*f.BYTES+1;function d(t){return o.mod(t,a)}function y(t){return o.invert(t,a)}const{ProjectivePoint:g,normPrivateKeyToScalar:b,weierstrassEquation:w,isWithinCurveOrder:m}=p({...n,toBytes(t,e,n){const r=e.toAffine(),o=f.toBytes(r.x),i=s.concatBytes;return n?i(Uint8Array.from([e.hasEvenY()?2:3]),o):i(Uint8Array.from([4]),o,f.toBytes(r.y))},fromBytes(t){const e=t.length,n=t[0],r=t.subarray(1);if(e!==h||2!==n&&3!==n){if(e===l&&4===n)return{x:f.fromBytes(r.subarray(0,f.BYTES)),y:f.fromBytes(r.subarray(f.BYTES,2*f.BYTES))};throw new Error(`Point of length ${e} was invalid. Expected ${h} compressed bytes or ${l} uncompressed bytes`)}{const t=s.bytesToNumberBE(r);if(!(c<(o=t)&&o<f.ORDER))throw new Error("Point is not on curve");const e=w(t);let i;try{i=f.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+e)}return 1==(1&n)!=((i&u)===u)&&(i=f.neg(i)),{x:t,y:i}}var o}}),E=t=>s.bytesToHex(s.numberToBytesBE(t,n.nByteLength));function B(t){return t>a>>u}const v=(t,e,n)=>s.bytesToNumberBE(t.slice(e,n));class x{constructor(t,e,n){this.r=t,this.s=e,this.recovery=n,this.assertValidity()}static fromCompact(t){const e=n.nByteLength;return t=(0,i.ensureBytes)("compactSignature",t,2*e),new x(v(t,0,e),v(t,e,2*e))}static fromDER(t){const{r:n,s:r}=e.DER.toSig((0,i.ensureBytes)("DER",t));return new x(n,r)}assertValidity(){if(!m(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!m(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new x(this.r,this.s,t)}recoverPublicKey(t){const{r:e,s:r,recovery:o}=this,s=O((0,i.ensureBytes)("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const a=2===o||3===o?e+n.n:e;if(a>=f.ORDER)throw new Error("recovery id 2 or 3 invalid");const c=0==(1&o)?"02":"03",u=g.fromHex(c+E(a)),h=y(a),l=d(-s*h),p=d(r*h),b=g.BASE.multiplyAndAddUnsafe(u,l,p);if(!b)throw new Error("point at infinify");return b.assertValidity(),b}hasHighS(){return B(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,d(-this.s),this.recovery):this}toDERRawBytes(){return s.hexToBytes(this.toDERHex())}toDERHex(){return e.DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return s.hexToBytes(this.toCompactHex())}toCompactHex(){return E(this.r)+E(this.s)}}const S={isValidPrivateKey(t){try{return b(t),!0}catch(t){return!1}},normPrivateKeyToScalar:b,randomPrivateKey:()=>{const t=o.getMinHashLength(n.n);return o.mapHashToField(n.randomBytes(t),n.n)},precompute:(t=8,e=g.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function I(t){const e=s.isBytes(t),n="string"==typeof t,r=(e||n)&&t.length;return e?r===h||r===l:n?r===2*h||r===2*l:t instanceof g}const A=n.bits2int||function(t){const e=s.bytesToNumberBE(t),r=8*t.length-n.nBitLength;return r>0?e>>BigInt(r):e},O=n.bits2int_modN||function(t){return d(A(t))},_=s.bitMask(n.nBitLength);function R(t){if("bigint"!=typeof t)throw new Error("bigint expected");if(!(c<=t&&t<_))throw new Error(`bigint expected < 2^${n.nBitLength}`);return s.numberToBytesBE(t,n.nByteLength)}const F={lowS:n.lowS,prehash:!1},H={lowS:n.lowS,prehash:!1};return g.BASE._setWindowSize(8),{CURVE:n,getPublicKey:function(t,e=!0){return g.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,n=!0){if(I(t))throw new Error("first arg must be private key");if(!I(e))throw new Error("second arg must be public key");return g.fromHex(e).multiply(b(t)).toRawBytes(n)},sign:function(t,e,r=F){const{seed:o,k2sig:a}=function(t,e,r=F){if(["recovered","canonical"].some((t=>t in r)))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:a}=n;let{lowS:h,prehash:l,extraEntropy:p}=r;null==h&&(h=!0),t=(0,i.ensureBytes)("msgHash",t),l&&(t=(0,i.ensureBytes)("prehashed msgHash",o(t)));const w=O(t),E=b(e),v=[R(E),R(w)];if(null!=p&&!1!==p){const t=!0===p?a(f.BYTES):p;v.push((0,i.ensureBytes)("extraEntropy",t))}const S=s.concatBytes(...v),I=w;return{seed:S,k2sig:function(t){const e=A(t);if(!m(e))return;const n=y(e),r=g.BASE.multiply(e).toAffine(),o=d(r.x);if(o===c)return;const s=d(n*d(I+o*E));if(s===c)return;let i=(r.x===o?0:2)|Number(r.y&u),f=s;return h&&B(s)&&(f=function(t){return B(t)?d(-t):t}(s),i^=1),new x(o,f,i)}}}(t,e,r),h=n;return s.createHmacDrbg(h.hash.outputLen,h.nByteLength,h.hmac)(o,a)},verify:function(t,r,o,f=H){const a=t;if(r=(0,i.ensureBytes)("msgHash",r),o=(0,i.ensureBytes)("publicKey",o),"strict"in f)throw new Error("options.strict was renamed to lowS");const{lowS:c,prehash:u}=f;let h,l;try{if("string"==typeof a||s.isBytes(a))try{h=x.fromDER(a)}catch(t){if(!(t instanceof e.DER.Err))throw t;h=x.fromCompact(a)}else{if("object"!=typeof a||"bigint"!=typeof a.r||"bigint"!=typeof a.s)throw new Error("PARSE");{const{r:t,s:e}=a;h=new x(t,e)}}l=g.fromHex(o)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(c&&h.hasHighS())return!1;u&&(r=n.hash(r));const{r:p,s:b}=h,w=O(r),m=y(b),E=d(w*m),B=d(p*m),v=g.BASE.multiplyAndAddUnsafe(l,E,B)?.toAffine();return!!v&&d(v.x)===p},ProjectivePoint:g,Signature:x,utils:S}},e.SWUFpSqrtRatio=y,e.mapToCurveSimpleSWU=function(t,e){if(o.validateField(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const n=y(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,i,f,a,c,u,h;o=t.sqr(r),o=t.mul(o,e.Z),s=t.sqr(o),s=t.add(s,o),i=t.add(s,t.ONE),i=t.mul(i,e.B),f=t.cmov(e.Z,t.neg(s),!t.eql(s,t.ZERO)),f=t.mul(f,e.A),s=t.sqr(i),c=t.sqr(f),a=t.mul(c,e.A),s=t.add(s,a),s=t.mul(s,i),c=t.mul(c,f),a=t.mul(c,e.B),s=t.add(s,a),u=t.mul(o,i);const{isValid:l,value:d}=n(s,c);h=t.mul(o,r),h=t.mul(h,d),u=t.cmov(u,i,l),h=t.cmov(h,d,l);const p=t.isOdd(r)===t.isOdd(h);return h=t.cmov(t.neg(h),h,p),u=t.div(u,f),{x:u,y:h}}};const r=n(807824),o=n(208767),s=n(647367),i=n(647367),{bytesToNumberBE:f,hexToBytes:a}=s;e.DER={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(t){const{Err:n}=e.DER;if(t.length<2||2!==t[0])throw new n("Invalid signature integer tag");const r=t[1],o=t.subarray(2,r+2);if(!r||o.length!==r)throw new n("Invalid signature integer: wrong length");if(128&o[0])throw new n("Invalid signature integer: negative");if(0===o[0]&&!(128&o[1]))throw new n("Invalid signature integer: unnecessary leading zero");return{d:f(o),l:t.subarray(r+2)}},toSig(t){const{Err:n}=e.DER,r="string"==typeof t?a(t):t;s.abytes(r);let o=r.length;if(o<2||48!=r[0])throw new n("Invalid signature tag");if(r[1]!==o-2)throw new n("Invalid signature: incorrect length");const{d:i,l:f}=e.DER._parseInt(r.subarray(2)),{d:c,l:u}=e.DER._parseInt(f);if(u.length)throw new n("Invalid signature: left bytes after parsing");return{r:i,s:c}},hexFromSig(t){const e=t=>8&Number.parseInt(t[0],16)?"00"+t:t,n=t=>{const e=t.toString(16);return 1&e.length?`0${e}`:e},r=e(n(t.s)),o=e(n(t.r)),s=r.length/2,i=o.length/2,f=n(s),a=n(i);return`30${n(i+s+4)}02${a}${o}02${f}${r}`}};const c=BigInt(0),u=BigInt(1),h=BigInt(2),l=BigInt(3),d=BigInt(4);function p(t){const e=function(t){const e=(0,r.validateBasic)(t);s.validateObject(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:o,a:i}=e;if(n){if(!o.eql(i,o.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:n}=e,f=e.toBytes||((t,e,r)=>{const o=e.toAffine();return s.concatBytes(Uint8Array.from([4]),n.toBytes(o.x),n.toBytes(o.y))}),a=e.fromBytes||(t=>{const e=t.subarray(1);return{x:n.fromBytes(e.subarray(0,n.BYTES)),y:n.fromBytes(e.subarray(n.BYTES,2*n.BYTES))}});function h(t){const{a:r,b:o}=e,s=n.sqr(t),i=n.mul(s,t);return n.add(n.add(i,n.mul(t,r)),o)}if(!n.eql(n.sqr(e.Gy),h(e.Gx)))throw new Error("bad generator point: equation left != right");function d(t){return"bigint"==typeof t&&c<t&&t<e.n}function p(t){if(!d(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function y(t){const{allowedPrivateKeyLengths:n,nByteLength:r,wrapPrivateKey:f,n:a}=e;if(n&&"bigint"!=typeof t){if(s.isBytes(t)&&(t=s.bytesToHex(t)),"string"!=typeof t||!n.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*r,"0")}let c;try{c="bigint"==typeof t?t:s.bytesToNumberBE((0,i.ensureBytes)("private key",t,r))}catch(e){throw new Error(`private key must be ${r} bytes, hex or bigint, not ${typeof t}`)}return f&&(c=o.mod(c,a)),p(c),c}const g=new Map;function b(t){if(!(t instanceof w))throw new Error("ProjectivePoint expected")}class w{constructor(t,e,r){if(this.px=t,this.py=e,this.pz=r,null==t||!n.isValid(t))throw new Error("x required");if(null==e||!n.isValid(e))throw new Error("y required");if(null==r||!n.isValid(r))throw new Error("z required")}static fromAffine(t){const{x:e,y:r}=t||{};if(!t||!n.isValid(e)||!n.isValid(r))throw new Error("invalid affine point");if(t instanceof w)throw new Error("projective point not allowed");const o=t=>n.eql(t,n.ZERO);return o(e)&&o(r)?w.ZERO:new w(e,r,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=n.invertBatch(t.map((t=>t.pz)));return t.map(((t,n)=>t.toAffine(e[n]))).map(w.fromAffine)}static fromHex(t){const e=w.fromAffine(a((0,i.ensureBytes)("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return w.BASE.multiply(y(t))}_setWindowSize(t){this._WINDOW_SIZE=t,g.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:t,y:r}=this.toAffine();if(!n.isValid(t)||!n.isValid(r))throw new Error("bad point: x or y not FE");const o=n.sqr(r),s=h(t);if(!n.eql(o,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(n.isOdd)return!n.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){b(t);const{px:e,py:r,pz:o}=this,{px:s,py:i,pz:f}=t,a=n.eql(n.mul(e,f),n.mul(s,o)),c=n.eql(n.mul(r,f),n.mul(i,o));return a&&c}negate(){return new w(this.px,n.neg(this.py),this.pz)}double(){const{a:t,b:r}=e,o=n.mul(r,l),{px:s,py:i,pz:f}=this;let a=n.ZERO,c=n.ZERO,u=n.ZERO,h=n.mul(s,s),d=n.mul(i,i),p=n.mul(f,f),y=n.mul(s,i);return y=n.add(y,y),u=n.mul(s,f),u=n.add(u,u),a=n.mul(t,u),c=n.mul(o,p),c=n.add(a,c),a=n.sub(d,c),c=n.add(d,c),c=n.mul(a,c),a=n.mul(y,a),u=n.mul(o,u),p=n.mul(t,p),y=n.sub(h,p),y=n.mul(t,y),y=n.add(y,u),u=n.add(h,h),h=n.add(u,h),h=n.add(h,p),h=n.mul(h,y),c=n.add(c,h),p=n.mul(i,f),p=n.add(p,p),h=n.mul(p,y),a=n.sub(a,h),u=n.mul(p,d),u=n.add(u,u),u=n.add(u,u),new w(a,c,u)}add(t){b(t);const{px:r,py:o,pz:s}=this,{px:i,py:f,pz:a}=t;let c=n.ZERO,u=n.ZERO,h=n.ZERO;const d=e.a,p=n.mul(e.b,l);let y=n.mul(r,i),g=n.mul(o,f),m=n.mul(s,a),E=n.add(r,o),B=n.add(i,f);E=n.mul(E,B),B=n.add(y,g),E=n.sub(E,B),B=n.add(r,s);let v=n.add(i,a);return B=n.mul(B,v),v=n.add(y,m),B=n.sub(B,v),v=n.add(o,s),c=n.add(f,a),v=n.mul(v,c),c=n.add(g,m),v=n.sub(v,c),h=n.mul(d,B),c=n.mul(p,m),h=n.add(c,h),c=n.sub(g,h),h=n.add(g,h),u=n.mul(c,h),g=n.add(y,y),g=n.add(g,y),m=n.mul(d,m),B=n.mul(p,B),g=n.add(g,m),m=n.sub(y,m),m=n.mul(d,m),B=n.add(B,m),y=n.mul(g,B),u=n.add(u,y),y=n.mul(v,B),c=n.mul(E,c),c=n.sub(c,y),y=n.mul(E,g),h=n.mul(v,h),h=n.add(h,y),new w(c,u,h)}subtract(t){return this.add(t.negate())}is0(){return this.equals(w.ZERO)}wNAF(t){return E.wNAFCached(this,g,t,(t=>{const e=n.invertBatch(t.map((t=>t.pz)));return t.map(((t,n)=>t.toAffine(e[n]))).map(w.fromAffine)}))}multiplyUnsafe(t){const r=w.ZERO;if(t===c)return r;if(p(t),t===u)return this;const{endo:o}=e;if(!o)return E.unsafeLadder(this,t);let{k1neg:s,k1:i,k2neg:f,k2:a}=o.splitScalar(t),h=r,l=r,d=this;for(;i>c||a>c;)i&u&&(h=h.add(d)),a&u&&(l=l.add(d)),d=d.double(),i>>=u,a>>=u;return s&&(h=h.negate()),f&&(l=l.negate()),l=new w(n.mul(l.px,o.beta),l.py,l.pz),h.add(l)}multiply(t){p(t);let r,o,s=t;const{endo:i}=e;if(i){const{k1neg:t,k1:e,k2neg:f,k2:a}=i.splitScalar(s);let{p:c,f:u}=this.wNAF(e),{p:h,f:l}=this.wNAF(a);c=E.constTimeNegate(t,c),h=E.constTimeNegate(f,h),h=new w(n.mul(h.px,i.beta),h.py,h.pz),r=c.add(h),o=u.add(l)}else{const{p:t,f:e}=this.wNAF(s);r=t,o=e}return w.normalizeZ([r,o])[0]}multiplyAndAddUnsafe(t,e,n){const r=w.BASE,o=(t,e)=>e!==c&&e!==u&&t.equals(r)?t.multiply(e):t.multiplyUnsafe(e),s=o(this,e).add(o(t,n));return s.is0()?void 0:s}toAffine(t){const{px:e,py:r,pz:o}=this,s=this.is0();null==t&&(t=s?n.ONE:n.inv(o));const i=n.mul(e,t),f=n.mul(r,t),a=n.mul(o,t);if(s)return{x:n.ZERO,y:n.ZERO};if(!n.eql(a,n.ONE))throw new Error("invZ was invalid");return{x:i,y:f}}isTorsionFree(){const{h:t,isTorsionFree:n}=e;if(t===u)return!0;if(n)return n(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:n}=e;return t===u?this:n?n(w,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),f(w,this,t)}toHex(t=!0){return s.bytesToHex(this.toRawBytes(t))}}w.BASE=new w(e.Gx,e.Gy,n.ONE),w.ZERO=new w(n.ZERO,n.ONE,n.ZERO);const m=e.nBitLength,E=(0,r.wNAF)(w,e.endo?Math.ceil(m/2):m);return{CURVE:e,ProjectivePoint:w,normPrivateKeyToScalar:y,weierstrassEquation:h,isWithinCurveOrder:d}}function y(t,e){const n=t.ORDER;let r=c;for(let t=n-u;t%h===c;t/=h)r+=u;const o=r,s=h<<o-u-u,i=s*h,f=(n-u)/i,a=(f-u)/h,p=i-u,y=s,g=t.pow(e,f),b=t.pow(e,(f+u)/h);let w=(e,n)=>{let r=g,s=t.pow(n,p),i=t.sqr(s);i=t.mul(i,n);let f=t.mul(e,i);f=t.pow(f,a),f=t.mul(f,s),s=t.mul(f,n),i=t.mul(f,e);let c=t.mul(i,s);f=t.pow(c,y);let l=t.eql(f,t.ONE);s=t.mul(i,b),f=t.mul(c,r),i=t.cmov(s,i,l),c=t.cmov(f,c,l);for(let e=o;e>u;e--){let n=e-h;n=h<<n-u;let o=t.pow(c,n);const f=t.eql(o,t.ONE);s=t.mul(i,r),r=t.mul(r,r),o=t.mul(c,r),i=t.cmov(s,i,f),c=t.cmov(o,c,f)}return{isValid:l,value:i}};if(t.ORDER%d===l){const n=(t.ORDER-l)/d,r=t.sqrt(t.neg(e));w=(e,o)=>{let s=t.sqr(o);const i=t.mul(e,o);s=t.mul(s,i);let f=t.pow(s,n);f=t.mul(f,i);const a=t.mul(f,r),c=t.mul(t.sqr(f),o),u=t.eql(c,e);return{isValid:u,value:t.cmov(a,f,u)}}}return w}},522934:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.encodeToCurve=e.hashToCurve=e.schnorr=e.secp256k1=void 0;const r=n(213426),o=n(850300),s=n(41019),i=n(129173),f=n(208767),a=n(647367),c=n(380551),u=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),h=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),l=BigInt(1),d=BigInt(2),p=(t,e)=>(t+e/d)/e;function y(t){const e=u,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),h=t*t*t%e,l=h*h*t%e,p=(0,f.pow2)(l,n,e)*l%e,y=(0,f.pow2)(p,n,e)*l%e,b=(0,f.pow2)(y,d,e)*h%e,w=(0,f.pow2)(b,o,e)*b%e,m=(0,f.pow2)(w,s,e)*w%e,E=(0,f.pow2)(m,a,e)*m%e,B=(0,f.pow2)(E,c,e)*E%e,v=(0,f.pow2)(B,a,e)*m%e,x=(0,f.pow2)(v,n,e)*l%e,S=(0,f.pow2)(x,i,e)*w%e,I=(0,f.pow2)(S,r,e)*h%e,A=(0,f.pow2)(I,d,e);if(!g.eql(g.sqr(A),t))throw new Error("Cannot find square root");return A}const g=(0,f.Field)(u,void 0,void 0,{sqrt:y});e.secp256k1=(0,s.createCurve)({a:BigInt(0),b:BigInt(7),Fp:g,n:h,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=h,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-l*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,i=BigInt("0x100000000000000000000000000000000"),a=p(s*t,e),c=p(-r*t,e);let u=(0,f.mod)(t-a*n-c*o,e),d=(0,f.mod)(-a*r-c*s,e);const y=u>i,g=d>i;if(y&&(u=e-u),g&&(d=e-d),u>i||d>i)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:y,k1:u,k2neg:g,k2:d}}}},r.sha256);const b=BigInt(0),w=t=>"bigint"==typeof t&&b<t&&t<u,m=t=>"bigint"==typeof t&&b<t&&t<h,E={};function B(t,...e){let n=E[t];if(void 0===n){const e=(0,r.sha256)(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=(0,a.concatBytes)(e,e),E[t]=n}return(0,r.sha256)((0,a.concatBytes)(n,...e))}const v=t=>t.toRawBytes(!0).slice(1),x=t=>(0,a.numberToBytesBE)(t,32),S=t=>(0,f.mod)(t,u),I=t=>(0,f.mod)(t,h),A=e.secp256k1.ProjectivePoint,O=(t,e,n)=>A.BASE.multiplyAndAddUnsafe(t,e,n);function _(t){let n=e.secp256k1.utils.normPrivateKeyToScalar(t),r=A.fromPrivateKey(n);return{scalar:r.hasEvenY()?n:I(-n),bytes:v(r)}}function R(t){if(!w(t))throw new Error("bad x: need 0 < x < p");const e=S(t*t);let n=y(S(e*t+BigInt(7)));n%d!==b&&(n=S(-n));const r=new A(t,n,l);return r.assertValidity(),r}function F(...t){return I((0,a.bytesToNumberBE)(B("BIP0340/challenge",...t)))}function H(t,e,n){const r=(0,a.ensureBytes)("signature",t,64),o=(0,a.ensureBytes)("message",e),s=(0,a.ensureBytes)("publicKey",n,32);try{const t=R((0,a.bytesToNumberBE)(s)),e=(0,a.bytesToNumberBE)(r.subarray(0,32));if(!w(e))return!1;const n=(0,a.bytesToNumberBE)(r.subarray(32,64));if(!m(n))return!1;const i=F(x(e),v(t),o),f=O(t,n,I(-i));return!(!f||!f.hasEvenY()||f.toAffine().x!==e)}catch(t){return!1}}e.schnorr={getPublicKey:function(t){return _(t).bytes},sign:function(t,e,n=(0,o.randomBytes)(32)){const r=(0,a.ensureBytes)("message",t),{bytes:s,scalar:i}=_(e),f=(0,a.ensureBytes)("auxRand",n,32),c=x(i^(0,a.bytesToNumberBE)(B("BIP0340/aux",f))),u=B("BIP0340/nonce",c,s,r),h=I((0,a.bytesToNumberBE)(u));if(h===b)throw new Error("sign failed: k is zero");const{bytes:l,scalar:d}=_(h),p=F(l,s,r),y=new Uint8Array(64);if(y.set(l,0),y.set(x(I(d+p*i)),32),!H(y,r,s))throw new Error("sign: Invalid signature produced");return y},verify:H,utils:{randomPrivateKey:e.secp256k1.utils.randomPrivateKey,lift_x:R,pointToBytes:v,numberToBytesBE:a.numberToBytesBE,bytesToNumberBE:a.bytesToNumberBE,taggedHash:B,mod:f.mod}};const L=(()=>(0,i.isogenyMap)(g,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map((t=>t.map((t=>BigInt(t)))))))(),T=(()=>(0,c.mapToCurveSimpleSWU)(g,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:g.create(BigInt("-11"))}))(),N=(()=>(0,i.createHasher)(e.secp256k1.ProjectivePoint,(t=>{const{x:e,y:n}=T(g.create(t[0]));return L(e,n)}),{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:g.ORDER,m:1,k:128,expand:"xmd",hash:r.sha256}))();e.hashToCurve=N.hashToCurve,e.encodeToCurve=N.encodeToCurve},391839:(t,e)=>{function n(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`positive integer expected, not ${t}`)}function r(t){if("boolean"!=typeof t)throw new Error(`boolean expected, not ${t}`)}function o(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}function s(t,...e){if(!o(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}function i(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");n(t.outputLen),n(t.blockLen)}function f(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function a(t,e){s(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}Object.defineProperty(e,"__esModule",{value:!0}),e.output=e.exists=e.hash=e.bytes=e.bool=e.number=e.isBytes=void 0,e.number=n,e.bool=r,e.isBytes=o,e.bytes=s,e.hash=i,e.exists=f,e.output=a;const c={number:n,bool:r,bytes:s,hash:i,exists:f,output:a};e.default=c},291116:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.HashMD=e.Maj=e.Chi=void 0;const r=n(391839),o=n(850300);e.Chi=(t,e,n)=>t&e^~t&n,e.Maj=(t,e,n)=>t&e^t&n^e&n;class s extends o.Hash{constructor(t,e,n,r){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=(0,o.createView)(this.buffer)}update(t){(0,r.exists)(this);const{view:e,buffer:n,blockLen:s}=this,i=(t=(0,o.toBytes)(t)).length;for(let r=0;r<i;){const f=Math.min(s-this.pos,i-r);if(f!==s)n.set(t.subarray(r,r+f),this.pos),this.pos+=f,r+=f,this.pos===s&&(this.process(e,0),this.pos=0);else{const e=(0,o.createView)(t);for(;s<=i-r;r+=s)this.process(e,r)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){(0,r.exists)(this),(0,r.output)(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:s,isLE:i}=this;let{pos:f}=this;e[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>s-f&&(this.process(n,0),f=0);for(let t=f;t<s;t++)e[t]=0;!function(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),i=Number(n>>o&s),f=Number(n&s),a=r?4:0,c=r?0:4;t.setUint32(e+a,i,r),t.setUint32(e+c,f,r)}(n,s-8,BigInt(8*this.length),i),this.process(n,0);const a=(0,o.createView)(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,h=this.get();if(u>h.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<u;t++)a.setUint32(4*t,h[t],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:o,destroyed:s,pos:i}=this;return t.length=r,t.pos=i,t.finished=o,t.destroyed=s,r%e&&t.buffer.set(n),t}}e.HashMD=s},402426:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.add5L=e.add5H=e.add4H=e.add4L=e.add3H=e.add3L=e.add=e.rotlBL=e.rotlBH=e.rotlSL=e.rotlSH=e.rotr32L=e.rotr32H=e.rotrBL=e.rotrBH=e.rotrSL=e.rotrSH=e.shrSL=e.shrSH=e.toBig=e.split=e.fromBig=void 0;const n=BigInt(2**32-1),r=BigInt(32);function o(t,e=!1){return e?{h:Number(t&n),l:Number(t>>r&n)}:{h:0|Number(t>>r&n),l:0|Number(t&n)}}function s(t,e=!1){let n=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let s=0;s<t.length;s++){const{h:i,l:f}=o(t[s],e);[n[s],r[s]]=[i,f]}return[n,r]}e.fromBig=o,e.split=s;const i=(t,e)=>BigInt(t>>>0)<<r|BigInt(e>>>0);e.toBig=i;const f=(t,e,n)=>t>>>n;e.shrSH=f;const a=(t,e,n)=>t<<32-n|e>>>n;e.shrSL=a;const c=(t,e,n)=>t>>>n|e<<32-n;e.rotrSH=c;const u=(t,e,n)=>t<<32-n|e>>>n;e.rotrSL=u;const h=(t,e,n)=>t<<64-n|e>>>n-32;e.rotrBH=h;const l=(t,e,n)=>t>>>n-32|e<<64-n;e.rotrBL=l;const d=(t,e)=>e;e.rotr32H=d;const p=(t,e)=>t;e.rotr32L=p;const y=(t,e,n)=>t<<n|e>>>32-n;e.rotlSH=y;const g=(t,e,n)=>e<<n|t>>>32-n;e.rotlSL=g;const b=(t,e,n)=>e<<n-32|t>>>64-n;e.rotlBH=b;const w=(t,e,n)=>t<<n-32|e>>>64-n;function m(t,e,n,r){const o=(e>>>0)+(r>>>0);return{h:t+n+(o/2**32|0)|0,l:0|o}}e.rotlBL=w,e.add=m;const E=(t,e,n)=>(t>>>0)+(e>>>0)+(n>>>0);e.add3L=E;const B=(t,e,n,r)=>e+n+r+(t/2**32|0)|0;e.add3H=B;const v=(t,e,n,r)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0);e.add4L=v;const x=(t,e,n,r,o)=>e+n+r+o+(t/2**32|0)|0;e.add4H=x;const S=(t,e,n,r,o)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0)+(o>>>0);e.add5L=S;const I=(t,e,n,r,o,s)=>e+n+r+o+s+(t/2**32|0)|0;e.add5H=I;const A={fromBig:o,split:s,toBig:i,shrSH:f,shrSL:a,rotrSH:c,rotrSL:u,rotrBH:h,rotrBL:l,rotr32H:d,rotr32L:p,rotlSH:y,rotlSL:g,rotlBH:b,rotlBL:w,add:m,add3L:E,add3H:B,add4L:v,add4H:x,add5H:I,add5L:S};e.default=A},644937:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.crypto=void 0,e.crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},170520:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.hmac=e.HMAC=void 0;const r=n(391839),o=n(850300);class s extends o.Hash{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,(0,r.hash)(t);const n=(0,o.toBytes)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(n.length>s?t.create().update(n).digest():n);for(let t=0;t<i.length;t++)i[t]^=54;this.iHash.update(i),this.oHash=t.create();for(let t=0;t<i.length;t++)i[t]^=106;this.oHash.update(i),i.fill(0)}update(t){return(0,r.exists)(this),this.iHash.update(t),this}digestInto(t){(0,r.exists)(this),(0,r.bytes)(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:o,blockLen:s,outputLen:i}=this;return t.finished=r,t.destroyed=o,t.blockLen=s,t.outputLen=i,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}e.HMAC=s,e.hmac=(t,e,n)=>new s(t,e).update(n).digest(),e.hmac.create=(t,e)=>new s(t,e)},213426:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.sha224=e.sha256=void 0;const r=n(291116),o=n(850300),s=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),i=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),f=new Uint32Array(64);class a extends r.HashMD{constructor(){super(64,32,8,!1),this.A=0|i[0],this.B=0|i[1],this.C=0|i[2],this.D=0|i[3],this.E=0|i[4],this.F=0|i[5],this.G=0|i[6],this.H=0|i[7]}get(){const{A:t,B:e,C:n,D:r,E:o,F:s,G:i,H:f}=this;return[t,e,n,r,o,s,i,f]}set(t,e,n,r,o,s,i,f){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|o,this.F=0|s,this.G=0|i,this.H=0|f}process(t,e){for(let n=0;n<16;n++,e+=4)f[n]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=f[t-15],n=f[t-2],r=(0,o.rotr)(e,7)^(0,o.rotr)(e,18)^e>>>3,s=(0,o.rotr)(n,17)^(0,o.rotr)(n,19)^n>>>10;f[t]=s+f[t-7]+r+f[t-16]|0}let{A:n,B:i,C:a,D:c,E:u,F:h,G:l,H:d}=this;for(let t=0;t<64;t++){const e=d+((0,o.rotr)(u,6)^(0,o.rotr)(u,11)^(0,o.rotr)(u,25))+(0,r.Chi)(u,h,l)+s[t]+f[t]|0,p=((0,o.rotr)(n,2)^(0,o.rotr)(n,13)^(0,o.rotr)(n,22))+(0,r.Maj)(n,i,a)|0;d=l,l=h,h=u,u=c+e|0,c=a,a=i,i=n,n=e+p|0}n=n+this.A|0,i=i+this.B|0,a=a+this.C|0,c=c+this.D|0,u=u+this.E|0,h=h+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(n,i,a,c,u,h,l,d)}roundClean(){f.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class c extends a{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}e.sha256=(0,o.wrapConstructor)((()=>new a)),e.sha224=(0,o.wrapConstructor)((()=>new c))},373488:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.shake256=e.shake128=e.keccak_512=e.keccak_384=e.keccak_256=e.keccak_224=e.sha3_512=e.sha3_384=e.sha3_256=e.sha3_224=e.Keccak=e.keccakP=void 0;const r=n(391839),o=n(402426),s=n(850300),i=[],f=[],a=[],c=BigInt(0),u=BigInt(1),h=BigInt(2),l=BigInt(7),d=BigInt(256),p=BigInt(113);for(let t=0,e=u,n=1,r=0;t<24;t++){[n,r]=[r,(2*n+3*r)%5],i.push(2*(5*r+n)),f.push((t+1)*(t+2)/2%64);let o=c;for(let t=0;t<7;t++)e=(e<<u^(e>>l)*p)%d,e&h&&(o^=u<<(u<<BigInt(t))-u);a.push(o)}const[y,g]=(0,o.split)(a,!0),b=(t,e,n)=>n>32?(0,o.rotlBH)(t,e,n):(0,o.rotlSH)(t,e,n),w=(t,e,n)=>n>32?(0,o.rotlBL)(t,e,n):(0,o.rotlSL)(t,e,n);function m(t,e=24){const n=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let e=0;e<10;e++)n[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const r=(e+8)%10,o=(e+2)%10,s=n[o],i=n[o+1],f=b(s,i,1)^n[r],a=w(s,i,1)^n[r+1];for(let n=0;n<50;n+=10)t[e+n]^=f,t[e+n+1]^=a}let e=t[2],o=t[3];for(let n=0;n<24;n++){const r=f[n],s=b(e,o,r),a=w(e,o,r),c=i[n];e=t[c],o=t[c+1],t[c]=s,t[c+1]=a}for(let e=0;e<50;e+=10){for(let r=0;r<10;r++)n[r]=t[e+r];for(let r=0;r<10;r++)t[e+r]^=~n[(r+2)%10]&n[(r+4)%10]}t[0]^=y[r],t[1]^=g[r]}n.fill(0)}e.keccakP=m;class E extends s.Hash{constructor(t,e,n,o=!1,i=24){if(super(),this.blockLen=t,this.suffix=e,this.outputLen=n,this.enableXOF=o,this.rounds=i,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,r.number)(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,s.u32)(this.state)}keccak(){s.isLE||(0,s.byteSwap32)(this.state32),m(this.state32,this.rounds),s.isLE||(0,s.byteSwap32)(this.state32),this.posOut=0,this.pos=0}update(t){(0,r.exists)(this);const{blockLen:e,state:n}=this,o=(t=(0,s.toBytes)(t)).length;for(let r=0;r<o;){const s=Math.min(e-this.pos,o-r);for(let e=0;e<s;e++)n[this.pos++]^=t[r++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:n,blockLen:r}=this;t[n]^=e,0!=(128&e)&&n===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){(0,r.exists)(this,!1),(0,r.bytes)(t),this.finish();const e=this.state,{blockLen:n}=this;for(let r=0,o=t.length;r<o;){this.posOut>=n&&this.keccak();const s=Math.min(n-this.posOut,o-r);t.set(e.subarray(this.posOut,this.posOut+s),r),this.posOut+=s,r+=s}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return(0,r.number)(t),this.xofInto(new Uint8Array(t))}digestInto(t){if((0,r.output)(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:n,outputLen:r,rounds:o,enableXOF:s}=this;return t||(t=new E(e,n,r,s,o)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=o,t.suffix=n,t.outputLen=r,t.enableXOF=s,t.destroyed=this.destroyed,t}}e.Keccak=E;const B=(t,e,n)=>(0,s.wrapConstructor)((()=>new E(e,t,n)));e.sha3_224=B(6,144,28),e.sha3_256=B(6,136,32),e.sha3_384=B(6,104,48),e.sha3_512=B(6,72,64),e.keccak_224=B(1,144,28),e.keccak_256=B(1,136,32),e.keccak_384=B(1,104,48),e.keccak_512=B(1,72,64);const v=(t,e,n)=>(0,s.wrapXOFConstructorWithOpts)(((r={})=>new E(e,t,void 0===r.dkLen?n:r.dkLen,!0)));e.shake128=v(31,168,16),e.shake256=v(31,136,32)},850300:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.randomBytes=e.wrapXOFConstructorWithOpts=e.wrapConstructorWithOpts=e.wrapConstructor=e.checkOpts=e.Hash=e.concatBytes=e.toBytes=e.utf8ToBytes=e.asyncLoop=e.nextTick=e.hexToBytes=e.bytesToHex=e.byteSwap32=e.byteSwapIfBE=e.byteSwap=e.isLE=e.rotl=e.rotr=e.createView=e.u32=e.u8=e.isBytes=void 0;const r=n(644937),o=n(391839);e.isBytes=function(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name},e.u8=t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength),e.u32=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),e.createView=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),e.rotr=(t,e)=>t<<32-e|t>>>e,e.rotl=(t,e)=>t<<e|t>>>32-e>>>0,e.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],e.byteSwap=t=>t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255,e.byteSwapIfBE=e.isLE?t=>t:t=>(0,e.byteSwap)(t),e.byteSwap32=function(t){for(let n=0;n<t.length;n++)t[n]=(0,e.byteSwap)(t[n])};const s=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));e.bytesToHex=function(t){(0,o.bytes)(t);let e="";for(let n=0;n<t.length;n++)e+=s[t[n]];return e};const i=48,f=57,a=65,c=70,u=97,h=102;function l(t){return t>=i&&t<=f?t-i:t>=a&&t<=c?t-(a-10):t>=u&&t<=h?t-(u-10):void 0}function d(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function p(t){return"string"==typeof t&&(t=d(t)),(0,o.bytes)(t),t}e.hexToBytes=function(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let e=0,o=0;e<n;e++,o+=2){const n=l(t.charCodeAt(o)),s=l(t.charCodeAt(o+1));if(void 0===n||void 0===s){const e=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+o)}r[e]=16*n+s}return r},e.nextTick=async()=>{},e.asyncLoop=async function(t,n,r){let o=Date.now();for(let s=0;s<t;s++){r(s);const t=Date.now()-o;t>=0&&t<n||(await(0,e.nextTick)(),o+=t)}},e.utf8ToBytes=d,e.toBytes=p,e.concatBytes=function(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];(0,o.bytes)(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n},e.Hash=class{clone(){return this._cloneInto()}};const y={}.toString;e.checkOpts=function(t,e){if(void 0!==e&&"[object Object]"!==y.call(e))throw new Error("Options should be object or undefined");return Object.assign(t,e)},e.wrapConstructor=function(t){const e=e=>t().update(p(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e},e.wrapConstructorWithOpts=function(t){const e=(e,n)=>t(n).update(p(e)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=e=>t(e),e},e.wrapXOFConstructorWithOpts=function(t){const e=(e,n)=>t(n).update(p(e)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=e=>t(e),e},e.randomBytes=function(t=32){if(r.crypto&&"function"==typeof r.crypto.getRandomValues)return r.crypto.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}},386464:(t,e,n)=>{n.d(e,{_:()=>o});var r=n(789629);function o(t,e){const n=e=>(0,r.e4)({...t,hash:e});return{...n(e),create:n}}},505849:(t,e,n)=>{n.d(e,{h:()=>y});var r=n(687427),o=n(590920),s=n(388246),i=n(164197),f=n(395814),a=n(789629);const c=BigInt(0),u=BigInt(1),h=BigInt(2),l=BigInt(3);function d(t){if(!Array.isArray(t)||0===t.length)throw new Error("expected non-empty array")}function p(t,e,n,r,s){const{Fp12:i,pairingBatch:f}=t;function c(t){return t instanceof e.Point?t:e.Point.fromHex(t)}function u(t){return t instanceof n.Point?t:n.Point.fromHex(t)}function h(t){if(!(t instanceof n.Point))throw new Error(`expected valid message hashed to ${s?"G1":"G2"} curve`);return t}const l=s?(t,e)=>({g1:e,g2:t}):(t,e)=>({g1:t,g2:e});return{getPublicKey(t){const n=(0,a.Nh)(e.Point.Fn,t);return e.Point.BASE.multiply(n)},sign(t,n,r){if(null!=r)throw new Error("sign() expects 2 arguments");const o=(0,a.Nh)(e.Point.Fn,n);return h(t).assertValidity(),t.multiply(o)},verify(t,n,r,o){if(null!=o)throw new Error("verify() expects 3 arguments");t=u(t);const s=(r=c(r)).negate(),a=e.Point.BASE,d=h(n),p=t,y=f([l(s,d),l(a,p)]);return i.eql(y,i.ONE)},verifyBatch(t,n,r){if(d(n),r.length!==n.length)throw new Error("amount of public keys and messages should be equal");const o=u(t),s=n,a=r.map(c),h=new Map;for(let t=0;t<a.length;t++){const e=a[t],n=s[t];let r=h.get(n);void 0===r&&(r=[],h.set(n,r)),r.push(e)}const p=[],y=e.Point.BASE;try{for(const[t,e]of h){const n=e.reduce(((t,e)=>t.add(e)));p.push(l(n,t))}return p.push(l(y.negate(),o)),i.eql(f(p),i.ONE)}catch{return!1}},aggregatePublicKeys(t){d(t);const n=(t=t.map((t=>c(t)))).reduce(((t,e)=>t.add(e)),e.Point.ZERO);return n.assertValidity(),n},aggregateSignatures(t){d(t);const e=(t=t.map((t=>u(t)))).reduce(((t,e)=>t.add(e)),n.Point.ZERO);return e.assertValidity(),e},hash(t,e){(0,o.gk)(t);const r=e?{DST:e}:void 0;return n.hashToCurve(t,r)},Signature:r}}function y(t){const{Fp:e,Fr:n,Fp2:d,Fp6:y,Fp12:g}=t.fields,b=(0,a.su)(t.G1),w=Object.assign(b,(0,i.V1)(b.Point,t.G1.mapToCurve,{...t.htfDefaults,...t.G1.htfDefaults})),m=(0,a.su)(t.G2),E=Object.assign(m,(0,i.V1)(m.Point,t.G2.mapToCurve,{...t.htfDefaults,...t.G2.htfDefaults})),B=function(t,e,n,o){const{Fp2:i,Fp12:f}=t,{twistType:a,ateLoopSize:d,xNegative:p,postPrecompute:y}=o;let g;if("multiplicative"===a)g=(t,e,n,r,o,s)=>f.mul014(r,t,i.mul(e,o),i.mul(n,s));else{if("divisive"!==a)throw new Error("bls: unknown twist type");g=(t,e,n,r,o,s)=>f.mul034(r,i.mul(n,s),i.mul(e,o),t)}const b=i.div(i.ONE,i.mul(i.ONE,h));function w(t,e,n,r){const o=i.sqr(n),s=i.sqr(r),f=i.mulByB(i.mul(s,l)),a=i.mul(f,l),c=i.sub(i.sub(i.sqr(i.add(n,r)),s),o),u=i.sub(f,o),h=i.mul(i.sqr(e),l),d=i.neg(c);return t.push([u,h,d]),{Rx:e=i.mul(i.mul(i.mul(i.sub(o,a),e),n),b),Ry:n=i.sub(i.sqr(i.mul(i.add(o,a),b)),i.mul(i.sqr(f),l)),Rz:r=i.mul(o,c)}}function m(t,e,n,r,o,s){const f=i.sub(n,i.mul(s,r)),a=i.sub(e,i.mul(o,r)),c=i.sub(i.mul(f,o),i.mul(a,s)),u=i.neg(f),l=a;t.push([c,u,l]);const d=i.sqr(a),p=i.mul(d,a),y=i.mul(d,e),g=i.add(i.sub(p,i.mul(y,h)),i.mul(i.sqr(f),r));return{Rx:e=i.mul(a,g),Ry:n=i.sub(i.mul(i.sub(y,g),f),i.mul(p,n)),Rz:r=i.mul(r,p)}}const E=function(t){const e=[];for(;t>u;t>>=u)(t&u)===c?e.unshift(0):(t&l)===l?(e.unshift(-1),t+=u):e.unshift(1);return e}(d),B=(0,r.H9)((t=>{const e=t,{x:n,y:r}=e.toAffine(),o=n,s=r,f=i.neg(r);let a=o,c=s,u=i.ONE;const h=[];for(const t of E){const e=[];({Rx:a,Ry:c,Rz:u}=w(e,a,c,u)),t&&({Rx:a,Ry:c,Rz:u}=m(e,a,c,u,o,-1===t?f:s)),h.push(e)}if(y){const t=h[h.length-1];y(a,c,u,o,s,m.bind(null,t))}return h}));function v(t,e=!1){let n=f.ONE;if(t.length){const e=t[0][0].length;for(let r=0;r<e;r++){n=f.sqr(n);for(const[e,o,s]of t)for(const[t,i,f]of e[r])n=g(t,i,f,n,o,s)}}return p&&(n=f.conjugate(n)),e?f.finalExponentiate(n):n}function x(t,r=!0){const o=[];(0,s.A1)(e,t.map((({g1:t})=>t))),(0,s.A1)(n,t.map((({g2:t})=>t)));for(const{g1:e,g2:n}of t){if(e.is0()||n.is0())throw new Error("pairing is not available for ZERO point");e.assertValidity(),n.assertValidity();const t=e.toAffine();o.push([B(n),t.x,t.y])}return v(o,r)}return{Fp12:f,millerLoopBatch:v,pairing:function(t,e,n=!0){return x([{g1:t,g2:e}],n)},pairingBatch:x,calcPairingPrecomputes:B}}(t.fields,w.Point,E.Point,{...t.params,postPrecompute:t.postPrecompute}),{millerLoopBatch:v,pairing:x,pairingBatch:S,calcPairingPrecomputes:I}=B,A=p(B,w,E,t.G2.Signature,!1),O=p(B,E,w,t.G1.ShortSignature,!0),_=t.randomBytes||o.O6,R=()=>{const t=(0,f.PS)(n.ORDER);return(0,f.Us)(_(t),n.ORDER)},F={randomSecretKey:R,randomPrivateKey:R,calcPairingPrecomputes:I},{ShortSignature:H}=t.G1,{Signature:L}=t.G2;function T(t,e){return t instanceof w.Point?t:O.hash((0,r.ql)("point",t),e?.DST)}function N(t,e){return t instanceof E.Point?t:A.hash((0,r.ql)("point",t),e?.DST)}return w.Point.BASE.precompute(4),{longSignatures:A,shortSignatures:O,millerLoopBatch:v,pairing:x,pairingBatch:S,verifyBatch:function(t,e,n,r){const o=e.map((t=>N(t,r)));return A.verifyBatch(t,o,n)},fields:{Fr:n,Fp:e,Fp2:d,Fp6:y,Fp12:g},params:{ateLoopSize:t.params.ateLoopSize,twistType:t.params.twistType,r:t.params.r,G1b:t.G1.b,G2b:t.G2.b},utils:F,getPublicKey:function(t){return A.getPublicKey(t).toBytes(!0)},getPublicKeyForShortSignatures:function(t){return O.getPublicKey(t).toBytes(!0)},sign:function(t,e,n){const r=N(t,n),o=A.sign(r,e);return t instanceof E.Point?o:L.toBytes(o)},signShortSignature:function(t,e,n){const r=T(t,n),o=O.sign(r,e);return t instanceof w.Point?o:H.toBytes(o)},verify:function(t,e,n,r){const o=N(e,r);return A.verify(t,o,n)},verifyShortSignature:function(t,e,n,r){const o=T(e,r);return O.verify(t,o,n)},aggregatePublicKeys:function(t){const e=A.aggregatePublicKeys(t);return t[0]instanceof w.Point?e:e.toBytes(!0)},aggregateSignatures:function(t){const e=A.aggregateSignatures(t);return t[0]instanceof E.Point?e:L.toBytes(e)},aggregateShortSignatures:function(t){const e=O.aggregateSignatures(t);return t[0]instanceof w.Point?e:H.toBytes(e)},G1:w,G2:E,Signature:L,ShortSignature:H}}},388246:(t,e,n)=>{n.d(e,{A1:()=>a,D1:()=>w,Mx:()=>g,N6:()=>b,rO:()=>E,xg:()=>f});var r=n(687427),o=n(395814);const s=BigInt(0),i=BigInt(1);function f(t,e){const n=e.negate();return t?n:e}function a(t,e){const n=(0,o.Eg)(t.Fp,e.map((t=>t.Z)));return e.map(((e,r)=>t.fromAffine(e.toAffine(n[r]))))}function c(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function u(t,e){c(t,e);const n=2**t;return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1),mask:(0,r.dQ)(t),maxNumber:n,shiftBy:BigInt(t)}}function h(t,e,n){const{windowSize:r,mask:o,maxNumber:s,shiftBy:f}=n;let a=Number(t&o),c=t>>f;a>r&&(a-=s,c+=i);const u=e*r;return{nextN:c,offset:u+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:e%2!=0,offsetF:u}}const l=new WeakMap,d=new WeakMap;function p(t){return d.get(t)||1}function y(t){if(t!==s)throw new Error("invalid wNAF")}class g{constructor(t,e){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,n=this.ZERO){let r=t;for(;e>s;)e&i&&(n=n.add(r)),r=r.double(),e>>=i;return n}precomputeWindow(t,e){const{windows:n,windowSize:r}=u(e,this.bits),o=[];let s=t,i=s;for(let t=0;t<n;t++){i=s,o.push(i);for(let t=1;t<r;t++)i=i.add(s),o.push(i);s=i.double()}return o}wNAF(t,e,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let r=this.ZERO,o=this.BASE;const s=u(t,this.bits);for(let t=0;t<s.windows;t++){const{nextN:i,offset:a,isZero:c,isNeg:u,isNegF:l,offsetF:d}=h(n,t,s);n=i,c?o=o.add(f(l,e[d])):r=r.add(f(u,e[a]))}return y(n),{p:r,f:o}}wNAFUnsafe(t,e,n,r=this.ZERO){const o=u(t,this.bits);for(let t=0;t<o.windows&&n!==s;t++){const{nextN:s,offset:i,isZero:f,isNeg:a}=h(n,t,o);if(n=s,!f){const t=e[i];r=r.add(a?t.negate():t)}}return y(n),r}getPrecomputes(t,e,n){let r=l.get(e);return r||(r=this.precomputeWindow(e,t),1!==t&&("function"==typeof n&&(r=n(r)),l.set(e,r))),r}cached(t,e,n){const r=p(t);return this.wNAF(r,this.getPrecomputes(r,t,n),e)}unsafe(t,e,n,r){const o=p(t);return 1===o?this._unsafeLadder(t,e,r):this.wNAFUnsafe(o,this.getPrecomputes(o,t,n),e,r)}createCache(t,e){c(e,this.bits),d.set(t,e),l.delete(t)}hasCache(t){return 1!==p(t)}}function b(t,e,n,r){let o=e,f=t.ZERO,a=t.ZERO;for(;n>s||r>s;)n&i&&(f=f.add(o)),r&i&&(a=a.add(o)),o=o.double(),n>>=i,r>>=i;return{p1:f,p2:a}}function w(t,e,n,o){(function(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach(((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)}))})(n,t),function(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach(((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)}))}(o,e);const s=n.length,i=o.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const f=t.ZERO,a=(0,r.Dd)(BigInt(s));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const u=(0,r.dQ)(c),h=new Array(Number(u)+1).fill(f);let l=f;for(let t=Math.floor((e.BITS-1)/c)*c;t>=0;t-=c){h.fill(f);for(let e=0;e<i;e++){const r=o[e],s=Number(r>>BigInt(t)&u);h[s]=h[s].add(n[e])}let e=f;for(let t=h.length-1,n=f;t>0;t--)n=n.add(h[t]),e=e.add(n);if(l=l.add(e),0!==t)for(let t=0;t<c;t++)l=l.double()}return l}function m(t,e,n){if(e){if(e.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return(0,o.OP)(e),e}return(0,o.gN)(t,{isLE:n})}function E(t,e,n={},r){if(void 0===r&&(r="edwards"===t),!e||"object"!=typeof e)throw new Error(`expected valid ${t} CURVE object`);for(const t of["p","n","h"]){const n=e[t];if(!("bigint"==typeof n&&n>s))throw new Error(`CURVE.${t} must be positive bigint`)}const o=m(e.p,n.Fp,r),i=m(e.n,n.Fn,r),f=["Gx","Gy","a","weierstrass"===t?"b":"d"];for(const t of f)if(!o.isValid(e[t]))throw new Error(`CURVE.${t} must be valid field element of CURVE.Fp`);return{CURVE:e=Object.freeze(Object.assign({},e)),Fp:o,Fn:i}}},124716:(t,e,n)=>{n.d(e,{eT:()=>l,gE:()=>h});var r=n(687427),o=n(590920),s=n(388246),i=n(395814);const f=BigInt(0),a=BigInt(1),c=BigInt(2),u=BigInt(8);class h{constructor(t){this.ep=t}static fromBytes(t){(0,r.EQ)()}static fromHex(t){(0,r.EQ)()}get x(){return this.toAffine().x}get y(){return this.toAffine().y}clearCofactor(){return this}assertValidity(){this.ep.assertValidity()}toAffine(t){return this.ep.toAffine(t)}toHex(){return(0,o.ci)(this.toBytes())}toString(){return this.toHex()}isTorsionFree(){return!0}isSmallOrder(){return!1}add(t){return this.assertSame(t),this.init(this.ep.add(t.ep))}subtract(t){return this.assertSame(t),this.init(this.ep.subtract(t.ep))}multiply(t){return this.init(this.ep.multiply(t))}multiplyUnsafe(t){return this.init(this.ep.multiplyUnsafe(t))}double(){return this.init(this.ep.double())}negate(){return this.init(this.ep.negate())}precompute(t,e){return this.init(this.ep.precompute(t,e))}toRawBytes(){return this.toBytes()}}function l(t){const{CURVE:e,curveOpts:n,hash:h,eddsaOpts:l}=function(t){const e={a:t.a,d:t.d,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},n={Fp:t.Fp,Fn:(0,i.gN)(e.n,t.nBitLength,!0),uvRatio:t.uvRatio},r={randomBytes:t.randomBytes,adjustScalarBytes:t.adjustScalarBytes,domain:t.domain,prehash:t.prehash,mapToCurve:t.mapToCurve};return{CURVE:e,curveOpts:n,hash:t.hash,eddsaOpts:r}}(t),d=function(t,e={}){const n=(0,s.rO)("edwards",t,e,e.FpFnLE),{Fp:i,Fn:h}=n;let l=n.CURVE;const{h:d}=l;(0,r.fA)(e,{},{uvRatio:"function"});const p=c<<BigInt(8*h.BYTES)-a,y=t=>i.create(t),g=e.uvRatio||((t,e)=>{try{return{isValid:!0,value:i.sqrt(i.div(t,e))}}catch(t){return{isValid:!1,value:f}}});if(!function(t,e,n,r){const o=t.sqr(n),s=t.sqr(r),i=t.add(t.mul(e.a,o),s),f=t.add(t.ONE,t.mul(e.d,t.mul(o,s)));return t.eql(i,f)}(i,l,l.Gx,l.Gy))throw new Error("bad curve params: generator point");function b(t,e,n=!1){const o=n?a:f;return(0,r.Fy)("coordinate "+t,e,o,p),e}function w(t){if(!(t instanceof B))throw new Error("ExtendedPoint expected")}const m=(0,r.H9)(((t,e)=>{const{X:n,Y:r,Z:o}=t,s=t.is0();null==e&&(e=s?u:i.inv(o));const c=y(n*e),h=y(r*e),l=i.mul(o,e);if(s)return{x:f,y:a};if(l!==a)throw new Error("invZ was invalid");return{x:c,y:h}})),E=(0,r.H9)((t=>{const{a:e,d:n}=l;if(t.is0())throw new Error("bad point: ZERO");const{X:r,Y:o,Z:s,T:i}=t,f=y(r*r),a=y(o*o),c=y(s*s),u=y(c*c),h=y(f*e);if(y(c*y(h+a))!==y(u+y(n*y(f*a))))throw new Error("bad point: equation left != right (1)");if(y(r*o)!==y(s*i))throw new Error("bad point: equation left != right (2)");return!0}));class B{constructor(t,e,n,r){this.X=b("x",t),this.Y=b("y",e),this.Z=b("z",n,!0),this.T=b("t",r),Object.freeze(this)}static CURVE(){return l}static fromAffine(t){if(t instanceof B)throw new Error("extended point not allowed");const{x:e,y:n}=t||{};return b("x",e),b("y",n),new B(e,n,a,y(e*n))}static fromBytes(t,e=!1){const n=i.BYTES,{a:o,d:s}=l;t=(0,r.HV)((0,r.GB)(t,n,"point")),(0,r.po)(e,"zip215");const c=(0,r.HV)(t),u=t[n-1];c[n-1]=-129&u;const h=(0,r.ty)(c),d=e?p:i.ORDER;(0,r.Fy)("point.y",h,f,d);const b=y(h*h),w=y(b-a),m=y(s*b-o);let{isValid:E,value:v}=g(w,m);if(!E)throw new Error("bad point: invalid y coordinate");const x=(v&a)===a,S=0!=(128&u);if(!e&&v===f&&S)throw new Error("bad point: x=0 and x_0=1");return S!==x&&(v=y(-v)),B.fromAffine({x:v,y:h})}static fromHex(t,e=!1){return B.fromBytes((0,r.ql)("point",t),e)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(t=8,e=!0){return v.createCache(this,t),e||this.multiply(c),this}assertValidity(){E(this)}equals(t){w(t);const{X:e,Y:n,Z:r}=this,{X:o,Y:s,Z:i}=t,f=y(e*i),a=y(o*r),c=y(n*i),u=y(s*r);return f===a&&c===u}is0(){return this.equals(B.ZERO)}negate(){return new B(y(-this.X),this.Y,this.Z,y(-this.T))}double(){const{a:t}=l,{X:e,Y:n,Z:r}=this,o=y(e*e),s=y(n*n),i=y(c*y(r*r)),f=y(t*o),a=e+n,u=y(y(a*a)-o-s),h=f+s,d=h-i,p=f-s,g=y(u*d),b=y(h*p),w=y(u*p),m=y(d*h);return new B(g,b,m,w)}add(t){w(t);const{a:e,d:n}=l,{X:r,Y:o,Z:s,T:i}=this,{X:f,Y:a,Z:c,T:u}=t,h=y(r*f),d=y(o*a),p=y(i*n*u),g=y(s*c),b=y((r+o)*(f+a)-h-d),m=g-p,E=g+p,v=y(d-e*h),x=y(b*m),S=y(E*v),I=y(b*v),A=y(m*E);return new B(x,S,A,I)}subtract(t){return this.add(t.negate())}multiply(t){if(!h.isValidNot0(t))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:e,f:n}=v.cached(this,t,(t=>(0,s.A1)(B,t)));return(0,s.A1)(B,[e,n])[0]}multiplyUnsafe(t,e=B.ZERO){if(!h.isValid(t))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return t===f?B.ZERO:this.is0()||t===a?this:v.unsafe(this,t,(t=>(0,s.A1)(B,t)),e)}isSmallOrder(){return this.multiplyUnsafe(d).is0()}isTorsionFree(){return v.unsafe(this,l.n).is0()}toAffine(t){return m(this,t)}clearCofactor(){return d===a?this:this.multiplyUnsafe(d)}toBytes(){const{x:t,y:e}=this.toAffine(),n=i.toBytes(e);return n[n.length-1]|=t&a?128:0,n}toHex(){return(0,o.ci)(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(t){return(0,s.A1)(B,t)}static msm(t,e){return(0,s.D1)(B,h,t,e)}_setWindowSize(t){this.precompute(t)}toRawBytes(){return this.toBytes()}}B.BASE=new B(l.Gx,l.Gy,a,y(l.Gx*l.Gy)),B.ZERO=new B(f,a,a,f),B.Fp=i,B.Fn=h;const v=new s.Mx(B,h.BITS);return B.BASE.precompute(8),B}(e,n);return function(t,e){const n=e.Point;return Object.assign({},e,{ExtendedPoint:n,CURVE:t,nBitLength:n.Fn.BITS,nByteLength:n.Fn.BYTES})}(t,function(t,e,n={}){if("function"!=typeof e)throw new Error('"hash" function param is required');(0,r.fA)(n,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:s}=n,{BASE:i,Fp:f,Fn:c}=t,u=n.randomBytes||o.O6,h=n.adjustScalarBytes||(t=>t),l=n.domain||((t,e,n)=>{if((0,r.po)(n,"phflag"),e.length||n)throw new Error("Contexts/pre-hash are not supported");return t});function d(t){return c.create((0,r.ty)(t))}function p(t){const{head:n,prefix:o,scalar:s}=function(t){const n=m.secretKey;t=(0,r.ql)("private key",t,n);const o=(0,r.ql)("hashed private key",e(t),2*n),s=h(o.slice(0,n));return{head:s,prefix:o.slice(n,2*n),scalar:d(s)}}(t),f=i.multiply(s),a=f.toBytes();return{head:n,prefix:o,scalar:s,point:f,pointBytes:a}}function y(t){return p(t).pointBytes}function g(t=Uint8Array.of(),...n){const i=(0,o.eV)(...n);return d(e(l(i,(0,r.ql)("context",t),!!s)))}const b={zip215:!0},w=f.BYTES,m={secretKey:w,publicKey:w,signature:2*w,seed:w};function E(t=u(m.seed)){return(0,r.GB)(t,m.seed,"seed")}const B={getExtendedPublicKey:p,randomSecretKey:E,isValidSecretKey:function(t){return(0,o._t)(t)&&t.length===c.BYTES},isValidPublicKey:function(e,n){try{return!!t.fromBytes(e,n)}catch(t){return!1}},toMontgomery(e){const{y:n}=t.fromBytes(e),r=m.publicKey,o=32===r;if(!o&&57!==r)throw new Error("only defined for 25519 and 448");const s=o?f.div(a+n,a-n):f.div(n-a,n+a);return f.toBytes(s)},toMontgomerySecret(t){const n=m.secretKey;(0,r.GB)(t,n);const o=e(t.subarray(0,n));return h(o).subarray(0,n)},randomPrivateKey:E,precompute:(e=8,n=t.BASE)=>n.precompute(e,!1)};return Object.freeze({keygen:function(t){const e=B.randomSecretKey(t);return{secretKey:e,publicKey:y(e)}},getPublicKey:y,sign:function(t,e,n={}){t=(0,r.ql)("message",t),s&&(t=s(t));const{prefix:f,scalar:a,pointBytes:u}=p(e),h=g(n.context,f,t),l=i.multiply(h).toBytes(),d=g(n.context,l,u,t),y=c.create(h+d*a);if(!c.isValid(y))throw new Error("sign failed: invalid s");const b=(0,o.eV)(l,c.toBytes(y));return(0,r.GB)(b,m.signature,"result")},verify:function(e,n,o,f=b){const{context:a,zip215:c}=f,u=m.signature;e=(0,r.ql)("signature",e,u),n=(0,r.ql)("message",n),o=(0,r.ql)("publicKey",o,m.publicKey),void 0!==c&&(0,r.po)(c,"zip215"),s&&(n=s(n));const h=u/2,l=e.subarray(0,h),d=(0,r.ty)(e.subarray(h,u));let p,y,w;try{p=t.fromBytes(o,c),y=t.fromBytes(l,c),w=i.multiplyUnsafe(d)}catch(t){return!1}if(!c&&p.isSmallOrder())return!1;const E=g(a,y.toBytes(),p.toBytes(),n);return y.add(p.multiplyUnsafe(E)).subtract(w).clearCofactor().is0()},utils:B,Point:t,lengths:m})}(d,h,l))}},164197:(t,e,n)=>{n.d(e,{Fc:()=>d,V1:()=>p,eO:()=>h});var r=n(687427),o=n(590920),s=n(395814);const i=r.Hv;function f(t,e){if(c(t),c(e),t<0||t>=1<<8*e)throw new Error("invalid I2OSP input: "+t);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=255&t,t>>>=8;return new Uint8Array(n)}function a(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function c(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function u(t){if(!(0,o._t)(t)&&"string"!=typeof t)throw new Error("DST must be Uint8Array or string");return"string"==typeof t?(0,o.iY)(t):t}function h(t,e,n,r){(0,o.gk)(t),c(n),(e=u(e)).length>255&&(e=r((0,o.eV)((0,o.iY)("H2C-OVERSIZE-DST-"),e)));const{outputLen:s,blockLen:i}=r,h=Math.ceil(n/s);if(n>65535||h>255)throw new Error("expand_message_xmd: invalid lenInBytes");const l=(0,o.eV)(e,f(e.length,1)),d=f(0,i),p=f(n,2),y=new Array(h),g=r((0,o.eV)(d,t,p,f(0,1),l));y[0]=r((0,o.eV)(g,f(1,1),l));for(let t=1;t<=h;t++){const e=[a(g,y[t-1]),f(t+1,1),l];y[t]=r((0,o.eV)(...e))}return(0,o.eV)(...y).slice(0,n)}function l(t,e,n){(0,r.fA)(n,{p:"bigint",m:"number",k:"number",hash:"function"});const{p:a,k:l,m:d,hash:p,expand:y,DST:g}=n;if(!(0,r.lt)(n.hash))throw new Error("expected valid hash");(0,o.gk)(t),c(e);const b=a.toString(2).length,w=Math.ceil((b+l)/8),m=e*d*w;let E;if("xmd"===y)E=h(t,g,m,p);else if("xof"===y)E=function(t,e,n,r,s){if((0,o.gk)(t),c(n),(e=u(e)).length>255){const t=Math.ceil(2*r/8);e=s.create({dkLen:t}).update((0,o.iY)("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:n}).update(t).update(f(n,2)).update(e).update(f(e.length,1)).digest()}(t,g,m,l,p);else{if("_internal_pass"!==y)throw new Error('expand must be "xmd" or "xof"');E=t}const B=new Array(e);for(let t=0;t<e;t++){const e=new Array(d);for(let n=0;n<d;n++){const r=w*(n+t*d),o=E.subarray(r,r+w);e[n]=(0,s.wQ)(i(o),a)}B[t]=e}return B}const d=(0,o.iY)("HashToScalar-");function p(t,e,n){if("function"!=typeof e)throw new Error("mapToCurve() must be defined");function r(n){return t.fromAffine(e(n))}function o(e){const n=e.clearCofactor();return n.equals(t.ZERO)?t.ZERO:(n.assertValidity(),n)}return{defaults:n,hashToCurve(t,e){const s=l(t,2,Object.assign({},n,e)),i=r(s[0]),f=r(s[1]);return o(i.add(f))},encodeToCurve(t,e){const s=n.encodeDST?{DST:n.encodeDST}:{};return o(r(l(t,1,Object.assign({},n,s,e))[0]))},mapToCurve(t){if(!Array.isArray(t))throw new Error("expected array of bigints");for(const e of t)if("bigint"!=typeof e)throw new Error("expected array of bigints");return o(r(t))},hashToScalar(e,r){const o=t.Fn.ORDER;return l(e,1,Object.assign({},n,{p:o,m:1,DST:d},r))[0][0]}}}},395814:(t,e,n)=>{n.d(e,{Eg:()=>A,IN:()=>O,OP:()=>S,PS:()=>H,Q:()=>I,Tu:()=>v,Us:()=>L,gN:()=>R,kK:()=>_,oA:()=>g,wQ:()=>y});var r=n(687427),o=n(590920);const s=BigInt(0),i=BigInt(1),f=BigInt(2),a=BigInt(3),c=BigInt(4),u=BigInt(5),h=BigInt(7),l=BigInt(8),d=BigInt(9),p=BigInt(16);function y(t,e){const n=t%e;return n>=s?n:e+n}function g(t,e,n){let r=t;for(;e-- >s;)r*=r,r%=n;return r}function b(t,e){if(t===s)throw new Error("invert: expected non-zero number");if(e<=s)throw new Error("invert: expected positive modulus, got "+e);let n=y(t,e),r=e,o=s,f=i,a=i,c=s;for(;n!==s;){const t=r/n,e=r%n,s=o-a*t,i=f-c*t;r=n,n=e,o=a,f=c,a=s,c=i}if(r!==i)throw new Error("invert: does not exist");return y(o,e)}function w(t,e,n){if(!t.eql(t.sqr(e),n))throw new Error("Cannot find square root")}function m(t,e){const n=(t.ORDER+i)/c,r=t.pow(e,n);return w(t,r,e),r}function E(t,e){const n=(t.ORDER-u)/l,r=t.mul(e,f),o=t.pow(r,n),s=t.mul(e,o),i=t.mul(t.mul(s,f),o),a=t.mul(s,t.sub(i,t.ONE));return w(t,a,e),a}function B(t){if(t<a)throw new Error("sqrt is not defined for small field");let e=t-i,n=0;for(;e%f===s;)e/=f,n++;let r=f;const o=R(t);for(;1===O(o,r);)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===n)return m;let c=o.pow(r,e);const u=(e+i)/f;return function(t,r){if(t.is0(r))return r;if(1!==O(t,r))throw new Error("Cannot find square root");let o=n,s=t.mul(t.ONE,c),f=t.pow(r,e),a=t.pow(r,u);for(;!t.eql(f,t.ONE);){if(t.is0(f))return t.ZERO;let e=1,n=t.sqr(f);for(;!t.eql(n,t.ONE);)if(e++,n=t.sqr(n),e===o)throw new Error("Cannot find square root");const r=i<<BigInt(o-e-1),c=t.pow(s,r);o=e,s=t.sqr(c),f=t.mul(f,s),a=t.mul(a,c)}return a}}const v=(t,e)=>(y(t,e)&i)===i,x=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function S(t){const e=x.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"});return(0,r.fA)(t,e),t}function I(t,e,n){if(n<s)throw new Error("invalid exponent, negatives unsupported");if(n===s)return t.ONE;if(n===i)return e;let r=t.ONE,o=e;for(;n>s;)n&i&&(r=t.mul(r,o)),o=t.sqr(o),n>>=i;return r}function A(t,e,n=!1){const r=new Array(e.length).fill(n?t.ZERO:void 0),o=e.reduce(((e,n,o)=>t.is0(n)?e:(r[o]=e,t.mul(e,n))),t.ONE),s=t.inv(o);return e.reduceRight(((e,n,o)=>t.is0(n)?e:(r[o]=t.mul(e,r[o]),t.mul(e,n))),s),r}function O(t,e){const n=(t.ORDER-i)/f,r=t.pow(e,n),o=t.eql(r,t.ONE),s=t.eql(r,t.ZERO),a=t.eql(r,t.neg(t.ONE));if(!o&&!s&&!a)throw new Error("invalid Legendre symbol result");return o?1:s?0:-1}function _(t,e){void 0!==e&&(0,o.k8)(e);const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function R(t,e,n=!1,o={}){if(t<=s)throw new Error("invalid field: expected ORDER > 0, got "+t);let f,g,v,x=!1;if("object"==typeof e&&null!=e){if(o.sqrt||n)throw new Error("cannot specify opts in two arguments");const t=e;t.BITS&&(f=t.BITS),t.sqrt&&(g=t.sqrt),"boolean"==typeof t.isLE&&(n=t.isLE),"boolean"==typeof t.modFromBytes&&(x=t.modFromBytes),v=t.allowedLengths}else"number"==typeof e&&(f=e),o.sqrt&&(g=o.sqrt);const{nBitLength:S,nByteLength:O}=_(t,f);if(O>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let F;const H=Object.freeze({ORDER:t,isLE:n,BITS:S,BYTES:O,MASK:(0,r.dQ)(S),ZERO:s,ONE:i,allowedLengths:v,create:e=>y(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("invalid field element: expected bigint, got "+typeof e);return s<=e&&e<t},is0:t=>t===s,isValidNot0:t=>!H.is0(t)&&H.isValid(t),isOdd:t=>(t&i)===i,neg:e=>y(-e,t),eql:(t,e)=>t===e,sqr:e=>y(e*e,t),add:(e,n)=>y(e+n,t),sub:(e,n)=>y(e-n,t),mul:(e,n)=>y(e*n,t),pow:(t,e)=>I(H,t,e),div:(e,n)=>y(e*b(n,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>b(e,t),sqrt:g||(e=>{return F||(F=(n=t)%c===a?m:n%l===u?E:n%p===d?function(t){const e=R(t),n=B(t),r=n(e,e.neg(e.ONE)),o=n(e,r),s=n(e,e.neg(r)),i=(t+h)/p;return(t,e)=>{let n=t.pow(e,i),f=t.mul(n,r);const a=t.mul(n,o),c=t.mul(n,s),u=t.eql(t.sqr(f),e),h=t.eql(t.sqr(a),e);n=t.cmov(n,f,u),f=t.cmov(c,a,h);const l=t.eql(t.sqr(f),e),d=t.cmov(n,f,l);return w(t,d,e),d}}(n):B(n)),F(H,e);var n}),toBytes:t=>n?(0,r.S5)(t,O):(0,r.tL)(t,O),fromBytes:(e,o=!0)=>{if(v){if(!v.includes(e.length)||e.length>O)throw new Error("Field.fromBytes: expected "+v+" bytes, got "+e.length);const t=new Uint8Array(O);t.set(e,n?0:t.length-e.length),e=t}if(e.length!==O)throw new Error("Field.fromBytes: expected "+O+" bytes, got "+e.length);let s=n?(0,r.ty)(e):(0,r.Hv)(e);if(x&&(s=y(s,t)),!o&&!H.isValid(s))throw new Error("invalid field element: outside of range 0..ORDER");return s},invertBatch:t=>A(H,t),cmov:(t,e,n)=>n?e:t});return Object.freeze(H)}function F(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function H(t){const e=F(t);return e+Math.ceil(e/2)}function L(t,e,n=!1){const o=t.length,s=F(e),f=H(e);if(o<16||o<f||o>1024)throw new Error("expected "+f+"-1024 bytes of input, got "+o);const a=y(n?(0,r.ty)(t):(0,r.Hv)(t),e-i)+i;return n?(0,r.S5)(a,s):(0,r.tL)(a,s)}},128463:(t,e,n)=>{n.d(e,{K:()=>h,o:()=>g});var r=n(687427),o=n(590920),s=n(395814);const i=BigInt(0),f=BigInt(1),a=BigInt(2),c=BigInt(3);function u(t,e,n,r,o=1,s){const i=BigInt(void 0===s?r:s),a=n**BigInt(r),c=[];for(let s=0;s<o;s++){const o=BigInt(s+1),u=[];for(let s=0,c=f;s<r;s++){const r=(o*c-o)/i%a;u.push(t.pow(e,r)),c*=n}c.push(u)}return c}function h(t,e,n){const r=e.pow(n,(t.ORDER-f)/c),o=e.pow(n,(t.ORDER-f)/a);function s(t,n){return[e.mul(e.frobeniusMap(t,1),r),e.mul(e.frobeniusMap(n,1),o)]}const i=e.pow(n,(t.ORDER**a-f)/c),u=e.pow(n,(t.ORDER**a-f)/a);if(!e.eql(u,e.neg(e.ONE)))throw new Error("psiFrobenius: PSI2_Y!==-1");function h(t,n){return[e.mul(t,i),e.neg(n)]}const l=t=>(e,n)=>{const r=n.toAffine(),o=t(r.x,r.y);return e.fromAffine({x:o[0],y:o[1]})};return{psi:s,psi2:h,G2psi:l(s),G2psi2:l(h),PSI_X:r,PSI_Y:o,PSI2_X:i,PSI2_Y:u}}const l=(t,e)=>{if(2!==e.length)throw new Error("invalid tuple");const n=e.map((e=>t.create(e)));return{c0:n[0],c1:n[1]}};class d{constructor(t,e={}){this.MASK=f;const n=t.ORDER,o=n*n;this.Fp=t,this.ORDER=o,this.BITS=(0,r.Dd)(o),this.BYTES=Math.ceil((0,r.Dd)(o)/8),this.isLE=t.isLE,this.ZERO={c0:t.ZERO,c1:t.ZERO},this.ONE={c0:t.ONE,c1:t.ZERO},this.Fp_NONRESIDUE=t.create(e.NONRESIDUE||BigInt(-1)),this.Fp_div2=t.div(t.ONE,a),this.NONRESIDUE=l(t,e.FP2_NONRESIDUE),this.FROBENIUS_COEFFICIENTS=u(t,this.Fp_NONRESIDUE,t.ORDER,2)[0],this.mulByB=e.Fp2mulByB,Object.seal(this)}fromBigTuple(t){return l(this.Fp,t)}create(t){return t}isValid({c0:t,c1:e}){function n(t,e){return"bigint"==typeof t&&i<=t&&t<e}return n(t,this.ORDER)&&n(e,this.ORDER)}is0({c0:t,c1:e}){return this.Fp.is0(t)&&this.Fp.is0(e)}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}eql({c0:t,c1:e},{c0:n,c1:r}){return this.Fp.eql(t,n)&&this.Fp.eql(e,r)}neg({c0:t,c1:e}){return{c0:this.Fp.neg(t),c1:this.Fp.neg(e)}}pow(t,e){return s.Q(this,t,e)}invertBatch(t){return s.Eg(this,t)}add(t,e){const{c0:n,c1:r}=t,{c0:o,c1:s}=e;return{c0:this.Fp.add(n,o),c1:this.Fp.add(r,s)}}sub({c0:t,c1:e},{c0:n,c1:r}){return{c0:this.Fp.sub(t,n),c1:this.Fp.sub(e,r)}}mul({c0:t,c1:e},n){const{Fp:r}=this;if("bigint"==typeof n)return{c0:r.mul(t,n),c1:r.mul(e,n)};const{c0:o,c1:s}=n;let i=r.mul(t,o),f=r.mul(e,s);return{c0:r.sub(i,f),c1:r.sub(r.mul(r.add(t,e),r.add(o,s)),r.add(i,f))}}sqr({c0:t,c1:e}){const{Fp:n}=this,r=n.add(t,e),o=n.sub(t,e),s=n.add(t,t);return{c0:n.mul(r,o),c1:n.mul(s,e)}}addN(t,e){return this.add(t,e)}subN(t,e){return this.sub(t,e)}mulN(t,e){return this.mul(t,e)}sqrN(t){return this.sqr(t)}div(t,e){const{Fp:n}=this;return this.mul(t,"bigint"==typeof e?n.inv(n.create(e)):this.inv(e))}inv({c0:t,c1:e}){const{Fp:n}=this,r=n.inv(n.create(t*t+e*e));return{c0:n.mul(r,n.create(t)),c1:n.mul(r,n.create(-e))}}sqrt(t){const{Fp:e}=this,n=this,{c0:r,c1:o}=t;if(e.is0(o))return 1===s.IN(e,r)?n.create({c0:e.sqrt(r),c1:e.ZERO}):n.create({c0:e.ZERO,c1:e.sqrt(e.div(r,this.Fp_NONRESIDUE))});const i=e.sqrt(e.sub(e.sqr(r),e.mul(e.sqr(o),this.Fp_NONRESIDUE)));let f=e.mul(e.add(i,r),this.Fp_div2);-1===s.IN(e,f)&&(f=e.sub(f,i));const a=e.sqrt(f),c=n.create({c0:a,c1:e.div(e.mul(o,this.Fp_div2),a)});if(!n.eql(n.sqr(c),t))throw new Error("Cannot find square root");const u=c,h=n.neg(u),{re:l,im:d}=n.reim(u),{re:p,im:y}=n.reim(h);return d>y||d===y&&l>p?u:h}isOdd(t){const{re:e,im:n}=this.reim(t);return BigInt(e%a||e===i&&n%a)==f}fromBytes(t){const{Fp:e}=this;if(t.length!==this.BYTES)throw new Error("fromBytes invalid length="+t.length);return{c0:e.fromBytes(t.subarray(0,e.BYTES)),c1:e.fromBytes(t.subarray(e.BYTES))}}toBytes({c0:t,c1:e}){return(0,o.eV)(this.Fp.toBytes(t),this.Fp.toBytes(e))}cmov({c0:t,c1:e},{c0:n,c1:r},o){return{c0:this.Fp.cmov(t,n,o),c1:this.Fp.cmov(e,r,o)}}reim({c0:t,c1:e}){return{re:t,im:e}}Fp4Square(t,e){const n=this,r=n.sqr(t),o=n.sqr(e);return{first:n.add(n.mulByNonresidue(o),r),second:n.sub(n.sub(n.sqr(n.add(t,e)),r),o)}}mulByNonresidue({c0:t,c1:e}){return this.mul({c0:t,c1:e},this.NONRESIDUE)}frobeniusMap({c0:t,c1:e},n){return{c0:t,c1:this.Fp.mul(e,this.FROBENIUS_COEFFICIENTS[n%2])}}}class p{constructor(t){this.MASK=f,this.Fp2=t,this.ORDER=t.ORDER,this.BITS=3*t.BITS,this.BYTES=3*t.BYTES,this.isLE=t.isLE,this.ZERO={c0:t.ZERO,c1:t.ZERO,c2:t.ZERO},this.ONE={c0:t.ONE,c1:t.ZERO,c2:t.ZERO};const{Fp:e}=t,n=u(t,t.NONRESIDUE,e.ORDER,6,2,3);this.FROBENIUS_COEFFICIENTS_1=n[0],this.FROBENIUS_COEFFICIENTS_2=n[1],Object.seal(this)}add({c0:t,c1:e,c2:n},{c0:r,c1:o,c2:s}){const{Fp2:i}=this;return{c0:i.add(t,r),c1:i.add(e,o),c2:i.add(n,s)}}sub({c0:t,c1:e,c2:n},{c0:r,c1:o,c2:s}){const{Fp2:i}=this;return{c0:i.sub(t,r),c1:i.sub(e,o),c2:i.sub(n,s)}}mul({c0:t,c1:e,c2:n},r){const{Fp2:o}=this;if("bigint"==typeof r)return{c0:o.mul(t,r),c1:o.mul(e,r),c2:o.mul(n,r)};const{c0:s,c1:i,c2:f}=r,a=o.mul(t,s),c=o.mul(e,i),u=o.mul(n,f);return{c0:o.add(a,o.mulByNonresidue(o.sub(o.mul(o.add(e,n),o.add(i,f)),o.add(c,u)))),c1:o.add(o.sub(o.mul(o.add(t,e),o.add(s,i)),o.add(a,c)),o.mulByNonresidue(u)),c2:o.sub(o.add(c,o.mul(o.add(t,n),o.add(s,f))),o.add(a,u))}}sqr({c0:t,c1:e,c2:n}){const{Fp2:r}=this;let o=r.sqr(t),s=r.mul(r.mul(t,e),a),i=r.mul(r.mul(e,n),a),f=r.sqr(n);return{c0:r.add(r.mulByNonresidue(i),o),c1:r.add(r.mulByNonresidue(f),s),c2:r.sub(r.sub(r.add(r.add(s,r.sqr(r.add(r.sub(t,e),n))),i),o),f)}}addN(t,e){return this.add(t,e)}subN(t,e){return this.sub(t,e)}mulN(t,e){return this.mul(t,e)}sqrN(t){return this.sqr(t)}create(t){return t}isValid({c0:t,c1:e,c2:n}){const{Fp2:r}=this;return r.isValid(t)&&r.isValid(e)&&r.isValid(n)}is0({c0:t,c1:e,c2:n}){const{Fp2:r}=this;return r.is0(t)&&r.is0(e)&&r.is0(n)}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}neg({c0:t,c1:e,c2:n}){const{Fp2:r}=this;return{c0:r.neg(t),c1:r.neg(e),c2:r.neg(n)}}eql({c0:t,c1:e,c2:n},{c0:r,c1:o,c2:s}){const{Fp2:i}=this;return i.eql(t,r)&&i.eql(e,o)&&i.eql(n,s)}sqrt(t){return(0,r.EQ)()}div(t,e){const{Fp2:n}=this,{Fp:r}=n;return this.mul(t,"bigint"==typeof e?r.inv(r.create(e)):this.inv(e))}pow(t,e){return s.Q(this,t,e)}invertBatch(t){return s.Eg(this,t)}inv({c0:t,c1:e,c2:n}){const{Fp2:r}=this;let o=r.sub(r.sqr(t),r.mulByNonresidue(r.mul(n,e))),s=r.sub(r.mulByNonresidue(r.sqr(n)),r.mul(t,e)),i=r.sub(r.sqr(e),r.mul(t,n)),f=r.inv(r.add(r.mulByNonresidue(r.add(r.mul(n,s),r.mul(e,i))),r.mul(t,o)));return{c0:r.mul(f,o),c1:r.mul(f,s),c2:r.mul(f,i)}}fromBytes(t){const{Fp2:e}=this;if(t.length!==this.BYTES)throw new Error("fromBytes invalid length="+t.length);const n=e.BYTES;return{c0:e.fromBytes(t.subarray(0,n)),c1:e.fromBytes(t.subarray(n,2*n)),c2:e.fromBytes(t.subarray(2*n))}}toBytes({c0:t,c1:e,c2:n}){const{Fp2:r}=this;return(0,o.eV)(r.toBytes(t),r.toBytes(e),r.toBytes(n))}cmov({c0:t,c1:e,c2:n},{c0:r,c1:o,c2:s},i){const{Fp2:f}=this;return{c0:f.cmov(t,r,i),c1:f.cmov(e,o,i),c2:f.cmov(n,s,i)}}fromBigSix(t){const{Fp2:e}=this;if(!Array.isArray(t)||6!==t.length)throw new Error("invalid Fp6 usage");return{c0:e.fromBigTuple(t.slice(0,2)),c1:e.fromBigTuple(t.slice(2,4)),c2:e.fromBigTuple(t.slice(4,6))}}frobeniusMap({c0:t,c1:e,c2:n},r){const{Fp2:o}=this;return{c0:o.frobeniusMap(t,r),c1:o.mul(o.frobeniusMap(e,r),this.FROBENIUS_COEFFICIENTS_1[r%6]),c2:o.mul(o.frobeniusMap(n,r),this.FROBENIUS_COEFFICIENTS_2[r%6])}}mulByFp2({c0:t,c1:e,c2:n},r){const{Fp2:o}=this;return{c0:o.mul(t,r),c1:o.mul(e,r),c2:o.mul(n,r)}}mulByNonresidue({c0:t,c1:e,c2:n}){const{Fp2:r}=this;return{c0:r.mulByNonresidue(n),c1:t,c2:e}}mul1({c0:t,c1:e,c2:n},r){const{Fp2:o}=this;return{c0:o.mulByNonresidue(o.mul(n,r)),c1:o.mul(t,r),c2:o.mul(e,r)}}mul01({c0:t,c1:e,c2:n},r,o){const{Fp2:s}=this;let i=s.mul(t,r),f=s.mul(e,o);return{c0:s.add(s.mulByNonresidue(s.sub(s.mul(s.add(e,n),o),f)),i),c1:s.sub(s.sub(s.mul(s.add(r,o),s.add(t,e)),i),f),c2:s.add(s.sub(s.mul(s.add(t,n),r),i),f)}}}class y{constructor(t,e){this.MASK=f;const{Fp2:n}=t,{Fp:r}=n;this.Fp6=t,this.ORDER=n.ORDER,this.BITS=2*t.BITS,this.BYTES=2*t.BYTES,this.isLE=t.isLE,this.ZERO={c0:t.ZERO,c1:t.ZERO},this.ONE={c0:t.ONE,c1:t.ZERO},this.FROBENIUS_COEFFICIENTS=u(n,n.NONRESIDUE,r.ORDER,12,1,6)[0],this.X_LEN=e.X_LEN,this.finalExponentiate=e.Fp12finalExponentiate}create(t){return t}isValid({c0:t,c1:e}){const{Fp6:n}=this;return n.isValid(t)&&n.isValid(e)}is0({c0:t,c1:e}){const{Fp6:n}=this;return n.is0(t)&&n.is0(e)}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}neg({c0:t,c1:e}){const{Fp6:n}=this;return{c0:n.neg(t),c1:n.neg(e)}}eql({c0:t,c1:e},{c0:n,c1:r}){const{Fp6:o}=this;return o.eql(t,n)&&o.eql(e,r)}sqrt(t){(0,r.EQ)()}inv({c0:t,c1:e}){const{Fp6:n}=this;let r=n.inv(n.sub(n.sqr(t),n.mulByNonresidue(n.sqr(e))));return{c0:n.mul(t,r),c1:n.neg(n.mul(e,r))}}div(t,e){const{Fp6:n}=this,{Fp2:r}=n,{Fp:o}=r;return this.mul(t,"bigint"==typeof e?o.inv(o.create(e)):this.inv(e))}pow(t,e){return s.Q(this,t,e)}invertBatch(t){return s.Eg(this,t)}add({c0:t,c1:e},{c0:n,c1:r}){const{Fp6:o}=this;return{c0:o.add(t,n),c1:o.add(e,r)}}sub({c0:t,c1:e},{c0:n,c1:r}){const{Fp6:o}=this;return{c0:o.sub(t,n),c1:o.sub(e,r)}}mul({c0:t,c1:e},n){const{Fp6:r}=this;if("bigint"==typeof n)return{c0:r.mul(t,n),c1:r.mul(e,n)};let{c0:o,c1:s}=n,i=r.mul(t,o),f=r.mul(e,s);return{c0:r.add(i,r.mulByNonresidue(f)),c1:r.sub(r.mul(r.add(t,e),r.add(o,s)),r.add(i,f))}}sqr({c0:t,c1:e}){const{Fp6:n}=this;let r=n.mul(t,e);return{c0:n.sub(n.sub(n.mul(n.add(n.mulByNonresidue(e),t),n.add(t,e)),r),n.mulByNonresidue(r)),c1:n.add(r,r)}}addN(t,e){return this.add(t,e)}subN(t,e){return this.sub(t,e)}mulN(t,e){return this.mul(t,e)}sqrN(t){return this.sqr(t)}fromBytes(t){const{Fp6:e}=this;if(t.length!==this.BYTES)throw new Error("fromBytes invalid length="+t.length);return{c0:e.fromBytes(t.subarray(0,e.BYTES)),c1:e.fromBytes(t.subarray(e.BYTES))}}toBytes({c0:t,c1:e}){const{Fp6:n}=this;return(0,o.eV)(n.toBytes(t),n.toBytes(e))}cmov({c0:t,c1:e},{c0:n,c1:r},o){const{Fp6:s}=this;return{c0:s.cmov(t,n,o),c1:s.cmov(e,r,o)}}fromBigTwelve(t){const{Fp6:e}=this;return{c0:e.fromBigSix(t.slice(0,6)),c1:e.fromBigSix(t.slice(6,12))}}frobeniusMap(t,e){const{Fp6:n}=this,{Fp2:r}=n,{c0:o,c1:s,c2:i}=n.frobeniusMap(t.c1,e),f=this.FROBENIUS_COEFFICIENTS[e%12];return{c0:n.frobeniusMap(t.c0,e),c1:n.create({c0:r.mul(o,f),c1:r.mul(s,f),c2:r.mul(i,f)})}}mulByFp2({c0:t,c1:e},n){const{Fp6:r}=this;return{c0:r.mulByFp2(t,n),c1:r.mulByFp2(e,n)}}conjugate({c0:t,c1:e}){return{c0:t,c1:this.Fp6.neg(e)}}mul014({c0:t,c1:e},n,r,o){const{Fp6:s}=this,{Fp2:i}=s;let f=s.mul01(t,n,r),a=s.mul1(e,o);return{c0:s.add(s.mulByNonresidue(a),f),c1:s.sub(s.sub(s.mul01(s.add(e,t),n,i.add(r,o)),f),a)}}mul034({c0:t,c1:e},n,r,o){const{Fp6:s}=this,{Fp2:i}=s,f=s.create({c0:i.mul(t.c0,n),c1:i.mul(t.c1,n),c2:i.mul(t.c2,n)}),a=s.mul01(e,r,o),c=s.mul01(s.add(t,e),i.add(n,r),o);return{c0:s.add(s.mulByNonresidue(a),f),c1:s.sub(c,s.add(f,a))}}_cyclotomicSquare({c0:t,c1:e}){const{Fp6:n}=this,{Fp2:r}=n,{c0:o,c1:s,c2:i}=t,{c0:f,c1:c,c2:u}=e,{first:h,second:l}=r.Fp4Square(o,c),{first:d,second:p}=r.Fp4Square(f,i),{first:y,second:g}=r.Fp4Square(s,u),b=r.mulByNonresidue(g);return{c0:n.create({c0:r.add(r.mul(r.sub(h,o),a),h),c1:r.add(r.mul(r.sub(d,s),a),d),c2:r.add(r.mul(r.sub(y,i),a),y)}),c1:n.create({c0:r.add(r.mul(r.add(b,f),a),b),c1:r.add(r.mul(r.add(l,c),a),l),c2:r.add(r.mul(r.add(p,u),a),p)})}}_cyclotomicExp(t,e){let n=this.ONE;for(let o=this.X_LEN-1;o>=0;o--)n=this._cyclotomicSquare(n),(0,r.H_)(e,o)&&(n=this.mul(n,t));return n}}function g(t){const e=s.gN(t.ORDER),n=new d(e,t),r=new p(n);return{Fp:e,Fp2:n,Fp6:r,Fp12:new y(r,t)}}},217271:(t,e,n)=>{n.d(e,{Hv:()=>s});var r=n(590920),o=n(687427);r.gk,r.k8,r.ci,r.Md,r.eV,r.nr,r._t,r.O6,r.iY,o.uw,o.uz,o.ly;const s=o.Hv;o.ty,o.tL,o.S5,o.Yt,o.ql,o.Wd,o.HV,o.QD,o.Z2,o.Fy,o.Dd,o.H_,o.lS,o.dQ,o.n$,o.EQ,o.H9,o.FF,o.lt},789629:(t,e,n)=>{n.d(e,{Nh:()=>w,e4:()=>S,su:()=>v});var r=n(10846),o=n(590920),s=n(687427),i=n(388246),f=n(395814);const a=(t,e)=>(t+(t>=0?e:-e)/y)/e;function c(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function u(t,e){const n={};for(let r of Object.keys(e))n[r]=void 0===t[r]?e[r]:t[r];return(0,s.po)(n.lowS,"lowS"),(0,s.po)(n.prehash,"prehash"),void 0!==n.format&&c(n.format),n}class h extends Error{constructor(t=""){super(t)}}const l={Err:h,_tlv:{encode:(t,e)=>{const{Err:n}=l;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(1&e.length)throw new n("tlv.encode: unpadded data");const r=e.length/2,o=(0,s.uz)(r);if(o.length/2&128)throw new n("tlv.encode: long form length too big");const i=r>127?(0,s.uz)(o.length/2|128):"";return(0,s.uz)(t)+i+o+e},decode(t,e){const{Err:n}=l;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const o=e[r++];let s=0;if(128&o){const t=127&o;if(!t)throw new n("tlv.decode(long): indefinite length not supported");if(t>4)throw new n("tlv.decode(long): byte length is too big");const i=e.subarray(r,r+t);if(i.length!==t)throw new n("tlv.decode: length bytes not complete");if(0===i[0])throw new n("tlv.decode(long): zero leftmost byte");for(const t of i)s=s<<8|t;if(r+=t,s<128)throw new n("tlv.decode(long): not minimal encoding")}else s=o;const i=e.subarray(r,r+s);if(i.length!==s)throw new n("tlv.decode: wrong value length");return{v:i,l:e.subarray(r+s)}}},_int:{encode(t){const{Err:e}=l;if(t<d)throw new e("integer: negative integers are not allowed");let n=(0,s.uz)(t);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new e("unexpected DER parsing assertion: unpadded hex");return n},decode(t){const{Err:e}=l;if(128&t[0])throw new e("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("invalid signature integer: unnecessary leading zero");return(0,s.Hv)(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=l,o=(0,s.ql)("signature",t),{v:i,l:f}=r.decode(48,o);if(f.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=r.decode(2,i),{v:u,l:h}=r.decode(2,c);if(h.length)throw new e("invalid signature: left bytes after parsing");return{r:n.decode(a),s:n.decode(u)}},hexFromSig(t){const{_tlv:e,_int:n}=l,r=e.encode(2,n.encode(t.r))+e.encode(2,n.encode(t.s));return e.encode(48,r)}},d=BigInt(0),p=BigInt(1),y=BigInt(2),g=BigInt(3),b=BigInt(4);function w(t,e){const{BYTES:n}=t;let r;if("bigint"==typeof e)r=e;else{let o=(0,s.ql)("private key",e);try{r=t.fromBytes(o)}catch(t){throw new Error(`invalid private key: expected ui8a of size ${n}, got ${typeof e}`)}}if(!t.isValidNot0(r))throw new Error("invalid private key: out of range [1..N-1]");return r}function m(t,e={}){const n=(0,i.rO)("weierstrass",t,e),{Fp:r,Fn:f}=n;let c=n.CURVE;const{h:u,n:h}=c;(0,s.fA)(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:l}=e;if(l&&(!r.is0(c.a)||"bigint"!=typeof l.beta||!Array.isArray(l.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const y=B(r,f);function m(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}const v=e.toBytes||function(t,e,n){const{x:i,y:f}=e.toAffine(),a=r.toBytes(i);if((0,s.po)(n,"isCompressed"),n){m();const t=!r.isOdd(f);return(0,o.eV)(E(t),a)}return(0,o.eV)(Uint8Array.of(4),a,r.toBytes(f))},x=e.fromBytes||function(t){(0,s.GB)(t,void 0,"Point");const{publicKey:e,publicKeyUncompressed:n}=y,o=t.length,i=t[0],f=t.subarray(1);if(o!==e||2!==i&&3!==i){if(o===n&&4===i){const t=r.BYTES,e=r.fromBytes(f.subarray(0,t)),n=r.fromBytes(f.subarray(t,2*t));if(!I(e,n))throw new Error("bad point: is not on curve");return{x:e,y:n}}throw new Error(`bad point: got length ${o}, expected compressed=${e} or uncompressed=${n}`)}{const t=r.fromBytes(f);if(!r.isValid(t))throw new Error("bad point: is not on curve, wrong x");const e=S(t);let n;try{n=r.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("bad point: is not on curve, sqrt error"+e)}return m(),1==(1&i)!==r.isOdd(n)&&(n=r.neg(n)),{x:t,y:n}}};function S(t){const e=r.sqr(t),n=r.mul(e,t);return r.add(r.add(n,r.mul(t,c.a)),c.b)}function I(t,e){const n=r.sqr(e),o=S(t);return r.eql(n,o)}if(!I(c.Gx,c.Gy))throw new Error("bad curve params: generator point");const A=r.mul(r.pow(c.a,g),b),O=r.mul(r.sqr(c.b),BigInt(27));if(r.is0(r.add(A,O)))throw new Error("bad curve params: a or b");function _(t,e,n=!1){if(!r.isValid(e)||n&&r.is0(e))throw new Error(`bad point coordinate ${t}`);return e}function R(t){if(!(t instanceof N))throw new Error("ProjectivePoint expected")}function F(t){if(!l||!l.basises)throw new Error("no endo");return function(t,e,n){const[[r,o],[i,f]]=e,c=a(f*t,n),u=a(-o*t,n);let h=t-c*r-u*i,l=-c*o-u*f;const y=h<d,g=l<d;y&&(h=-h),g&&(l=-l);const b=(0,s.dQ)(Math.ceil((0,s.Dd)(n)/2))+p;if(h<d||h>=b||l<d||l>=b)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:y,k1:h,k2neg:g,k2:l}}(t,l.basises,f.ORDER)}const H=(0,s.H9)(((t,e)=>{const{X:n,Y:o,Z:s}=t;if(r.eql(s,r.ONE))return{x:n,y:o};const i=t.is0();null==e&&(e=i?r.ONE:r.inv(s));const f=r.mul(n,e),a=r.mul(o,e),c=r.mul(s,e);if(i)return{x:r.ZERO,y:r.ZERO};if(!r.eql(c,r.ONE))throw new Error("invZ was invalid");return{x:f,y:a}})),L=(0,s.H9)((t=>{if(t.is0()){if(e.allowInfinityPoint&&!r.is0(t.Y))return;throw new Error("bad point: ZERO")}const{x:n,y:o}=t.toAffine();if(!r.isValid(n)||!r.isValid(o))throw new Error("bad point: x or y not field elements");if(!I(n,o))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0}));function T(t,e,n,o,s){return n=new N(r.mul(n.X,t),n.Y,n.Z),e=(0,i.xg)(o,e),n=(0,i.xg)(s,n),e.add(n)}class N{constructor(t,e,n){this.X=_("x",t),this.Y=_("y",e,!0),this.Z=_("z",n),Object.freeze(this)}static CURVE(){return c}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof N)throw new Error("projective point not allowed");return r.is0(e)&&r.is0(n)?N.ZERO:new N(e,n,r.ONE)}static fromBytes(t){const e=N.fromAffine(x((0,s.GB)(t,void 0,"point")));return e.assertValidity(),e}static fromHex(t){return N.fromBytes((0,s.ql)("pointHex",t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(t=8,e=!0){return k.createCache(this,t),e||this.multiply(g),this}assertValidity(){L(this)}hasEvenY(){const{y:t}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(t)}equals(t){R(t);const{X:e,Y:n,Z:o}=this,{X:s,Y:i,Z:f}=t,a=r.eql(r.mul(e,f),r.mul(s,o)),c=r.eql(r.mul(n,f),r.mul(i,o));return a&&c}negate(){return new N(this.X,r.neg(this.Y),this.Z)}double(){const{a:t,b:e}=c,n=r.mul(e,g),{X:o,Y:s,Z:i}=this;let f=r.ZERO,a=r.ZERO,u=r.ZERO,h=r.mul(o,o),l=r.mul(s,s),d=r.mul(i,i),p=r.mul(o,s);return p=r.add(p,p),u=r.mul(o,i),u=r.add(u,u),f=r.mul(t,u),a=r.mul(n,d),a=r.add(f,a),f=r.sub(l,a),a=r.add(l,a),a=r.mul(f,a),f=r.mul(p,f),u=r.mul(n,u),d=r.mul(t,d),p=r.sub(h,d),p=r.mul(t,p),p=r.add(p,u),u=r.add(h,h),h=r.add(u,h),h=r.add(h,d),h=r.mul(h,p),a=r.add(a,h),d=r.mul(s,i),d=r.add(d,d),h=r.mul(d,p),f=r.sub(f,h),u=r.mul(d,l),u=r.add(u,u),u=r.add(u,u),new N(f,a,u)}add(t){R(t);const{X:e,Y:n,Z:o}=this,{X:s,Y:i,Z:f}=t;let a=r.ZERO,u=r.ZERO,h=r.ZERO;const l=c.a,d=r.mul(c.b,g);let p=r.mul(e,s),y=r.mul(n,i),b=r.mul(o,f),w=r.add(e,n),m=r.add(s,i);w=r.mul(w,m),m=r.add(p,y),w=r.sub(w,m),m=r.add(e,o);let E=r.add(s,f);return m=r.mul(m,E),E=r.add(p,b),m=r.sub(m,E),E=r.add(n,o),a=r.add(i,f),E=r.mul(E,a),a=r.add(y,b),E=r.sub(E,a),h=r.mul(l,m),a=r.mul(d,b),h=r.add(a,h),a=r.sub(y,h),h=r.add(y,h),u=r.mul(a,h),y=r.add(p,p),y=r.add(y,p),b=r.mul(l,b),m=r.mul(d,m),y=r.add(y,b),b=r.sub(p,b),b=r.mul(l,b),m=r.add(m,b),p=r.mul(y,m),u=r.add(u,p),p=r.mul(E,m),a=r.mul(w,a),a=r.sub(a,p),p=r.mul(w,y),h=r.mul(E,h),h=r.add(h,p),new N(a,u,h)}subtract(t){return this.add(t.negate())}is0(){return this.equals(N.ZERO)}multiply(t){const{endo:n}=e;if(!f.isValidNot0(t))throw new Error("invalid scalar: out of range");let r,o;const s=t=>k.cached(this,t,(t=>(0,i.A1)(N,t)));if(n){const{k1neg:e,k1:i,k2neg:f,k2:a}=F(t),{p:c,f:u}=s(i),{p:h,f:l}=s(a);o=u.add(l),r=T(n.beta,c,h,e,f)}else{const{p:e,f:n}=s(t);r=e,o=n}return(0,i.A1)(N,[r,o])[0]}multiplyUnsafe(t){const{endo:n}=e,r=this;if(!f.isValid(t))throw new Error("invalid scalar: out of range");if(t===d||r.is0())return N.ZERO;if(t===p)return r;if(k.hasCache(this))return this.multiply(t);if(n){const{k1neg:e,k1:o,k2neg:s,k2:f}=F(t),{p1:a,p2:c}=(0,i.N6)(N,r,o,f);return T(n.beta,a,c,e,s)}return k.unsafe(r,t)}multiplyAndAddUnsafe(t,e,n){const r=this.multiplyUnsafe(e).add(t.multiplyUnsafe(n));return r.is0()?void 0:r}toAffine(t){return H(this,t)}isTorsionFree(){const{isTorsionFree:t}=e;return u===p||(t?t(N,this):k.unsafe(this,h).is0())}clearCofactor(){const{clearCofactor:t}=e;return u===p?this:t?t(N,this):this.multiplyUnsafe(u)}isSmallOrder(){return this.multiplyUnsafe(u).is0()}toBytes(t=!0){return(0,s.po)(t,"isCompressed"),this.assertValidity(),v(N,this,t)}toHex(t=!0){return(0,o.ci)(this.toBytes(t))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(t=!0){return this.toBytes(t)}_setWindowSize(t){this.precompute(t)}static normalizeZ(t){return(0,i.A1)(N,t)}static msm(t,e){return(0,i.D1)(N,f,t,e)}static fromPrivateKey(t){return N.BASE.multiply(w(f,t))}}N.BASE=new N(c.Gx,c.Gy,r.ONE),N.ZERO=new N(r.ZERO,r.ONE,r.ZERO),N.Fp=r,N.Fn=f;const U=f.BITS,k=new i.Mx(N,e.endo?Math.ceil(U/2):U);return N.BASE.precompute(8),N}function E(t){return Uint8Array.of(t?2:3)}function B(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function v(t){const{CURVE:e,curveOpts:n}=x(t);return function(t,e){const{Fp:n,Fn:r}=e;const o=function(t,e,n){return function(r){const o=t.sqr(r),s=t.mul(o,r);return t.add(t.add(s,t.mul(r,e)),n)}}(n,t.a,t.b);return Object.assign({},{CURVE:t,Point:e,ProjectivePoint:e,normPrivateKeyToScalar:t=>w(r,t),weierstrassEquation:o,isWithinCurveOrder:function(t){return(0,s.Z2)(t,p,r.ORDER)}})}(t,m(e,n))}function x(t){const e={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},n=t.Fp;let r=t.allowedPrivateKeyLengths?Array.from(new Set(t.allowedPrivateKeyLengths.map((t=>Math.ceil(t/2))))):void 0;return{CURVE:e,curveOpts:{Fp:n,Fn:(0,f.gN)(e.n,{BITS:t.nBitLength,allowedLengths:r,modFromBytes:t.wrapPrivateKey}),allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes}}}function S(t){const{CURVE:e,curveOpts:n,hash:i,ecdsaOpts:a}=function(t){const{CURVE:e,curveOpts:n}=x(t),r={hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN};return{CURVE:e,curveOpts:n,hash:t.hash,ecdsaOpts:r}}(t);return function(t,e){const n=e.Point;return Object.assign({},e,{ProjectivePoint:n,CURVE:Object.assign({},t,(0,f.kK)(n.Fn.ORDER,n.Fn.BITS))})}(t,function(t,e,n={}){(0,o.z3)(e),(0,s.fA)(n,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const i=n.randomBytes||o.O6,a=n.hmac||((t,...n)=>(0,r.b)(e,t,(0,o.eV)(...n))),{Fp:h,Fn:g}=t,{ORDER:b,BITS:m}=g,{keygen:v,getPublicKey:x,getSharedSecret:S,utils:I,lengths:A}=function(t,e={}){const{Fn:n}=t,r=e.randomBytes||o.O6,i=Object.assign(B(t.Fp,n),{seed:(0,f.PS)(n.ORDER)});function a(t){try{return!!w(n,t)}catch(t){return!1}}function c(t=r(i.seed)){return(0,f.Us)((0,s.GB)(t,i.seed,"seed"),n.ORDER)}function u(e,r=!0){return t.BASE.multiply(w(n,e)).toBytes(r)}function h(e){if("bigint"==typeof e)return!1;if(e instanceof t)return!0;const{secretKey:r,publicKey:o,publicKeyUncompressed:f}=i;if(n.allowedLengths||r===o)return;const a=(0,s.ql)("key",e).length;return a===o||a===f}const l={isValidSecretKey:a,isValidPublicKey:function(e,n){const{publicKey:r,publicKeyUncompressed:o}=i;try{const s=e.length;return!(!0===n&&s!==r||!1===n&&s!==o||!t.fromBytes(e))}catch(t){return!1}},randomSecretKey:c,isValidPrivateKey:a,randomPrivateKey:c,normPrivateKeyToScalar:t=>w(n,t),precompute:(e=8,n=t.BASE)=>n.precompute(e,!1)};return Object.freeze({getPublicKey:u,getSharedSecret:function(e,r,o=!0){if(!0===h(e))throw new Error("first arg must be private key");if(!1===h(r))throw new Error("second arg must be public key");const s=w(n,e);return t.fromHex(r).multiply(s).toBytes(o)},keygen:function(t){const e=c(t);return{secretKey:e,publicKey:u(e)}},Point:t,utils:l,lengths:i})}(t,n),O={prehash:!1,lowS:"boolean"==typeof n.lowS&&n.lowS,format:void 0,extraEntropy:!1},_="compact";function R(t){return t>b>>p}function F(t,e){if(!g.isValidNot0(e))throw new Error(`invalid signature ${t}: out of range 1..Point.Fn.ORDER`);return e}class H{constructor(t,e,n){this.r=F("r",t),this.s=F("s",e),null!=n&&(this.recovery=n),Object.freeze(this)}static fromBytes(t,e=_){let n;if(function(t,e){c(e);const n=A.signature,r="compact"===e?n:"recovered"===e?n+1:void 0;(0,s.GB)(t,r,`${e} signature`)}(t,e),"der"===e){const{r:e,s:n}=l.toSig((0,s.GB)(t));return new H(e,n)}"recovered"===e&&(n=t[0],e="compact",t=t.subarray(1));const r=g.BYTES,o=t.subarray(0,r),i=t.subarray(r,2*r);return new H(g.fromBytes(o),g.fromBytes(i),n)}static fromHex(t,e){return this.fromBytes((0,o.nr)(t),e)}addRecoveryBit(t){return new H(this.r,this.s,t)}recoverPublicKey(e){const n=h.ORDER,{r,s:i,recovery:f}=this;if(null==f||![0,1,2,3].includes(f))throw new Error("recovery id invalid");if(b*y<n&&f>1)throw new Error("recovery id is ambiguous for h>1 curve");const a=2===f||3===f?r+b:r;if(!h.isValid(a))throw new Error("recovery id 2 or 3 invalid");const c=h.toBytes(a),u=t.fromBytes((0,o.eV)(E(0==(1&f)),c)),l=g.inv(a),d=T((0,s.ql)("msgHash",e)),p=g.create(-d*l),w=g.create(i*l),m=t.BASE.multiplyUnsafe(p).add(u.multiplyUnsafe(w));if(m.is0())throw new Error("point at infinify");return m.assertValidity(),m}hasHighS(){return R(this.s)}toBytes(t=_){if(c(t),"der"===t)return(0,o.nr)(l.hexFromSig(this));const e=g.toBytes(this.r),n=g.toBytes(this.s);if("recovered"===t){if(null==this.recovery)throw new Error("recovery bit must be present");return(0,o.eV)(Uint8Array.of(this.recovery),e,n)}return(0,o.eV)(e,n)}toHex(t){return(0,o.ci)(this.toBytes(t))}assertValidity(){}static fromCompact(t){return H.fromBytes((0,s.ql)("sig",t),"compact")}static fromDER(t){return H.fromBytes((0,s.ql)("sig",t),"der")}normalizeS(){return this.hasHighS()?new H(this.r,g.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return(0,o.ci)(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return(0,o.ci)(this.toBytes("compact"))}}const L=n.bits2int||function(t){if(t.length>8192)throw new Error("input is too large");const e=(0,s.Hv)(t),n=8*t.length-m;return n>0?e>>BigInt(n):e},T=n.bits2int_modN||function(t){return g.create(L(t))},N=(0,s.dQ)(m);function U(t){return(0,s.Fy)("num < 2^"+m,t,d,N),g.toBytes(t)}function k(t,n){return(0,s.GB)(t,void 0,"message"),n?(0,s.GB)(e(t),void 0,"prehashed message"):t}return Object.freeze({keygen:v,getPublicKey:x,getSharedSecret:S,utils:I,lengths:A,Point:t,sign:function(n,r,f={}){n=(0,s.ql)("message",n);const{seed:c,k2sig:h}=function(e,n,r){if(["recovered","canonical"].some((t=>t in r)))throw new Error("sign() legacy options not supported");const{lowS:f,prehash:a,extraEntropy:c}=u(r,O);e=k(e,a);const h=T(e),l=w(g,n),y=[U(l),U(h)];if(null!=c&&!1!==c){const t=!0===c?i(A.secretKey):c;y.push((0,s.ql)("extraEntropy",t))}const b=(0,o.eV)(...y),m=h;return{seed:b,k2sig:function(e){const n=L(e);if(!g.isValidNot0(n))return;const r=g.inv(n),o=t.BASE.multiply(n).toAffine(),s=g.create(o.x);if(s===d)return;const i=g.create(r*g.create(m+s*l));if(i===d)return;let a=(o.x===s?0:2)|Number(o.y&p),c=i;return f&&R(i)&&(c=g.neg(i),a^=1),new H(s,c,a)}}}(n,r,f);return(0,s.n$)(e.outputLen,g.BYTES,a)(c,h)},verify:function(e,n,r,i={}){const{lowS:f,prehash:a,format:c}=u(i,O);if(r=(0,s.ql)("publicKey",r),n=k((0,s.ql)("message",n),a),"strict"in i)throw new Error("options.strict was renamed to lowS");const h=void 0===c?function(t){let e;const n="string"==typeof t||(0,o._t)(t),r=!n&&null!==t&&"object"==typeof t&&"bigint"==typeof t.r&&"bigint"==typeof t.s;if(!n&&!r)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(r)e=new H(t.r,t.s);else if(n){try{e=H.fromBytes((0,s.ql)("sig",t),"der")}catch(t){if(!(t instanceof l.Err))throw t}if(!e)try{e=H.fromBytes((0,s.ql)("sig",t),"compact")}catch(t){return!1}}return e||!1}(e):H.fromBytes((0,s.ql)("sig",e),c);if(!1===h)return!1;try{const e=t.fromBytes(r);if(f&&h.hasHighS())return!1;const{r:o,s}=h,i=T(n),a=g.inv(s),c=g.create(i*a),u=g.create(o*a),l=t.BASE.multiplyUnsafe(c).add(e.multiplyUnsafe(u));return!l.is0()&&g.create(l.x)===o}catch(t){return!1}},recoverPublicKey:function(t,e,n={}){const{prehash:r}=u(n,O);return e=k(e,r),H.fromBytes(t,"recovered").recoverPublicKey(e).toBytes()},Signature:H,hash:e})}(m(e,n),i,a))}},517599:(t,e,n)=>{n.d(e,{bn254:()=>_});var r=n(397049),o=n(505849),s=n(395814),i=n(128463),f=n(789629),a=n(687427);const c=BigInt(0),u=BigInt(1),h=BigInt(2),l=BigInt(3),d=BigInt(6),p=BigInt("4965661367192848881"),y=(0,a.Dd)(p),g=d*p**h,b={p:BigInt("0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47"),n:BigInt("0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001"),h:u,a:c,b:l,Gx:u,Gy:BigInt(2)},w=(0,s.gN)(b.n),m={c0:BigInt("19485874751759354771024239261021720505790618469301721065564631296452457478373"),c1:BigInt("266929791119991161246907387137283842545076965332900288569378510910307636690")},{Fp:E,Fp2:B,Fp6:v,Fp12:x}=(0,i.o)({ORDER:b.p,X_LEN:y,FP2_NONRESIDUE:[BigInt(9),u],Fp2mulByB:t=>B.mul(t,m),Fp12finalExponentiate:t=>{const e=t=>x.conjugate(x._cyclotomicExp(t,p)),n=x.mul(x.conjugate(t),x.inv(t)),r=x.mul(x.frobeniusMap(n,2),n),o=x._cyclotomicSquare(e(r)),s=x.mul(x._cyclotomicSquare(o),o),i=e(s),f=e(x._cyclotomicSquare(i)),a=x.mul(x.mul(x.conjugate(f),i),x.conjugate(s)),c=x.mul(a,o);return x.mul(x.frobeniusMap(x.mul(x.conjugate(r),c),3),x.mul(x.frobeniusMap(a,2),x.mul(x.frobeniusMap(c,1),x.mul(x.mul(a,i),r))))}}),{G2psi:S,psi:I}=(0,i.K)(E,B,B.NONRESIDUE),A=Object.freeze({DST:"BN254G2_XMD:SHA-256_SVDW_RO_",encodeDST:"BN254G2_XMD:SHA-256_SVDW_RO_",p:E.ORDER,m:2,k:128,expand:"xmd",hash:r.JQ}),O={p:B.ORDER,n:b.n,h:BigInt("0x30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d"),a:B.ZERO,b:m,Gx:B.fromBigTuple([BigInt("10857046999023057135944570762232829481370756359578518086990519993285655852781"),BigInt("11559732032986387107991004021392285783925812861821192530917403151452391805634")]),Gy:B.fromBigTuple([BigInt("8495653923123431417604973247489272438418190587263600148770280649306958101930"),BigInt("4082367875863433681332203403145435568316851327593401208105741076214120093531")])},_=(0,o.h)({fields:{Fp:E,Fp2:B,Fp6:v,Fp12:x,Fr:w},G1:{...b,Fp:E,htfDefaults:{...A,m:1,DST:"BN254G2_XMD:SHA-256_SVDW_RO_"},wrapPrivateKey:!0,allowInfinityPoint:!0,mapToCurve:a.EQ,fromBytes:a.EQ,toBytes:a.EQ,ShortSignature:{fromBytes:a.EQ,fromHex:a.EQ,toBytes:a.EQ,toRawBytes:a.EQ,toHex:a.EQ}},G2:{...O,Fp:B,hEff:BigInt("21888242871839275222246405745257275088844257914179612981679871602714643921549"),htfDefaults:{...A},wrapPrivateKey:!0,allowInfinityPoint:!0,isTorsionFree:(t,e)=>e.multiplyUnsafe(g).equals(S(t,e)),mapToCurve:a.EQ,fromBytes:a.EQ,toBytes:a.EQ,Signature:{fromBytes:a.EQ,fromHex:a.EQ,toBytes:a.EQ,toRawBytes:a.EQ,toHex:a.EQ}},params:{ateLoopSize:p*d+h,r:w.ORDER,xNegative:!1,twistType:"divisive"},htfDefaults:A,hash:r.JQ,postPrecompute:(t,e,n,r,o,s)=>{const i=I(r,o);({Rx:t,Ry:e,Rz:n}=s(t,e,n,i[0],i[1]));const f=I(i[0],i[1]);s(t,e,n,f[0],B.neg(f[1]))}});(0,f.e4)({a:BigInt(0),b:BigInt(3),Fp:E,n:BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617"),Gx:BigInt(1),Gy:BigInt(2),h:BigInt(1),hash:r.JQ})},117780:(t,e,n)=>{n.d(e,{UN:()=>v});var r=n(397049),o=n(590920),s=n(388246),i=n(124716),f=(n(164197),n(395814)),a=n(687427);const c=BigInt(0),u=BigInt(1),h=BigInt(2),l=(BigInt(3),BigInt(5)),d=BigInt(8),p=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),y=(()=>({p,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:d,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")}))();function g(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}const b=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function w(t,e){const n=p,r=(0,f.wQ)(e*e*e,n),o=function(t){const e=BigInt(10),n=BigInt(20),r=BigInt(40),o=BigInt(80),s=p,i=t*t%s*t%s,a=(0,f.oA)(i,h,s)*i%s,c=(0,f.oA)(a,u,s)*t%s,d=(0,f.oA)(c,l,s)*c%s,y=(0,f.oA)(d,e,s)*d%s,g=(0,f.oA)(y,n,s)*y%s,b=(0,f.oA)(g,r,s)*g%s,w=(0,f.oA)(b,o,s)*b%s,m=(0,f.oA)(w,o,s)*b%s,E=(0,f.oA)(m,e,s)*d%s;return{pow_p_5_8:(0,f.oA)(E,h,s)*t%s,b2:i}}(t*(0,f.wQ)(r*r*e,n)).pow_p_5_8;let s=(0,f.wQ)(t*r*o,n);const i=(0,f.wQ)(e*s*s,n),a=s,c=(0,f.wQ)(s*b,n),d=i===t,y=i===(0,f.wQ)(-t,n),g=i===(0,f.wQ)(-t*b,n);return d&&(s=a),(y||g)&&(s=c),(0,f.Tu)(s,n)&&(s=(0,f.wQ)(-s,n)),{isValid:d||y,value:s}}const m=(()=>(0,f.gN)(y.p,{isLE:!0}))(),E=(()=>(0,f.gN)(y.n,{isLE:!0}))(),B=(()=>({...y,Fp:m,hash:r.o,adjustScalarBytes:g,uvRatio:w}))(),v=(()=>(0,i.eT)(B))(),x=b,S=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),I=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),A=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),O=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),_=t=>w(u,t),R=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),F=t=>v.Point.Fp.create((0,a.ty)(t)&R);function H(t){const{d:e}=y,n=p,r=t=>m.create(t),o=r(x*t*t),s=r((o+u)*A);let i=BigInt(-1);const a=r((i-e*o)*r(o+e));let{isValid:c,value:h}=w(s,a),l=r(h*t);(0,f.Tu)(l,n)||(l=r(-l)),c||(h=l),c||(i=o);const d=r(i*(o-u)*O-a),g=h*h,b=r((h+h)*a),E=r(d*S),B=r(u-g),I=r(u+g);return new v.Point(r(b*I),r(B*E),r(E*I),r(b*B))}class L extends i.gE{constructor(t){super(t)}static fromAffine(t){return new L(v.Point.fromAffine(t))}assertSame(t){if(!(t instanceof L))throw new Error("RistrettoPoint expected")}init(t){return new L(t)}static hashToCurve(t){return function(t){(0,o.gk)(t,64);const e=H(F(t.subarray(0,32))),n=H(F(t.subarray(32,64)));return new L(e.add(n))}((0,a.ql)("ristrettoHash",t,64))}static fromBytes(t){(0,o.gk)(t,32);const{a:e,d:n}=y,r=p,s=t=>m.create(t),i=F(t);if(!(0,a.Wd)(m.toBytes(i),t)||(0,f.Tu)(i,r))throw new Error("invalid ristretto255 encoding 1");const h=s(i*i),l=s(u+e*h),d=s(u-e*h),g=s(l*l),b=s(d*d),w=s(e*n*g-b),{isValid:E,value:B}=_(s(w*b)),x=s(B*d),S=s(B*x*w);let I=s((i+i)*x);(0,f.Tu)(I,r)&&(I=s(-I));const A=s(l*S),O=s(I*A);if(!E||(0,f.Tu)(O,r)||A===c)throw new Error("invalid ristretto255 encoding 2");return new L(new v.Point(I,A,u,O))}static fromHex(t){return L.fromBytes((0,a.ql)("ristrettoHex",t,32))}static msm(t,e){return(0,s.D1)(L,v.Point.Fn,t,e)}toBytes(){let{X:t,Y:e,Z:n,T:r}=this.ep;const o=p,s=t=>m.create(t),i=s(s(n+e)*s(n-e)),a=s(t*e),c=s(a*a),{value:u}=_(s(i*c)),h=s(u*i),l=s(u*a),d=s(h*l*r);let y;if((0,f.Tu)(r*d,o)){let n=s(e*x),r=s(t*x);t=n,e=r,y=s(h*I)}else y=l;(0,f.Tu)(t*d,o)&&(e=s(-e));let g=s((n-e)*y);return(0,f.Tu)(g,o)&&(g=s(-g)),m.toBytes(g)}equals(t){this.assertSame(t);const{X:e,Y:n}=this.ep,{X:r,Y:o}=t.ep,s=t=>m.create(t),i=s(e*o)===s(n*r),f=s(n*o)===s(e*r);return i||f}is0(){return this.equals(L.ZERO)}}L.BASE=(()=>new L(v.Point.BASE))(),L.ZERO=(()=>new L(v.Point.ZERO))(),L.Fp=(()=>m)(),L.Fn=(()=>E)()},425959:(t,e,n)=>{n.d(e,{kA:()=>u});var r=n(397049),o=n(386464),s=n(395814);const i={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},f={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},a=BigInt(2),c=(0,s.gN)(i.p,{sqrt:function(t){const e=i.p,n=BigInt(3),r=BigInt(6),o=BigInt(11),f=BigInt(22),u=BigInt(23),h=BigInt(44),l=BigInt(88),d=t*t*t%e,p=d*d*t%e,y=(0,s.oA)(p,n,e)*p%e,g=(0,s.oA)(y,n,e)*p%e,b=(0,s.oA)(g,a,e)*d%e,w=(0,s.oA)(b,o,e)*b%e,m=(0,s.oA)(w,f,e)*w%e,E=(0,s.oA)(m,h,e)*m%e,B=(0,s.oA)(E,l,e)*E%e,v=(0,s.oA)(B,h,e)*m%e,x=(0,s.oA)(v,n,e)*p%e,S=(0,s.oA)(x,u,e)*w%e,I=(0,s.oA)(S,r,e)*d%e,A=(0,s.oA)(I,a,e);if(!c.eql(c.sqr(A),t))throw new Error("Cannot find square root");return A}}),u=(0,o._)({...i,Fp:c,lowS:!0,endo:f},r.JQ)},687427:(t,e,n)=>{n.d(e,{Dd:()=>x,EQ:()=>L,FF:()=>R,Fy:()=>v,GB:()=>a,H9:()=>T,HV:()=>w,H_:()=>S,Hv:()=>h,QD:()=>m,S5:()=>p,Wd:()=>b,Yt:()=>y,Z2:()=>B,dQ:()=>A,fA:()=>H,lS:()=>I,lt:()=>F,ly:()=>u,n$:()=>O,po:()=>f,ql:()=>g,tL:()=>d,ty:()=>l,uw:()=>i,uz:()=>c});var r=n(590920);const o=BigInt(0),s=BigInt(1);function i(t,e){if("boolean"!=typeof e)throw new Error(t+" boolean expected, got "+e)}function f(t,e=""){if("boolean"!=typeof t)throw new Error((e&&`"${e}"`)+"expected boolean, got type="+typeof t);return t}function a(t,e,n=""){const o=(0,r._t)(t),s=t?.length,i=void 0!==e;if(!o||i&&s!==e)throw new Error((n&&`"${n}" `)+"expected Uint8Array"+(i?` of length ${e}`:"")+", got "+(o?`length=${s}`:"type="+typeof t));return t}function c(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function u(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?o:BigInt("0x"+t)}function h(t){return u((0,r.ci)(t))}function l(t){return(0,r.gk)(t),u((0,r.ci)(Uint8Array.from(t).reverse()))}function d(t,e){return(0,r.nr)(t.toString(16).padStart(2*e,"0"))}function p(t,e){return d(t,e).reverse()}function y(t){return(0,r.nr)(c(t))}function g(t,e,n){let o;if("string"==typeof e)try{o=(0,r.nr)(e)}catch(e){throw new Error(t+" must be hex string or Uint8Array, cause: "+e)}else{if(!(0,r._t)(e))throw new Error(t+" must be hex string or Uint8Array");o=Uint8Array.from(e)}const s=o.length;if("number"==typeof n&&s!==n)throw new Error(t+" of length "+n+" expected, got "+s);return o}function b(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return 0===n}function w(t){return Uint8Array.from(t)}function m(t){return Uint8Array.from(t,((e,n)=>{const r=e.charCodeAt(0);if(1!==e.length||r>127)throw new Error(`string contains non-ASCII character "${t[n]}" with code ${r} at position ${n}`);return r}))}const E=t=>"bigint"==typeof t&&o<=t;function B(t,e,n){return E(t)&&E(e)&&E(n)&&e<=t&&t<n}function v(t,e,n,r){if(!B(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}function x(t){let e;for(e=0;t>o;t>>=s,e+=1);return e}function S(t,e){return t>>BigInt(e)&s}function I(t,e,n){return t|(n?s:o)<<BigInt(e)}const A=t=>(s<<BigInt(t))-s;function O(t,e,n){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");const o=t=>new Uint8Array(t),s=t=>Uint8Array.of(t);let i=o(t),f=o(t),a=0;const c=()=>{i.fill(1),f.fill(0),a=0},u=(...t)=>n(f,i,...t),h=(t=o(0))=>{f=u(s(0),t),i=u(),0!==t.length&&(f=u(s(1),t),i=u())},l=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const n=[];for(;t<e;){i=u();const e=i.slice();n.push(e),t+=i.length}return(0,r.eV)(...n)};return(t,e)=>{let n;for(c(),h(t);!(n=e(l()));)h();return c(),n}}const _={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||(0,r._t)(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function R(t,e,n={}){const r=(e,n,r)=>{const o=_[n];if("function"!=typeof o)throw new Error("invalid validator function");const s=t[e];if(!(r&&void 0===s||o(s,t)))throw new Error("param "+String(e)+" is invalid. Expected "+n+", got "+s)};for(const[t,n]of Object.entries(e))r(t,n,!1);for(const[t,e]of Object.entries(n))r(t,e,!0);return t}function F(t){return"function"==typeof t&&Number.isSafeInteger(t.outputLen)}function H(t,e,n={}){if(!t||"object"!=typeof t)throw new Error("expected valid options object");function r(e,n,r){const o=t[e];if(r&&void 0===o)return;const s=typeof o;if(s!==n||null===o)throw new Error(`param "${e}" is invalid: expected ${n}, got ${s}`)}Object.entries(e).forEach((([t,e])=>r(t,e,!1))),Object.entries(n).forEach((([t,e])=>r(t,e,!0)))}const L=()=>{throw new Error("not implemented")};function T(t){const e=new WeakMap;return(n,...r)=>{const o=e.get(n);if(void 0!==o)return o;const s=t(n,...r);return e.set(n,s),s}}},260547:(t,e,n)=>{n.d(e,{Cu:()=>r});const r=Uint8Array.from([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9,12,5,1,15,14,13,4,10,0,7,6,3,9,2,8,11,13,11,7,14,12,1,3,9,5,0,15,4,8,6,2,10,6,15,14,9,11,3,0,8,12,2,13,7,1,4,10,5,10,2,8,4,7,6,1,5,15,11,9,14,3,12,13,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9])},480264:(t,e,n)=>{n.d(e,{VR:()=>i,bc:()=>o,l3:()=>s,pw:()=>a,r$:()=>f});var r=n(590920);function o(t,e,n){return t&e^~t&n}function s(t,e,n){return t&e^t&n^e&n}class i extends r.kb{constructor(t,e,n,o){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=o,this.buffer=new Uint8Array(t),this.view=(0,r.GL)(this.buffer)}update(t){(0,r.$h)(this),t=(0,r.O0)(t),(0,r.gk)(t);const{view:e,buffer:n,blockLen:o}=this,s=t.length;for(let i=0;i<s;){const f=Math.min(o-this.pos,s-i);if(f!==o)n.set(t.subarray(i,i+f),this.pos),this.pos+=f,i+=f,this.pos===o&&(this.process(e,0),this.pos=0);else{const e=(0,r.GL)(t);for(;o<=s-i;i+=o)this.process(e,i)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){(0,r.$h)(this),(0,r.eB)(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:o,isLE:s}=this;let{pos:i}=this;e[i++]=128,(0,r.ru)(this.buffer.subarray(i)),this.padOffset>o-i&&(this.process(n,0),i=0);for(let t=i;t<o;t++)e[t]=0;!function(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),i=Number(n>>o&s),f=Number(n&s),a=r?4:0,c=r?0:4;t.setUint32(e+a,i,r),t.setUint32(e+c,f,r)}(n,o-8,BigInt(8*this.length),s),this.process(n,0);const f=(0,r.GL)(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,u=this.get();if(c>u.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<c;t++)f.setUint32(4*t,u[t],s)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:o,destroyed:s,pos:i}=this;return t.destroyed=s,t.finished=o,t.length=r,t.pos=i,r%e&&t.buffer.set(n),t}clone(){return this._cloneInto()}}const f=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),a=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209])},796541:(t,e,n)=>{n.d(e,{$m:()=>d,$p:()=>l,EP:()=>y,Ev:()=>s,FL:()=>h,Fn:()=>B,IH:()=>m,Iq:()=>a,NI:()=>f,Ou:()=>u,SD:()=>b,Vl:()=>i,Xb:()=>v,ac:()=>E,gm:()=>g,j:()=>p,m_:()=>c,mk:()=>w,pp:()=>I,u8:()=>x,zP:()=>S});const r=BigInt(2**32-1),o=BigInt(32);function s(t,e=!1){return e?{h:Number(t&r),l:Number(t>>o&r)}:{h:0|Number(t>>o&r),l:0|Number(t&r)}}function i(t,e=!1){const n=t.length;let r=new Uint32Array(n),o=new Uint32Array(n);for(let i=0;i<n;i++){const{h:n,l:f}=s(t[i],e);[r[i],o[i]]=[n,f]}return[r,o]}const f=(t,e,n)=>t>>>n,a=(t,e,n)=>t<<32-n|e>>>n,c=(t,e,n)=>t>>>n|e<<32-n,u=(t,e,n)=>t<<32-n|e>>>n,h=(t,e,n)=>t<<64-n|e>>>n-32,l=(t,e,n)=>t>>>n-32|e<<64-n,d=(t,e)=>e,p=(t,e)=>t,y=(t,e,n)=>t<<n|e>>>32-n,g=(t,e,n)=>e<<n|t>>>32-n,b=(t,e,n)=>e<<n-32|t>>>64-n,w=(t,e,n)=>t<<n-32|e>>>64-n;function m(t,e,n,r){const o=(e>>>0)+(r>>>0);return{h:t+n+(o/2**32|0)|0,l:0|o}}const E=(t,e,n)=>(t>>>0)+(e>>>0)+(n>>>0),B=(t,e,n,r)=>e+n+r+(t/2**32|0)|0,v=(t,e,n,r)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0),x=(t,e,n,r,o)=>e+n+r+o+(t/2**32|0)|0,S=(t,e,n,r,o)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0)+(o>>>0),I=(t,e,n,r,o,s)=>e+n+r+o+s+(t/2**32|0)|0},600749:(t,e,n)=>{n.d(e,{Rg:()=>l});var r=n(260547),o=n(796541),s=n(590920);const i=Uint32Array.from([4089235720,1779033703,2227873595,3144134277,4271175723,1013904242,1595750129,2773480762,2917565137,1359893119,725511199,2600822924,4215389547,528734635,327033209,1541459225]),f=new Uint32Array(32);function a(t,e,n,r,s,i){const a=s[i],c=s[i+1];let u=f[2*t],h=f[2*t+1],l=f[2*e],d=f[2*e+1],p=f[2*n],y=f[2*n+1],g=f[2*r],b=f[2*r+1],w=o.ac(u,l,a);h=o.Fn(w,h,d,c),u=0|w,({Dh:b,Dl:g}={Dh:b^h,Dl:g^u}),({Dh:b,Dl:g}={Dh:o.$m(b,g),Dl:o.j(b,g)}),({h:y,l:p}=o.IH(y,p,b,g)),({Bh:d,Bl:l}={Bh:d^y,Bl:l^p}),({Bh:d,Bl:l}={Bh:o.m_(d,l,24),Bl:o.Ou(d,l,24)}),f[2*t]=u,f[2*t+1]=h,f[2*e]=l,f[2*e+1]=d,f[2*n]=p,f[2*n+1]=y,f[2*r]=g,f[2*r+1]=b}function c(t,e,n,r,s,i){const a=s[i],c=s[i+1];let u=f[2*t],h=f[2*t+1],l=f[2*e],d=f[2*e+1],p=f[2*n],y=f[2*n+1],g=f[2*r],b=f[2*r+1],w=o.ac(u,l,a);h=o.Fn(w,h,d,c),u=0|w,({Dh:b,Dl:g}={Dh:b^h,Dl:g^u}),({Dh:b,Dl:g}={Dh:o.m_(b,g,16),Dl:o.Ou(b,g,16)}),({h:y,l:p}=o.IH(y,p,b,g)),({Bh:d,Bl:l}={Bh:d^y,Bl:l^p}),({Bh:d,Bl:l}={Bh:o.FL(d,l,63),Bl:o.$p(d,l,63)}),f[2*t]=u,f[2*t+1]=h,f[2*e]=l,f[2*e+1]=d,f[2*n]=p,f[2*n+1]=y,f[2*r]=g,f[2*r+1]=b}class u extends s.kb{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,this.length=0,this.pos=0,(0,s.k8)(t),(0,s.k8)(e),this.blockLen=t,this.outputLen=e,this.buffer=new Uint8Array(t),this.buffer32=(0,s.Jq)(this.buffer)}update(t){(0,s.$h)(this),t=(0,s.O0)(t),(0,s.gk)(t);const{blockLen:e,buffer:n,buffer32:r}=this,o=t.length,i=t.byteOffset,f=t.buffer;for(let a=0;a<o;){this.pos===e&&((0,s.Ux)(r),this.compress(r,0,!1),(0,s.Ux)(r),this.pos=0);const c=Math.min(e-this.pos,o-a),u=i+a;if(c!==e||u%4||!(a+c<o))n.set(t.subarray(a,a+c),this.pos),this.pos+=c,this.length+=c,a+=c;else{const t=new Uint32Array(f,u,Math.floor((o-a)/4));(0,s.Ux)(t);for(let n=0;a+e<o;n+=r.length,a+=e)this.length+=e,this.compress(t,n,!1);(0,s.Ux)(t)}}return this}digestInto(t){(0,s.$h)(this),(0,s.eB)(t,this);const{pos:e,buffer32:n}=this;this.finished=!0,(0,s.ru)(this.buffer.subarray(e)),(0,s.Ux)(n),this.compress(n,0,!0),(0,s.Ux)(n);const r=(0,s.Jq)(t);this.get().forEach(((t,e)=>r[e]=(0,s.N$)(t)))}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){const{buffer:e,length:n,finished:r,destroyed:o,outputLen:s,pos:i}=this;return t||(t=new this.constructor({dkLen:s})),t.set(...this.get()),t.buffer.set(e),t.destroyed=o,t.finished=r,t.length=n,t.pos=i,t.outputLen=s,t}clone(){return this._cloneInto()}}class h extends u{constructor(t={}){const e=void 0===t.dkLen?64:t.dkLen;super(128,e),this.v0l=0|i[0],this.v0h=0|i[1],this.v1l=0|i[2],this.v1h=0|i[3],this.v2l=0|i[4],this.v2h=0|i[5],this.v3l=0|i[6],this.v3h=0|i[7],this.v4l=0|i[8],this.v4h=0|i[9],this.v5l=0|i[10],this.v5h=0|i[11],this.v6l=0|i[12],this.v6h=0|i[13],this.v7l=0|i[14],this.v7h=0|i[15],function(t,e={},n,r,o){if((0,s.k8)(n),t<0||t>n)throw new Error("outputLen bigger than keyLen");const{key:i,salt:f,personalization:a}=e;if(void 0!==i&&(i.length<1||i.length>n))throw new Error("key length must be undefined or 1.."+n);if(void 0!==f&&f.length!==r)throw new Error("salt must be undefined or "+r);if(void 0!==a&&a.length!==o)throw new Error("personalization must be undefined or "+o)}(e,t,64,16,16);let{key:n,personalization:r,salt:o}=t,f=0;if(void 0!==n&&(n=(0,s.O0)(n),f=n.length),this.v0l^=this.outputLen|f<<8|65536|1<<24,void 0!==o){o=(0,s.O0)(o);const t=(0,s.Jq)(o);this.v4l^=(0,s.N$)(t[0]),this.v4h^=(0,s.N$)(t[1]),this.v5l^=(0,s.N$)(t[2]),this.v5h^=(0,s.N$)(t[3])}if(void 0!==r){r=(0,s.O0)(r);const t=(0,s.Jq)(r);this.v6l^=(0,s.N$)(t[0]),this.v6h^=(0,s.N$)(t[1]),this.v7l^=(0,s.N$)(t[2]),this.v7h^=(0,s.N$)(t[3])}if(void 0!==n){const t=new Uint8Array(this.blockLen);t.set(n),this.update(t)}}get(){let{v0l:t,v0h:e,v1l:n,v1h:r,v2l:o,v2h:s,v3l:i,v3h:f,v4l:a,v4h:c,v5l:u,v5h:h,v6l:l,v6h:d,v7l:p,v7h:y}=this;return[t,e,n,r,o,s,i,f,a,c,u,h,l,d,p,y]}set(t,e,n,r,o,s,i,f,a,c,u,h,l,d,p,y){this.v0l=0|t,this.v0h=0|e,this.v1l=0|n,this.v1h=0|r,this.v2l=0|o,this.v2h=0|s,this.v3l=0|i,this.v3h=0|f,this.v4l=0|a,this.v4h=0|c,this.v5l=0|u,this.v5h=0|h,this.v6l=0|l,this.v6h=0|d,this.v7l=0|p,this.v7h=0|y}compress(t,e,n){this.get().forEach(((t,e)=>f[e]=t)),f.set(i,16);let{h:u,l:h}=o.Ev(BigInt(this.length));f[24]=i[8]^h,f[25]=i[9]^u,n&&(f[28]=~f[28],f[29]=~f[29]);let l=0;const d=r.Cu;for(let n=0;n<12;n++)a(0,4,8,12,t,e+2*d[l++]),c(0,4,8,12,t,e+2*d[l++]),a(1,5,9,13,t,e+2*d[l++]),c(1,5,9,13,t,e+2*d[l++]),a(2,6,10,14,t,e+2*d[l++]),c(2,6,10,14,t,e+2*d[l++]),a(3,7,11,15,t,e+2*d[l++]),c(3,7,11,15,t,e+2*d[l++]),a(0,5,10,15,t,e+2*d[l++]),c(0,5,10,15,t,e+2*d[l++]),a(1,6,11,12,t,e+2*d[l++]),c(1,6,11,12,t,e+2*d[l++]),a(2,7,8,13,t,e+2*d[l++]),c(2,7,8,13,t,e+2*d[l++]),a(3,4,9,14,t,e+2*d[l++]),c(3,4,9,14,t,e+2*d[l++]);this.v0l^=f[0]^f[16],this.v0h^=f[1]^f[17],this.v1l^=f[2]^f[18],this.v1h^=f[3]^f[19],this.v2l^=f[4]^f[20],this.v2h^=f[5]^f[21],this.v3l^=f[6]^f[22],this.v3h^=f[7]^f[23],this.v4l^=f[8]^f[24],this.v4h^=f[9]^f[25],this.v5l^=f[10]^f[26],this.v5h^=f[11]^f[27],this.v6l^=f[12]^f[28],this.v6h^=f[13]^f[29],this.v7l^=f[14]^f[30],this.v7h^=f[15]^f[31],(0,s.ru)(f)}destroy(){this.destroyed=!0,(0,s.ru)(this.buffer32),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const l=(0,s.WV)((t=>new h(t)))},546275:(t,e,n)=>{n.d(e,{R:()=>r});const r=n(600749).Rg},108067:(t,e,n)=>{n.d(e,{e:()=>r});const r="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},10846:(t,e,n)=>{n.d(e,{b:()=>s});var r=n(590920);class o extends r.kb{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,(0,r.z3)(t);const n=(0,r.O0)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(n.length>o?t.create().update(n).digest():n);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),(0,r.ru)(s)}update(t){return(0,r.$h)(this),this.iHash.update(t),this}digestInto(t){(0,r.$h)(this),(0,r.gk)(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:o,blockLen:s,outputLen:i}=this;return t.finished=r,t.destroyed=o,t.blockLen=s,t.outputLen=i,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const s=(t,e,n)=>new o(t,e).update(n).digest();s.create=(t,e)=>new o(t,e)},8952:(t,e,n)=>{n.d(e,{bP:()=>m});var r=n(480264),o=n(590920);const s=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),i=(()=>Uint8Array.from(new Array(16).fill(0).map(((t,e)=>e))))(),f=(()=>i.map((t=>(9*t+5)%16)))(),a=(()=>{const t=[[i],[f]];for(let e=0;e<4;e++)for(let n of t)n.push(n[e].map((t=>s[t])));return t})(),c=(()=>a[0])(),u=(()=>a[1])(),h=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((t=>Uint8Array.from(t))),l=c.map(((t,e)=>t.map((t=>h[e][t])))),d=u.map(((t,e)=>t.map((t=>h[e][t])))),p=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),y=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function g(t,e,n,r){return 0===t?e^n^r:1===t?e&n|~e&r:2===t?(e|~n)^r:3===t?e&r|n&~r:e^(n|~r)}const b=new Uint32Array(16);class w extends r.VR{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:n,h3:r,h4:o}=this;return[t,e,n,r,o]}set(t,e,n,r,o){this.h0=0|t,this.h1=0|e,this.h2=0|n,this.h3=0|r,this.h4=0|o}process(t,e){for(let n=0;n<16;n++,e+=4)b[n]=t.getUint32(e,!0);let n=0|this.h0,r=n,s=0|this.h1,i=s,f=0|this.h2,a=f,h=0|this.h3,w=h,m=0|this.h4,E=m;for(let t=0;t<5;t++){const e=4-t,B=p[t],v=y[t],x=c[t],S=u[t],I=l[t],A=d[t];for(let e=0;e<16;e++){const r=(0,o.XG)(n+g(t,s,f,h)+b[x[e]]+B,I[e])+m|0;n=m,m=h,h=0|(0,o.XG)(f,10),f=s,s=r}for(let t=0;t<16;t++){const n=(0,o.XG)(r+g(e,i,a,w)+b[S[t]]+v,A[t])+E|0;r=E,E=w,w=0|(0,o.XG)(a,10),a=i,i=n}}this.set(this.h1+f+w|0,this.h2+h+E|0,this.h3+m+r|0,this.h4+n+i|0,this.h0+s+a|0)}roundClean(){(0,o.ru)(b)}destroy(){this.destroyed=!0,(0,o.ru)(this.buffer),this.set(0,0,0,0,0)}}const m=(0,o.V1)((()=>new w))},607537:(t,e,n)=>{n.d(e,{n:()=>s});var r=n(10846),o=n(590920);function s(t,e,n,s){const{c:i,dkLen:f,DK:a,PRF:c,PRFSalt:u}=function(t,e,n,s){(0,o.z3)(t);const i=(0,o.U5)({dkLen:32,asyncTick:10},s),{c:f,dkLen:a,asyncTick:c}=i;if((0,o.k8)(f),(0,o.k8)(a),(0,o.k8)(c),f<1)throw new Error("iterations (c) should be >= 1");const u=(0,o.A0)(e),h=(0,o.A0)(n),l=new Uint8Array(a),d=r.b.create(t,u),p=d._cloneInto().update(h);return{c:f,dkLen:a,asyncTick:c,DK:l,PRF:d,PRFSalt:p}}(t,e,n,s);let h;const l=new Uint8Array(4),d=(0,o.GL)(l),p=new Uint8Array(c.outputLen);for(let t=1,e=0;e<f;t++,e+=c.outputLen){const n=a.subarray(e,e+c.outputLen);d.setInt32(0,t,!1),(h=u._cloneInto(h)).update(l).digestInto(p),n.set(p.subarray(0,n.length));for(let t=1;t<i;t++){c._cloneInto(h).update(p).digestInto(p);for(let t=0;t<n.length;t++)n[t]^=p[t]}}return function(t,e,n,r,s){return t.destroy(),e.destroy(),r&&r.destroy(),(0,o.ru)(s),n}(c,u,a,h,p)}},397049:(t,e,n)=>{n.d(e,{JQ:()=>b,o:()=>w,pr:()=>m});var r=n(480264),o=n(796541),s=n(590920);const i=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),f=new Uint32Array(64);class a extends r.VR{constructor(t=32){super(64,t,8,!1),this.A=0|r.r$[0],this.B=0|r.r$[1],this.C=0|r.r$[2],this.D=0|r.r$[3],this.E=0|r.r$[4],this.F=0|r.r$[5],this.G=0|r.r$[6],this.H=0|r.r$[7]}get(){const{A:t,B:e,C:n,D:r,E:o,F:s,G:i,H:f}=this;return[t,e,n,r,o,s,i,f]}set(t,e,n,r,o,s,i,f){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|o,this.F=0|s,this.G=0|i,this.H=0|f}process(t,e){for(let n=0;n<16;n++,e+=4)f[n]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=f[t-15],n=f[t-2],r=(0,s.np)(e,7)^(0,s.np)(e,18)^e>>>3,o=(0,s.np)(n,17)^(0,s.np)(n,19)^n>>>10;f[t]=o+f[t-7]+r+f[t-16]|0}let{A:n,B:o,C:a,D:c,E:u,F:h,G:l,H:d}=this;for(let t=0;t<64;t++){const e=d+((0,s.np)(u,6)^(0,s.np)(u,11)^(0,s.np)(u,25))+(0,r.bc)(u,h,l)+i[t]+f[t]|0,p=((0,s.np)(n,2)^(0,s.np)(n,13)^(0,s.np)(n,22))+(0,r.l3)(n,o,a)|0;d=l,l=h,h=u,u=c+e|0,c=a,a=o,o=n,n=e+p|0}n=n+this.A|0,o=o+this.B|0,a=a+this.C|0,c=c+this.D|0,u=u+this.E|0,h=h+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(n,o,a,c,u,h,l,d)}roundClean(){(0,s.ru)(f)}destroy(){this.set(0,0,0,0,0,0,0,0),(0,s.ru)(this.buffer)}}const c=(()=>o.Vl(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((t=>BigInt(t)))))(),u=(()=>c[0])(),h=(()=>c[1])(),l=new Uint32Array(80),d=new Uint32Array(80);class p extends r.VR{constructor(t=64){super(128,t,16,!1),this.Ah=0|r.pw[0],this.Al=0|r.pw[1],this.Bh=0|r.pw[2],this.Bl=0|r.pw[3],this.Ch=0|r.pw[4],this.Cl=0|r.pw[5],this.Dh=0|r.pw[6],this.Dl=0|r.pw[7],this.Eh=0|r.pw[8],this.El=0|r.pw[9],this.Fh=0|r.pw[10],this.Fl=0|r.pw[11],this.Gh=0|r.pw[12],this.Gl=0|r.pw[13],this.Hh=0|r.pw[14],this.Hl=0|r.pw[15]}get(){const{Ah:t,Al:e,Bh:n,Bl:r,Ch:o,Cl:s,Dh:i,Dl:f,Eh:a,El:c,Fh:u,Fl:h,Gh:l,Gl:d,Hh:p,Hl:y}=this;return[t,e,n,r,o,s,i,f,a,c,u,h,l,d,p,y]}set(t,e,n,r,o,s,i,f,a,c,u,h,l,d,p,y){this.Ah=0|t,this.Al=0|e,this.Bh=0|n,this.Bl=0|r,this.Ch=0|o,this.Cl=0|s,this.Dh=0|i,this.Dl=0|f,this.Eh=0|a,this.El=0|c,this.Fh=0|u,this.Fl=0|h,this.Gh=0|l,this.Gl=0|d,this.Hh=0|p,this.Hl=0|y}process(t,e){for(let n=0;n<16;n++,e+=4)l[n]=t.getUint32(e),d[n]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|l[t-15],n=0|d[t-15],r=o.m_(e,n,1)^o.m_(e,n,8)^o.NI(e,n,7),s=o.Ou(e,n,1)^o.Ou(e,n,8)^o.Iq(e,n,7),i=0|l[t-2],f=0|d[t-2],a=o.m_(i,f,19)^o.FL(i,f,61)^o.NI(i,f,6),c=o.Ou(i,f,19)^o.$p(i,f,61)^o.Iq(i,f,6),u=o.Xb(s,c,d[t-7],d[t-16]),h=o.u8(u,r,a,l[t-7],l[t-16]);l[t]=0|h,d[t]=0|u}let{Ah:n,Al:r,Bh:s,Bl:i,Ch:f,Cl:a,Dh:c,Dl:p,Eh:y,El:g,Fh:b,Fl:w,Gh:m,Gl:E,Hh:B,Hl:v}=this;for(let t=0;t<80;t++){const e=o.m_(y,g,14)^o.m_(y,g,18)^o.FL(y,g,41),x=o.Ou(y,g,14)^o.Ou(y,g,18)^o.$p(y,g,41),S=y&b^~y&m,I=g&w^~g&E,A=o.zP(v,x,I,h[t],d[t]),O=o.pp(A,B,e,S,u[t],l[t]),_=0|A,R=o.m_(n,r,28)^o.FL(n,r,34)^o.FL(n,r,39),F=o.Ou(n,r,28)^o.$p(n,r,34)^o.$p(n,r,39),H=n&s^n&f^s&f,L=r&i^r&a^i&a;B=0|m,v=0|E,m=0|b,E=0|w,b=0|y,w=0|g,({h:y,l:g}=o.IH(0|c,0|p,0|O,0|_)),c=0|f,p=0|a,f=0|s,a=0|i,s=0|n,i=0|r;const T=o.ac(_,F,L);n=o.Fn(T,O,R,H),r=0|T}({h:n,l:r}=o.IH(0|this.Ah,0|this.Al,0|n,0|r)),({h:s,l:i}=o.IH(0|this.Bh,0|this.Bl,0|s,0|i)),({h:f,l:a}=o.IH(0|this.Ch,0|this.Cl,0|f,0|a)),({h:c,l:p}=o.IH(0|this.Dh,0|this.Dl,0|c,0|p)),({h:y,l:g}=o.IH(0|this.Eh,0|this.El,0|y,0|g)),({h:b,l:w}=o.IH(0|this.Fh,0|this.Fl,0|b,0|w)),({h:m,l:E}=o.IH(0|this.Gh,0|this.Gl,0|m,0|E)),({h:B,l:v}=o.IH(0|this.Hh,0|this.Hl,0|B,0|v)),this.set(n,r,s,i,f,a,c,p,y,g,b,w,m,E,B,v)}roundClean(){(0,s.ru)(l,d)}destroy(){(0,s.ru)(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const y=Uint32Array.from([573645204,4230739756,2673172387,3360449730,596883563,1867755857,2520282905,1497426621,2519219938,2827943907,3193839141,1401305490,721525244,746961066,246885852,2177182882]);class g extends p{constructor(){super(32),this.Ah=0|y[0],this.Al=0|y[1],this.Bh=0|y[2],this.Bl=0|y[3],this.Ch=0|y[4],this.Cl=0|y[5],this.Dh=0|y[6],this.Dl=0|y[7],this.Eh=0|y[8],this.El=0|y[9],this.Fh=0|y[10],this.Fl=0|y[11],this.Gh=0|y[12],this.Gl=0|y[13],this.Hh=0|y[14],this.Hl=0|y[15]}}const b=(0,s.V1)((()=>new a)),w=(0,s.V1)((()=>new p)),m=(0,s.V1)((()=>new g))},153929:(t,e,n)=>{n.d(e,{JQ:()=>r});const r=n(397049).JQ},748796:(t,e,n)=>{n.d(e,{DZ:()=>B,fr:()=>v});var r=n(796541),o=n(590920);const s=BigInt(0),i=BigInt(1),f=BigInt(2),a=BigInt(7),c=BigInt(256),u=BigInt(113),h=[],l=[],d=[];for(let t=0,e=i,n=1,r=0;t<24;t++){[n,r]=[r,(2*n+3*r)%5],h.push(2*(5*r+n)),l.push((t+1)*(t+2)/2%64);let o=s;for(let t=0;t<7;t++)e=(e<<i^(e>>a)*u)%c,e&f&&(o^=i<<(i<<BigInt(t))-i);d.push(o)}const p=(0,r.Vl)(d,!0),y=p[0],g=p[1],b=(t,e,n)=>n>32?(0,r.SD)(t,e,n):(0,r.EP)(t,e,n),w=(t,e,n)=>n>32?(0,r.mk)(t,e,n):(0,r.gm)(t,e,n);class m extends o.kb{constructor(t,e,n,r=!1,s=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=e,this.outputLen=n,this.enableXOF=r,this.rounds=s,(0,o.k8)(n),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=(0,o.Jq)(this.state)}clone(){return this._cloneInto()}keccak(){(0,o.Ux)(this.state32),function(t,e=24){const n=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let e=0;e<10;e++)n[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const r=(e+8)%10,o=(e+2)%10,s=n[o],i=n[o+1],f=b(s,i,1)^n[r],a=w(s,i,1)^n[r+1];for(let n=0;n<50;n+=10)t[e+n]^=f,t[e+n+1]^=a}let e=t[2],o=t[3];for(let n=0;n<24;n++){const r=l[n],s=b(e,o,r),i=w(e,o,r),f=h[n];e=t[f],o=t[f+1],t[f]=s,t[f+1]=i}for(let e=0;e<50;e+=10){for(let r=0;r<10;r++)n[r]=t[e+r];for(let r=0;r<10;r++)t[e+r]^=~n[(r+2)%10]&n[(r+4)%10]}t[0]^=y[r],t[1]^=g[r]}(0,o.ru)(n)}(this.state32,this.rounds),(0,o.Ux)(this.state32),this.posOut=0,this.pos=0}update(t){(0,o.$h)(this),t=(0,o.O0)(t),(0,o.gk)(t);const{blockLen:e,state:n}=this,r=t.length;for(let o=0;o<r;){const s=Math.min(e-this.pos,r-o);for(let e=0;e<s;e++)n[this.pos++]^=t[o++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:n,blockLen:r}=this;t[n]^=e,0!=(128&e)&&n===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){(0,o.$h)(this,!1),(0,o.gk)(t),this.finish();const e=this.state,{blockLen:n}=this;for(let r=0,o=t.length;r<o;){this.posOut>=n&&this.keccak();const s=Math.min(n-this.posOut,o-r);t.set(e.subarray(this.posOut,this.posOut+s),r),this.posOut+=s,r+=s}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return(0,o.k8)(t),this.xofInto(new Uint8Array(t))}digestInto(t){if((0,o.eB)(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,(0,o.ru)(this.state)}_cloneInto(t){const{blockLen:e,suffix:n,outputLen:r,rounds:o,enableXOF:s}=this;return t||(t=new m(e,n,r,s,o)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=o,t.suffix=n,t.outputLen=r,t.enableXOF=s,t.destroyed=this.destroyed,t}}const E=(t,e,n)=>(0,o.V1)((()=>new m(e,t,n))),B=(()=>E(6,136,32))(),v=(()=>E(1,136,32))()},108448:(t,e,n)=>{n.d(e,{o:()=>o,pr:()=>s});var r=n(397049);const o=r.o,s=r.pr},590920:(t,e,n)=>{n.d(e,{$h:()=>a,A0:()=>_,GL:()=>l,Jq:()=>u,Md:()=>A,N$:()=>b,O0:()=>O,O6:()=>N,U5:()=>F,Ux:()=>w,V1:()=>L,WV:()=>T,XG:()=>p,_t:()=>o,ci:()=>B,eB:()=>c,eV:()=>R,gk:()=>i,iY:()=>I,k8:()=>s,kb:()=>H,np:()=>d,nr:()=>S,ru:()=>h,z3:()=>f});var r=n(108067);function o(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function s(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function i(t,...e){if(!o(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function f(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.createHasher");s(t.outputLen),s(t.blockLen)}function a(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function c(t,e){i(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function u(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function h(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function l(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function d(t,e){return t<<32-e|t>>>e}function p(t,e){return t<<e|t>>>32-e>>>0}const y=(()=>68===new Uint8Array(new Uint32Array([287454020]).buffer)[0])();function g(t){return t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255}const b=y?t=>t:t=>g(t),w=y?t=>t:function(t){for(let e=0;e<t.length;e++)t[e]=g(t[e]);return t},m=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),E=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function B(t){if(i(t),m)return t.toHex();let e="";for(let n=0;n<t.length;n++)e+=E[t[n]];return e}const v={_0:48,_9:57,A:65,F:70,a:97,f:102};function x(t){return t>=v._0&&t<=v._9?t-v._0:t>=v.A&&t<=v.F?t-(v.A-10):t>=v.a&&t<=v.f?t-(v.a-10):void 0}function S(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(m)return Uint8Array.fromHex(t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let e=0,o=0;e<n;e++,o+=2){const n=x(t.charCodeAt(o)),s=x(t.charCodeAt(o+1));if(void 0===n||void 0===s){const e=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+o)}r[e]=16*n+s}return r}function I(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}function A(t){return(new TextDecoder).decode(t)}function O(t){return"string"==typeof t&&(t=I(t)),i(t),t}function _(t){return"string"==typeof t&&(t=I(t)),i(t),t}function R(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];i(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n}function F(t,e){if(void 0!==e&&"[object Object]"!=={}.toString.call(e))throw new Error("options should be object or undefined");return Object.assign(t,e)}class H{}function L(t){const e=e=>t().update(O(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function T(t){const e=(e,n)=>t(n).update(O(e)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=e=>t(e),e}function N(t=32){if(r.e&&"function"==typeof r.e.getRandomValues)return r.e.getRandomValues(new Uint8Array(t));if(r.e&&"function"==typeof r.e.randomBytes)return Uint8Array.from(r.e.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}},455661:(t,e,n)=>{n.d(e,{_:()=>f});var r=n(600144),o=n(135020),s=n(72955);function i(t){return{hash:t,hmac:(e,...n)=>(0,r.b)(t,e,(0,o.eV)(...n)),randomBytes:o.O6}}function f(t,e){const n=e=>(0,s.e4)({...t,...i(e)});return Object.freeze({...n(e),create:n})}},828219:(t,e,n)=>{n.d(e,{D1:()=>u,Kd:()=>h,Mx:()=>c});var r=n(666814),o=n(572798);const s=BigInt(0),i=BigInt(1),f=new WeakMap,a=new WeakMap;function c(t,e){const n=(t,e)=>{const n=e.negate();return t?n:e},r=t=>{if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error(`Wrong window size=${t}, should be [1..${e}]`)},o=t=>(r(t),{windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:n,unsafeLadder(e,n){let r=t.ZERO,o=e;for(;n>s;)n&i&&(r=r.add(o)),o=o.double(),n>>=i;return r},precomputeWindow(t,e){const{windows:n,windowSize:r}=o(e),s=[];let i=t,f=i;for(let t=0;t<n;t++){f=i,s.push(f);for(let t=1;t<r;t++)f=f.add(i),s.push(f);i=f.double()}return s},wNAF(e,r,s){const{windows:f,windowSize:a}=o(e);let c=t.ZERO,u=t.BASE;const h=BigInt(2**e-1),l=2**e,d=BigInt(e);for(let t=0;t<f;t++){const e=t*a;let o=Number(s&h);s>>=d,o>a&&(o-=l,s+=i);const f=e,p=e+Math.abs(o)-1,y=t%2!=0,g=o<0;0===o?u=u.add(n(y,r[f])):c=c.add(n(g,r[p]))}return{p:c,f:u}},wNAFCached(t,e,n){const r=a.get(t)||1;let o=f.get(t);return o||(o=this.precomputeWindow(t,r),1!==r&&f.set(t,n(o))),this.wNAF(r,o,e)},setWindowSize(t,e){r(e),a.set(t,e),f.delete(t)}}}function u(t,e,n,r){if(!Array.isArray(n)||!Array.isArray(r)||r.length!==n.length)throw new Error("arrays of points and scalars must have equal length");r.forEach(((t,n)=>{if(!e.isValid(t))throw new Error(`wrong scalar at index ${n}`)})),n.forEach(((e,n)=>{if(!(e instanceof t))throw new Error(`wrong point at index ${n}`)}));const s=(0,o.Dd)(BigInt(n.length)),i=s>12?s-3:s>4?s-2:s?2:1,f=(1<<i)-1,a=new Array(f+1).fill(t.ZERO),c=Math.floor((e.BITS-1)/i)*i;let u=t.ZERO;for(let e=c;e>=0;e-=i){a.fill(t.ZERO);for(let t=0;t<r.length;t++){const o=r[t],s=Number(o>>BigInt(e)&BigInt(f));a[s]=a[s].add(n[t])}let o=t.ZERO;for(let e=a.length-1,n=t.ZERO;e>0;e--)n=n.add(a[e]),o=o.add(n);if(u=u.add(o),0!==e)for(let t=0;t<i;t++)u=u.double()}return u}function h(t){return(0,r.OP)(t.Fp),(0,o.FF)(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,r.kK)(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}},666814:(t,e,n)=>{n.d(e,{OP:()=>g,PS:()=>E,U_:()=>p,Us:()=>B,gN:()=>w,kK:()=>b,oA:()=>d,wQ:()=>h});var r=n(572798);const o=BigInt(0),s=BigInt(1),i=BigInt(2),f=BigInt(3),a=BigInt(4),c=BigInt(5),u=BigInt(8);function h(t,e){const n=t%e;return n>=o?n:e+n}function l(t,e,n){if(n<=o||e<o)throw new Error("Expected power/modulo > 0");if(n===s)return o;let r=s;for(;e>o;)e&s&&(r=r*t%n),t=t*t%n,e>>=s;return r}function d(t,e,n){let r=t;for(;e-- >o;)r*=r,r%=n;return r}function p(t,e){if(t===o||e<=o)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=h(t,e),r=e,i=o,f=s,a=s,c=o;for(;n!==o;){const t=r/n,e=r%n,o=i-a*t,s=f-c*t;r=n,n=e,i=a,f=c,a=o,c=s}if(r!==s)throw new Error("invert: does not exist");return h(i,e)}BigInt(9),BigInt(16);const y=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function g(t){const e=y.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return(0,r.FF)(t,e)}function b(t,e){const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function w(t,e,n=!1,d={}){if(t<=o)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:y,nByteLength:g}=b(t,e);if(g>2048)throw new Error("Field lengths over 2048 bytes are not supported");const w=function(t){if(t%a===f){const e=(t+s)/a;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}if(t%u===c){const e=(t-c)/u;return function(t,n){const r=t.mul(n,i),o=t.pow(r,e),s=t.mul(n,o),f=t.mul(t.mul(s,i),o),a=t.mul(s,t.sub(f,t.ONE));if(!t.eql(t.sqr(a),n))throw new Error("Cannot find square root");return a}}return function(t){const e=(t-s)/i;let n,r,f;for(n=t-s,r=0;n%i===o;n/=i,r++);for(f=i;f<t&&l(f,e,t)!==t-s;f++);if(1===r){const e=(t+s)/a;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}const c=(n+s)/i;return function(t,o){if(t.pow(o,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let i=r,a=t.pow(t.mul(t.ONE,f),n),u=t.pow(o,c),h=t.pow(o,n);for(;!t.eql(h,t.ONE);){if(t.eql(h,t.ZERO))return t.ZERO;let e=1;for(let n=t.sqr(h);e<i&&!t.eql(n,t.ONE);e++)n=t.sqr(n);const n=t.pow(a,s<<BigInt(i-e-1));a=t.sqr(n),u=t.mul(u,n),h=t.mul(h,a),i=e}return u}}(t)}(t),m=Object.freeze({ORDER:t,BITS:y,BYTES:g,MASK:(0,r.dQ)(y),ZERO:o,ONE:s,create:e=>h(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return o<=e&&e<t},is0:t=>t===o,isOdd:t=>(t&s)===s,neg:e=>h(-e,t),eql:(t,e)=>t===e,sqr:e=>h(e*e,t),add:(e,n)=>h(e+n,t),sub:(e,n)=>h(e-n,t),mul:(e,n)=>h(e*n,t),pow:(t,e)=>function(t,e,n){if(n<o)throw new Error("Expected power > 0");if(n===o)return t.ONE;if(n===s)return e;let r=t.ONE,i=e;for(;n>o;)n&s&&(r=t.mul(r,i)),i=t.sqr(i),n>>=s;return r}(m,t,e),div:(e,n)=>h(e*p(n,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>p(e,t),sqrt:d.sqrt||(t=>w(m,t)),invertBatch:t=>function(t,e){const n=new Array(e.length),r=e.reduce(((e,r,o)=>t.is0(r)?e:(n[o]=e,t.mul(e,r))),t.ONE),o=t.inv(r);return e.reduceRight(((e,r,o)=>t.is0(r)?e:(n[o]=t.mul(e,n[o]),t.mul(e,r))),o),n}(m,t),cmov:(t,e,n)=>n?e:t,toBytes:t=>n?(0,r.S5)(t,g):(0,r.tL)(t,g),fromBytes:t=>{if(t.length!==g)throw new Error(`Fp.fromBytes: expected ${g}, got ${t.length}`);return n?(0,r.ty)(t):(0,r.bytesToNumberBE)(t)}});return Object.freeze(m)}function m(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function E(t){const e=m(t);return e+Math.ceil(e/2)}function B(t,e,n=!1){const o=t.length,i=m(e),f=E(e);if(o<16||o<f||o>1024)throw new Error(`expected ${f}-1024 bytes of input, got ${o}`);const a=h(n?(0,r.bytesToNumberBE)(t):(0,r.ty)(t),e-s)+s;return n?(0,r.S5)(a,i):(0,r.tL)(a,i)}},572798:(t,e,n)=>{n.d(e,{Dd:()=>I,FF:()=>H,Fy:()=>S,H9:()=>L,S5:()=>m,Z2:()=>x,_t:()=>i,bytesToNumberBE:()=>g,ci:()=>u,dQ:()=>A,eV:()=>B,gk:()=>f,hexToBytes:()=>y,n$:()=>R,ql:()=>E,tL:()=>w,ty:()=>b,uw:()=>a,uz:()=>h});const r=BigInt(0),o=BigInt(1),s=BigInt(2);function i(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}function f(t){if(!i(t))throw new Error("Uint8Array expected")}function a(t,e){if("boolean"!=typeof e)throw new Error(`${t} must be valid boolean, got "${e}".`)}const c=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function u(t){f(t);let e="";for(let n=0;n<t.length;n++)e+=c[t[n]];return e}function h(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function l(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}const d={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function p(t){return t>=d._0&&t<=d._9?t-d._0:t>=d._A&&t<=d._F?t-(d._A-10):t>=d._a&&t<=d._f?t-(d._a-10):void 0}function y(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let e=0,o=0;e<n;e++,o+=2){const n=p(t.charCodeAt(o)),s=p(t.charCodeAt(o+1));if(void 0===n||void 0===s){const e=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+o)}r[e]=16*n+s}return r}function g(t){return l(u(t))}function b(t){return f(t),l(u(Uint8Array.from(t).reverse()))}function w(t,e){return y(t.toString(16).padStart(2*e,"0"))}function m(t,e){return w(t,e).reverse()}function E(t,e,n){let r;if("string"==typeof e)try{r=y(e)}catch(n){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${n}`)}else{if(!i(e))throw new Error(`${t} must be hex string or Uint8Array`);r=Uint8Array.from(e)}const o=r.length;if("number"==typeof n&&o!==n)throw new Error(`${t} expected ${n} bytes, got ${o}`);return r}function B(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];f(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n}const v=t=>"bigint"==typeof t&&r<=t;function x(t,e,n){return v(t)&&v(e)&&v(n)&&e<=t&&t<n}function S(t,e,n,r){if(!x(e,n,r))throw new Error(`expected valid ${t}: ${n} <= n < ${r}, got ${typeof e} ${e}`)}function I(t){let e;for(e=0;t>r;t>>=o,e+=1);return e}const A=t=>(s<<BigInt(t-1))-o,O=t=>new Uint8Array(t),_=t=>Uint8Array.from(t);function R(t,e,n){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let r=O(t),o=O(t),s=0;const i=()=>{r.fill(1),o.fill(0),s=0},f=(...t)=>n(o,r,...t),a=(t=O())=>{o=f(_([0]),t),r=f(),0!==t.length&&(o=f(_([1]),t),r=f())},c=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const n=[];for(;t<e;){r=f();const e=r.slice();n.push(e),t+=r.length}return B(...n)};return(t,e)=>{let n;for(i(),a(t);!(n=e(c()));)a();return i(),n}}const F={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||i(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function H(t,e,n={}){const r=(e,n,r)=>{const o=F[n];if("function"!=typeof o)throw new Error(`Invalid validator "${n}", expected function`);const s=t[e];if(!(r&&void 0===s||o(s,t)))throw new Error(`Invalid param ${String(e)}=${s} (${typeof s}), expected ${n}`)};for(const[t,n]of Object.entries(e))r(t,n,!1);for(const[t,e]of Object.entries(n))r(t,e,!0);return t}function L(t){const e=new WeakMap;return(n,...r)=>{const o=e.get(n);if(void 0!==o)return o;const s=t(n,...r);return e.set(n,s),s}}},72955:(t,e,n)=>{n.d(e,{e4:()=>d});var r=n(828219),o=n(666814),s=n(572798);function i(t){void 0!==t.lowS&&(0,s.uw)("lowS",t.lowS),void 0!==t.prehash&&(0,s.uw)("prehash",t.prehash)}const{bytesToNumberBE:f,hexToBytes:a}=s,c={Err:class extends Error{constructor(t=""){super(t)}},_tlv:{encode:(t,e)=>{const{Err:n}=c;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(1&e.length)throw new n("tlv.encode: unpadded data");const r=e.length/2,o=s.uz(r);if(o.length/2&128)throw new n("tlv.encode: long form length too big");const i=r>127?s.uz(o.length/2|128):"";return`${s.uz(t)}${i}${o}${e}`},decode(t,e){const{Err:n}=c;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const o=e[r++];let s=0;if(128&o){const t=127&o;if(!t)throw new n("tlv.decode(long): indefinite length not supported");if(t>4)throw new n("tlv.decode(long): byte length is too big");const i=e.subarray(r,r+t);if(i.length!==t)throw new n("tlv.decode: length bytes not complete");if(0===i[0])throw new n("tlv.decode(long): zero leftmost byte");for(const t of i)s=s<<8|t;if(r+=t,s<128)throw new n("tlv.decode(long): not minimal encoding")}else s=o;const i=e.subarray(r,r+s);if(i.length!==s)throw new n("tlv.decode: wrong value length");return{v:i,l:e.subarray(r+s)}}},_int:{encode(t){const{Err:e}=c;if(t<u)throw new e("integer: negative integers are not allowed");let n=s.uz(t);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new e("unexpected assertion");return n},decode(t){const{Err:e}=c;if(128&t[0])throw new e("Invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("Invalid signature integer: unnecessary leading zero");return f(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=c,o="string"==typeof t?a(t):t;s.gk(o);const{v:i,l:f}=r.decode(48,o);if(f.length)throw new e("Invalid signature: left bytes after parsing");const{v:u,l:h}=r.decode(2,i),{v:l,l:d}=r.decode(2,h);if(d.length)throw new e("Invalid signature: left bytes after parsing");return{r:n.decode(u),s:n.decode(l)}},hexFromSig(t){const{_tlv:e,_int:n}=c,r=`${e.encode(2,n.encode(t.r))}${e.encode(2,n.encode(t.s))}`;return e.encode(48,r)}},u=BigInt(0),h=BigInt(1),l=(BigInt(2),BigInt(3));function d(t){const e=function(t){const e=(0,r.Kd)(t);return s.FF(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:n,n:f}=e,a=n.BYTES+1,d=2*n.BYTES+1;function p(t){return o.wQ(t,f)}function y(t){return o.U_(t,f)}const{ProjectivePoint:g,normPrivateKeyToScalar:b,weierstrassEquation:w,isWithinCurveOrder:m}=function(t){const e=function(t){const e=(0,r.Kd)(t);s.FF(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:o,a:i}=e;if(n){if(!o.eql(i,o.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:n}=e,i=o.gN(e.n,e.nBitLength),f=e.toBytes||((t,e,r)=>{const o=e.toAffine();return s.eV(Uint8Array.from([4]),n.toBytes(o.x),n.toBytes(o.y))}),a=e.fromBytes||(t=>{const e=t.subarray(1);return{x:n.fromBytes(e.subarray(0,n.BYTES)),y:n.fromBytes(e.subarray(n.BYTES,2*n.BYTES))}});function c(t){const{a:r,b:o}=e,s=n.sqr(t),i=n.mul(s,t);return n.add(n.add(i,n.mul(t,r)),o)}if(!n.eql(n.sqr(e.Gy),c(e.Gx)))throw new Error("bad generator point: equation left != right");function d(t){const{allowedPrivateKeyLengths:n,nByteLength:r,wrapPrivateKey:i,n:f}=e;if(n&&"bigint"!=typeof t){if(s._t(t)&&(t=s.ci(t)),"string"!=typeof t||!n.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*r,"0")}let a;try{a="bigint"==typeof t?t:s.bytesToNumberBE((0,s.ql)("private key",t,r))}catch(e){throw new Error(`private key must be ${r} bytes, hex or bigint, not ${typeof t}`)}return i&&(a=o.wQ(a,f)),s.Fy("private key",a,h,f),a}function p(t){if(!(t instanceof b))throw new Error("ProjectivePoint expected")}const y=(0,s.H9)(((t,e)=>{const{px:r,py:o,pz:s}=t;if(n.eql(s,n.ONE))return{x:r,y:o};const i=t.is0();null==e&&(e=i?n.ONE:n.inv(s));const f=n.mul(r,e),a=n.mul(o,e),c=n.mul(s,e);if(i)return{x:n.ZERO,y:n.ZERO};if(!n.eql(c,n.ONE))throw new Error("invZ was invalid");return{x:f,y:a}})),g=(0,s.H9)((t=>{if(t.is0()){if(e.allowInfinityPoint&&!n.is0(t.py))return;throw new Error("bad point: ZERO")}const{x:r,y:o}=t.toAffine();if(!n.isValid(r)||!n.isValid(o))throw new Error("bad point: x or y not FE");const s=n.sqr(o),i=c(r);if(!n.eql(s,i))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0}));class b{constructor(t,e,r){if(this.px=t,this.py=e,this.pz=r,null==t||!n.isValid(t))throw new Error("x required");if(null==e||!n.isValid(e))throw new Error("y required");if(null==r||!n.isValid(r))throw new Error("z required");Object.freeze(this)}static fromAffine(t){const{x:e,y:r}=t||{};if(!t||!n.isValid(e)||!n.isValid(r))throw new Error("invalid affine point");if(t instanceof b)throw new Error("projective point not allowed");const o=t=>n.eql(t,n.ZERO);return o(e)&&o(r)?b.ZERO:new b(e,r,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=n.invertBatch(t.map((t=>t.pz)));return t.map(((t,n)=>t.toAffine(e[n]))).map(b.fromAffine)}static fromHex(t){const e=b.fromAffine(a((0,s.ql)("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return b.BASE.multiply(d(t))}static msm(t,e){return(0,r.D1)(b,i,t,e)}_setWindowSize(t){m.setWindowSize(this,t)}assertValidity(){g(this)}hasEvenY(){const{y:t}=this.toAffine();if(n.isOdd)return!n.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){p(t);const{px:e,py:r,pz:o}=this,{px:s,py:i,pz:f}=t,a=n.eql(n.mul(e,f),n.mul(s,o)),c=n.eql(n.mul(r,f),n.mul(i,o));return a&&c}negate(){return new b(this.px,n.neg(this.py),this.pz)}double(){const{a:t,b:r}=e,o=n.mul(r,l),{px:s,py:i,pz:f}=this;let a=n.ZERO,c=n.ZERO,u=n.ZERO,h=n.mul(s,s),d=n.mul(i,i),p=n.mul(f,f),y=n.mul(s,i);return y=n.add(y,y),u=n.mul(s,f),u=n.add(u,u),a=n.mul(t,u),c=n.mul(o,p),c=n.add(a,c),a=n.sub(d,c),c=n.add(d,c),c=n.mul(a,c),a=n.mul(y,a),u=n.mul(o,u),p=n.mul(t,p),y=n.sub(h,p),y=n.mul(t,y),y=n.add(y,u),u=n.add(h,h),h=n.add(u,h),h=n.add(h,p),h=n.mul(h,y),c=n.add(c,h),p=n.mul(i,f),p=n.add(p,p),h=n.mul(p,y),a=n.sub(a,h),u=n.mul(p,d),u=n.add(u,u),u=n.add(u,u),new b(a,c,u)}add(t){p(t);const{px:r,py:o,pz:s}=this,{px:i,py:f,pz:a}=t;let c=n.ZERO,u=n.ZERO,h=n.ZERO;const d=e.a,y=n.mul(e.b,l);let g=n.mul(r,i),w=n.mul(o,f),m=n.mul(s,a),E=n.add(r,o),B=n.add(i,f);E=n.mul(E,B),B=n.add(g,w),E=n.sub(E,B),B=n.add(r,s);let v=n.add(i,a);return B=n.mul(B,v),v=n.add(g,m),B=n.sub(B,v),v=n.add(o,s),c=n.add(f,a),v=n.mul(v,c),c=n.add(w,m),v=n.sub(v,c),h=n.mul(d,B),c=n.mul(y,m),h=n.add(c,h),c=n.sub(w,h),h=n.add(w,h),u=n.mul(c,h),w=n.add(g,g),w=n.add(w,g),m=n.mul(d,m),B=n.mul(y,B),w=n.add(w,m),m=n.sub(g,m),m=n.mul(d,m),B=n.add(B,m),g=n.mul(w,B),u=n.add(u,g),g=n.mul(v,B),c=n.mul(E,c),c=n.sub(c,g),g=n.mul(E,w),h=n.mul(v,h),h=n.add(h,g),new b(c,u,h)}subtract(t){return this.add(t.negate())}is0(){return this.equals(b.ZERO)}wNAF(t){return m.wNAFCached(this,t,b.normalizeZ)}multiplyUnsafe(t){s.Fy("scalar",t,u,e.n);const r=b.ZERO;if(t===u)return r;if(t===h)return this;const{endo:o}=e;if(!o)return m.unsafeLadder(this,t);let{k1neg:i,k1:f,k2neg:a,k2:c}=o.splitScalar(t),l=r,d=r,p=this;for(;f>u||c>u;)f&h&&(l=l.add(p)),c&h&&(d=d.add(p)),p=p.double(),f>>=h,c>>=h;return i&&(l=l.negate()),a&&(d=d.negate()),d=new b(n.mul(d.px,o.beta),d.py,d.pz),l.add(d)}multiply(t){const{endo:r,n:o}=e;let i,f;if(s.Fy("scalar",t,h,o),r){const{k1neg:e,k1:o,k2neg:s,k2:a}=r.splitScalar(t);let{p:c,f:u}=this.wNAF(o),{p:h,f:l}=this.wNAF(a);c=m.constTimeNegate(e,c),h=m.constTimeNegate(s,h),h=new b(n.mul(h.px,r.beta),h.py,h.pz),i=c.add(h),f=u.add(l)}else{const{p:e,f:n}=this.wNAF(t);i=e,f=n}return b.normalizeZ([i,f])[0]}multiplyAndAddUnsafe(t,e,n){const r=b.BASE,o=(t,e)=>e!==u&&e!==h&&t.equals(r)?t.multiply(e):t.multiplyUnsafe(e),s=o(this,e).add(o(t,n));return s.is0()?void 0:s}toAffine(t){return y(this,t)}isTorsionFree(){const{h:t,isTorsionFree:n}=e;if(t===h)return!0;if(n)return n(b,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:n}=e;return t===h?this:n?n(b,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return(0,s.uw)("isCompressed",t),this.assertValidity(),f(b,this,t)}toHex(t=!0){return(0,s.uw)("isCompressed",t),s.ci(this.toRawBytes(t))}}b.BASE=new b(e.Gx,e.Gy,n.ONE),b.ZERO=new b(n.ZERO,n.ONE,n.ZERO);const w=e.nBitLength,m=(0,r.Mx)(b,e.endo?Math.ceil(w/2):w);return{CURVE:e,ProjectivePoint:b,normPrivateKeyToScalar:d,weierstrassEquation:c,isWithinCurveOrder:function(t){return s.Z2(t,h,e.n)}}}({...e,toBytes(t,e,r){const o=e.toAffine(),i=n.toBytes(o.x),f=s.eV;return(0,s.uw)("isCompressed",r),r?f(Uint8Array.from([e.hasEvenY()?2:3]),i):f(Uint8Array.from([4]),i,n.toBytes(o.y))},fromBytes(t){const e=t.length,r=t[0],o=t.subarray(1);if(e!==a||2!==r&&3!==r){if(e===d&&4===r)return{x:n.fromBytes(o.subarray(0,n.BYTES)),y:n.fromBytes(o.subarray(n.BYTES,2*n.BYTES))};throw new Error(`Point of length ${e} was invalid. Expected ${a} compressed bytes or ${d} uncompressed bytes`)}{const t=s.bytesToNumberBE(o);if(!s.Z2(t,h,n.ORDER))throw new Error("Point is not on curve");const e=w(t);let i;try{i=n.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+e)}return 1==(1&r)!=((i&h)===h)&&(i=n.neg(i)),{x:t,y:i}}}}),E=t=>s.ci(s.tL(t,e.nByteLength));function B(t){return t>f>>h}const v=(t,e,n)=>s.bytesToNumberBE(t.slice(e,n));class x{constructor(t,e,n){this.r=t,this.s=e,this.recovery=n,this.assertValidity()}static fromCompact(t){const n=e.nByteLength;return t=(0,s.ql)("compactSignature",t,2*n),new x(v(t,0,n),v(t,n,2*n))}static fromDER(t){const{r:e,s:n}=c.toSig((0,s.ql)("DER",t));return new x(e,n)}assertValidity(){s.Fy("r",this.r,h,f),s.Fy("s",this.s,h,f)}addRecoveryBit(t){return new x(this.r,this.s,t)}recoverPublicKey(t){const{r,s:o,recovery:i}=this,f=O((0,s.ql)("msgHash",t));if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");const a=2===i||3===i?r+e.n:r;if(a>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const c=0==(1&i)?"02":"03",u=g.fromHex(c+E(a)),h=y(a),l=p(-f*h),d=p(o*h),b=g.BASE.multiplyAndAddUnsafe(u,l,d);if(!b)throw new Error("point at infinify");return b.assertValidity(),b}hasHighS(){return B(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,p(-this.s),this.recovery):this}toDERRawBytes(){return s.hexToBytes(this.toDERHex())}toDERHex(){return c.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return s.hexToBytes(this.toCompactHex())}toCompactHex(){return E(this.r)+E(this.s)}}const S={isValidPrivateKey(t){try{return b(t),!0}catch(t){return!1}},normPrivateKeyToScalar:b,randomPrivateKey:()=>{const t=o.PS(e.n);return o.Us(e.randomBytes(t),e.n)},precompute:(t=8,e=g.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function I(t){const e=s._t(t),n="string"==typeof t,r=(e||n)&&t.length;return e?r===a||r===d:n?r===2*a||r===2*d:t instanceof g}const A=e.bits2int||function(t){const n=s.bytesToNumberBE(t),r=8*t.length-e.nBitLength;return r>0?n>>BigInt(r):n},O=e.bits2int_modN||function(t){return p(A(t))},_=s.dQ(e.nBitLength);function R(t){return s.Fy(`num < 2^${e.nBitLength}`,t,u,_),s.tL(t,e.nByteLength)}const F={lowS:e.lowS,prehash:!1},H={lowS:e.lowS,prehash:!1};return g.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return g.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,n=!0){if(I(t))throw new Error("first arg must be private key");if(!I(e))throw new Error("second arg must be public key");return g.fromHex(e).multiply(b(t)).toRawBytes(n)},sign:function(t,r,o=F){const{seed:f,k2sig:a}=function(t,r,o=F){if(["recovered","canonical"].some((t=>t in o)))throw new Error("sign() legacy options not supported");const{hash:f,randomBytes:a}=e;let{lowS:c,prehash:l,extraEntropy:d}=o;null==c&&(c=!0),t=(0,s.ql)("msgHash",t),i(o),l&&(t=(0,s.ql)("prehashed msgHash",f(t)));const w=O(t),E=b(r),v=[R(E),R(w)];if(null!=d&&!1!==d){const t=!0===d?a(n.BYTES):d;v.push((0,s.ql)("extraEntropy",t))}const S=s.eV(...v),I=w;return{seed:S,k2sig:function(t){const e=A(t);if(!m(e))return;const n=y(e),r=g.BASE.multiply(e).toAffine(),o=p(r.x);if(o===u)return;const s=p(n*p(I+o*E));if(s===u)return;let i=(r.x===o?0:2)|Number(r.y&h),f=s;return c&&B(s)&&(f=function(t){return B(t)?p(-t):t}(s),i^=1),new x(o,f,i)}}}(t,r,o),c=e;return s.n$(c.hash.outputLen,c.nByteLength,c.hmac)(f,a)},verify:function(t,n,r,o=H){const f=t;if(n=(0,s.ql)("msgHash",n),r=(0,s.ql)("publicKey",r),"strict"in o)throw new Error("options.strict was renamed to lowS");i(o);const{lowS:a,prehash:u}=o;let h,l;try{if("string"==typeof f||s._t(f))try{h=x.fromDER(f)}catch(t){if(!(t instanceof c.Err))throw t;h=x.fromCompact(f)}else{if("object"!=typeof f||"bigint"!=typeof f.r||"bigint"!=typeof f.s)throw new Error("PARSE");{const{r:t,s:e}=f;h=new x(t,e)}}l=g.fromHex(r)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(a&&h.hasHighS())return!1;u&&(n=e.hash(n));const{r:d,s:b}=h,w=O(n),m=y(b),E=p(w*m),B=p(d*m),v=g.BASE.multiplyAndAddUnsafe(l,E,B)?.toAffine();return!!v&&p(v.x)===d},ProjectivePoint:g,Signature:x,utils:S}}BigInt(4)},98825:(t,e,n)=>{n.d(e,{kA:()=>y,xW:()=>L});var r=n(728547),o=n(135020),s=n(455661),i=n(666814),f=n(572798);const a=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),c=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),u=BigInt(1),h=BigInt(2),l=(t,e)=>(t+e/h)/e;function d(t){const e=a,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),f=BigInt(23),c=BigInt(44),u=BigInt(88),l=t*t*t%e,d=l*l*t%e,y=(0,i.oA)(d,n,e)*d%e,g=(0,i.oA)(y,n,e)*d%e,b=(0,i.oA)(g,h,e)*l%e,w=(0,i.oA)(b,o,e)*b%e,m=(0,i.oA)(w,s,e)*w%e,E=(0,i.oA)(m,c,e)*m%e,B=(0,i.oA)(E,u,e)*E%e,v=(0,i.oA)(B,c,e)*m%e,x=(0,i.oA)(v,n,e)*d%e,S=(0,i.oA)(x,f,e)*w%e,I=(0,i.oA)(S,r,e)*l%e,A=(0,i.oA)(I,h,e);if(!p.eql(p.sqr(A),t))throw new Error("Cannot find square root");return A}const p=(0,i.gN)(a,void 0,void 0,{sqrt:d}),y=(0,s._)({a:BigInt(0),b:BigInt(7),Fp:p,n:c,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=c,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-u*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,f=BigInt("0x100000000000000000000000000000000"),a=l(s*t,e),h=l(-r*t,e);let d=(0,i.wQ)(t-a*n-h*o,e),p=(0,i.wQ)(-a*r-h*s,e);const y=d>f,g=p>f;if(y&&(d=e-d),g&&(p=e-p),d>f||p>f)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:y,k1:d,k2neg:g,k2:p}}}},r.JQ),g=BigInt(0),b={};function w(t,...e){let n=b[t];if(void 0===n){const e=(0,r.JQ)(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=(0,f.eV)(e,e),b[t]=n}return(0,r.JQ)((0,f.eV)(n,...e))}const m=t=>t.toRawBytes(!0).slice(1),E=t=>(0,f.tL)(t,32),B=t=>(0,i.wQ)(t,a),v=t=>(0,i.wQ)(t,c),x=y.ProjectivePoint,S=(t,e,n)=>x.BASE.multiplyAndAddUnsafe(t,e,n);function I(t){let e=y.utils.normPrivateKeyToScalar(t),n=x.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:v(-e),bytes:m(n)}}function A(t){(0,f.Fy)("x",t,u,a);const e=B(t*t);let n=d(B(e*t+BigInt(7)));n%h!==g&&(n=B(-n));const r=new x(t,n,u);return r.assertValidity(),r}const O=f.bytesToNumberBE;function _(...t){return v(O(w("BIP0340/challenge",...t)))}function R(t){return I(t).bytes}function F(t,e,n=(0,o.O6)(32)){const r=(0,f.ql)("message",t),{bytes:s,scalar:i}=I(e),a=(0,f.ql)("auxRand",n,32),c=E(i^O(w("BIP0340/aux",a))),u=w("BIP0340/nonce",c,s,r),h=v(O(u));if(h===g)throw new Error("sign failed: k is zero");const{bytes:l,scalar:d}=I(h),p=_(l,s,r),y=new Uint8Array(64);if(y.set(l,0),y.set(E(v(d+p*i)),32),!H(y,r,s))throw new Error("sign: Invalid signature produced");return y}function H(t,e,n){const r=(0,f.ql)("signature",t,64),o=(0,f.ql)("message",e),s=(0,f.ql)("publicKey",n,32);try{const t=A(O(s)),e=O(r.subarray(0,32));if(!(0,f.Z2)(e,u,a))return!1;const n=O(r.subarray(32,64));if(!(0,f.Z2)(n,u,c))return!1;const i=_(E(e),m(t),o),h=S(t,n,v(-i));return!(!h||!h.hasEvenY()||h.toAffine().x!==e)}catch(t){return!1}}const L=(()=>({getPublicKey:R,sign:F,verify:H,utils:{randomPrivateKey:y.utils.randomPrivateKey,lift_x:A,pointToBytes:m,numberToBytesBE:f.tL,bytesToNumberBE:f.bytesToNumberBE,taggedHash:w,mod:i.wQ}}))()},282970:(t,e,n)=>{function r(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`positive integer expected, not ${t}`)}function o(t,...e){if(!((n=t)instanceof Uint8Array||null!=n&&"object"==typeof n&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(e.length>0&&!e.includes(t.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}function s(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");r(t.outputLen),r(t.blockLen)}function i(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function f(t,e){o(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}n.d(e,{Gg:()=>i,J8:()=>f,aI:()=>o,vp:()=>s})},29981:(t,e,n)=>{n.d(e,{VR:()=>f,bc:()=>s,l3:()=>i});var r=n(282970),o=n(135020);const s=(t,e,n)=>t&e^~t&n,i=(t,e,n)=>t&e^t&n^e&n;class f extends o.kb{constructor(t,e,n,r){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=(0,o.GL)(this.buffer)}update(t){(0,r.Gg)(this);const{view:e,buffer:n,blockLen:s}=this,i=(t=(0,o.O0)(t)).length;for(let r=0;r<i;){const f=Math.min(s-this.pos,i-r);if(f!==s)n.set(t.subarray(r,r+f),this.pos),this.pos+=f,r+=f,this.pos===s&&(this.process(e,0),this.pos=0);else{const e=(0,o.GL)(t);for(;s<=i-r;r+=s)this.process(e,r)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){(0,r.Gg)(this),(0,r.J8)(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:s,isLE:i}=this;let{pos:f}=this;e[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>s-f&&(this.process(n,0),f=0);for(let t=f;t<s;t++)e[t]=0;!function(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),i=Number(n>>o&s),f=Number(n&s),a=r?4:0,c=r?0:4;t.setUint32(e+a,i,r),t.setUint32(e+c,f,r)}(n,s-8,BigInt(8*this.length),i),this.process(n,0);const a=(0,o.GL)(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,h=this.get();if(u>h.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<u;t++)a.setUint32(4*t,h[t],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:o,destroyed:s,pos:i}=this;return t.length=r,t.pos=i,t.finished=o,t.destroyed=s,r%e&&t.buffer.set(n),t}}},798459:(t,e,n)=>{n.d(e,{e:()=>r});const r="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},600144:(t,e,n)=>{n.d(e,{b:()=>i});var r=n(282970),o=n(135020);class s extends o.kb{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,(0,r.vp)(t);const n=(0,o.O0)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(n.length>s?t.create().update(n).digest():n);for(let t=0;t<i.length;t++)i[t]^=54;this.iHash.update(i),this.oHash=t.create();for(let t=0;t<i.length;t++)i[t]^=106;this.oHash.update(i),i.fill(0)}update(t){return(0,r.Gg)(this),this.iHash.update(t),this}digestInto(t){(0,r.Gg)(this),(0,r.aI)(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:o,blockLen:s,outputLen:i}=this;return t.finished=r,t.destroyed=o,t.blockLen=s,t.outputLen=i,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const i=(t,e,n)=>new s(t,e).update(n).digest();i.create=(t,e)=>new s(t,e)},638156:(t,e,n)=>{n.d(e,{b:()=>b});var r=n(29981),o=n(135020);const s=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),i=new Uint8Array(new Array(16).fill(0).map(((t,e)=>e)));let f=[i],a=[i.map((t=>(9*t+5)%16))];for(let t=0;t<4;t++)for(let e of[f,a])e.push(e[t].map((t=>s[t])));const c=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((t=>new Uint8Array(t))),u=f.map(((t,e)=>t.map((t=>c[e][t])))),h=a.map(((t,e)=>t.map((t=>c[e][t])))),l=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),d=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]);function p(t,e,n,r){return 0===t?e^n^r:1===t?e&n|~e&r:2===t?(e|~n)^r:3===t?e&r|n&~r:e^(n|~r)}const y=new Uint32Array(16);class g extends r.VR{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:n,h3:r,h4:o}=this;return[t,e,n,r,o]}set(t,e,n,r,o){this.h0=0|t,this.h1=0|e,this.h2=0|n,this.h3=0|r,this.h4=0|o}process(t,e){for(let n=0;n<16;n++,e+=4)y[n]=t.getUint32(e,!0);let n=0|this.h0,r=n,s=0|this.h1,i=s,c=0|this.h2,g=c,b=0|this.h3,w=b,m=0|this.h4,E=m;for(let t=0;t<5;t++){const e=4-t,B=l[t],v=d[t],x=f[t],S=a[t],I=u[t],A=h[t];for(let e=0;e<16;e++){const r=(0,o.XG)(n+p(t,s,c,b)+y[x[e]]+B,I[e])+m|0;n=m,m=b,b=0|(0,o.XG)(c,10),c=s,s=r}for(let t=0;t<16;t++){const n=(0,o.XG)(r+p(e,i,g,w)+y[S[t]]+v,A[t])+E|0;r=E,E=w,w=0|(0,o.XG)(g,10),g=i,i=n}}this.set(this.h1+c+w|0,this.h2+b+E|0,this.h3+m+r|0,this.h4+n+i|0,this.h0+s+g|0)}roundClean(){y.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const b=(0,o.hE)((()=>new g))},728547:(t,e,n)=>{n.d(e,{JQ:()=>c});var r=n(29981),o=n(135020);const s=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),i=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),f=new Uint32Array(64);class a extends r.VR{constructor(){super(64,32,8,!1),this.A=0|i[0],this.B=0|i[1],this.C=0|i[2],this.D=0|i[3],this.E=0|i[4],this.F=0|i[5],this.G=0|i[6],this.H=0|i[7]}get(){const{A:t,B:e,C:n,D:r,E:o,F:s,G:i,H:f}=this;return[t,e,n,r,o,s,i,f]}set(t,e,n,r,o,s,i,f){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|o,this.F=0|s,this.G=0|i,this.H=0|f}process(t,e){for(let n=0;n<16;n++,e+=4)f[n]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=f[t-15],n=f[t-2],r=(0,o.np)(e,7)^(0,o.np)(e,18)^e>>>3,s=(0,o.np)(n,17)^(0,o.np)(n,19)^n>>>10;f[t]=s+f[t-7]+r+f[t-16]|0}let{A:n,B:i,C:a,D:c,E:u,F:h,G:l,H:d}=this;for(let t=0;t<64;t++){const e=d+((0,o.np)(u,6)^(0,o.np)(u,11)^(0,o.np)(u,25))+(0,r.bc)(u,h,l)+s[t]+f[t]|0,p=((0,o.np)(n,2)^(0,o.np)(n,13)^(0,o.np)(n,22))+(0,r.l3)(n,i,a)|0;d=l,l=h,h=u,u=c+e|0,c=a,a=i,i=n,n=e+p|0}n=n+this.A|0,i=i+this.B|0,a=a+this.C|0,c=c+this.D|0,u=u+this.E|0,h=h+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(n,i,a,c,u,h,l,d)}roundClean(){f.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const c=(0,o.hE)((()=>new a))},135020:(t,e,n)=>{n.d(e,{GL:()=>s,O0:()=>a,O6:()=>l,XG:()=>f,eV:()=>c,hE:()=>h,kb:()=>u,np:()=>i});var r=n(798459),o=n(282970);const s=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),i=(t,e)=>t<<32-e|t>>>e,f=(t,e)=>t<<e|t>>>32-e>>>0;function a(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),(0,o.aI)(t),t}function c(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];(0,o.aI)(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n}new Uint8Array(new Uint32Array([287454020]).buffer)[0];class u{clone(){return this._cloneInto()}}function h(t){const e=e=>t().update(a(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function l(t=32){if(r.e&&"function"==typeof r.e.getRandomValues)return r.e.getRandomValues(new Uint8Array(t));if(r.e&&"function"==typeof r.e.randomBytes)return r.e.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}},757226:(t,e,n)=>{n.d(e,{_:()=>f});var r=n(563682),o=n(467222),s=n(127743);function i(t){return{hash:t,hmac:(e,...n)=>(0,r.b)(t,e,(0,o.eV)(...n)),randomBytes:o.O6}}function f(t,e){const n=e=>(0,s.e4)({...t,...i(e)});return Object.freeze({...n(e),create:n})}},529613:(t,e,n)=>{n.d(e,{K:()=>a,M:()=>f});var r=n(748193),o=n(880907);const s=BigInt(0),i=BigInt(1);function f(t,e){const n=(t,e)=>{const n=e.negate();return t?n:e},r=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:n,unsafeLadder(e,n){let r=t.ZERO,o=e;for(;n>s;)n&i&&(r=r.add(o)),o=o.double(),n>>=i;return r},precomputeWindow(t,e){const{windows:n,windowSize:o}=r(e),s=[];let i=t,f=i;for(let t=0;t<n;t++){f=i,s.push(f);for(let t=1;t<o;t++)f=f.add(i),s.push(f);i=f.double()}return s},wNAF(e,o,s){const{windows:f,windowSize:a}=r(e);let c=t.ZERO,u=t.BASE;const h=BigInt(2**e-1),l=2**e,d=BigInt(e);for(let t=0;t<f;t++){const e=t*a;let r=Number(s&h);s>>=d,r>a&&(r-=l,s+=i);const f=e,p=e+Math.abs(r)-1,y=t%2!=0,g=r<0;0===r?u=u.add(n(y,o[f])):c=c.add(n(g,o[p]))}return{p:c,f:u}},wNAFCached(t,e,n,r){const o=t._WINDOW_SIZE||1;let s=e.get(t);return s||(s=this.precomputeWindow(t,o),1!==o&&e.set(t,r(s))),this.wNAF(o,s,n)}}}function a(t){return(0,r.OP)(t.Fp),(0,o.FF)(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,r.kK)(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}},748193:(t,e,n)=>{n.d(e,{OP:()=>g,PS:()=>E,U_:()=>p,Us:()=>B,gN:()=>w,kK:()=>b,oA:()=>d,wQ:()=>h});var r=n(880907);const o=BigInt(0),s=BigInt(1),i=BigInt(2),f=BigInt(3),a=BigInt(4),c=BigInt(5),u=BigInt(8);function h(t,e){const n=t%e;return n>=o?n:e+n}function l(t,e,n){if(n<=o||e<o)throw new Error("Expected power/modulo > 0");if(n===s)return o;let r=s;for(;e>o;)e&s&&(r=r*t%n),t=t*t%n,e>>=s;return r}function d(t,e,n){let r=t;for(;e-- >o;)r*=r,r%=n;return r}function p(t,e){if(t===o||e<=o)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=h(t,e),r=e,i=o,f=s,a=s,c=o;for(;n!==o;){const t=r/n,e=r%n,o=i-a*t,s=f-c*t;r=n,n=e,i=a,f=c,a=o,c=s}if(r!==s)throw new Error("invert: does not exist");return h(i,e)}BigInt(9),BigInt(16);const y=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function g(t){const e=y.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return(0,r.FF)(t,e)}function b(t,e){const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function w(t,e,n=!1,d={}){if(t<=o)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:y,nByteLength:g}=b(t,e);if(g>2048)throw new Error("Field lengths over 2048 bytes are not supported");const w=function(t){if(t%a===f){const e=(t+s)/a;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}if(t%u===c){const e=(t-c)/u;return function(t,n){const r=t.mul(n,i),o=t.pow(r,e),s=t.mul(n,o),f=t.mul(t.mul(s,i),o),a=t.mul(s,t.sub(f,t.ONE));if(!t.eql(t.sqr(a),n))throw new Error("Cannot find square root");return a}}return function(t){const e=(t-s)/i;let n,r,f;for(n=t-s,r=0;n%i===o;n/=i,r++);for(f=i;f<t&&l(f,e,t)!==t-s;f++);if(1===r){const e=(t+s)/a;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}const c=(n+s)/i;return function(t,o){if(t.pow(o,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let i=r,a=t.pow(t.mul(t.ONE,f),n),u=t.pow(o,c),h=t.pow(o,n);for(;!t.eql(h,t.ONE);){if(t.eql(h,t.ZERO))return t.ZERO;let e=1;for(let n=t.sqr(h);e<i&&!t.eql(n,t.ONE);e++)n=t.sqr(n);const n=t.pow(a,s<<BigInt(i-e-1));a=t.sqr(n),u=t.mul(u,n),h=t.mul(h,a),i=e}return u}}(t)}(t),m=Object.freeze({ORDER:t,BITS:y,BYTES:g,MASK:(0,r.dQ)(y),ZERO:o,ONE:s,create:e=>h(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return o<=e&&e<t},is0:t=>t===o,isOdd:t=>(t&s)===s,neg:e=>h(-e,t),eql:(t,e)=>t===e,sqr:e=>h(e*e,t),add:(e,n)=>h(e+n,t),sub:(e,n)=>h(e-n,t),mul:(e,n)=>h(e*n,t),pow:(t,e)=>function(t,e,n){if(n<o)throw new Error("Expected power > 0");if(n===o)return t.ONE;if(n===s)return e;let r=t.ONE,i=e;for(;n>o;)n&s&&(r=t.mul(r,i)),i=t.sqr(i),n>>=s;return r}(m,t,e),div:(e,n)=>h(e*p(n,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>p(e,t),sqrt:d.sqrt||(t=>w(m,t)),invertBatch:t=>function(t,e){const n=new Array(e.length),r=e.reduce(((e,r,o)=>t.is0(r)?e:(n[o]=e,t.mul(e,r))),t.ONE),o=t.inv(r);return e.reduceRight(((e,r,o)=>t.is0(r)?e:(n[o]=t.mul(e,n[o]),t.mul(e,r))),o),n}(m,t),cmov:(t,e,n)=>n?e:t,toBytes:t=>n?(0,r.S5)(t,g):(0,r.tL)(t,g),fromBytes:t=>{if(t.length!==g)throw new Error(`Fp.fromBytes: expected ${g}, got ${t.length}`);return n?(0,r.ty)(t):(0,r.bytesToNumberBE)(t)}});return Object.freeze(m)}function m(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function E(t){const e=m(t);return e+Math.ceil(e/2)}function B(t,e,n=!1){const o=t.length,i=m(e),f=E(e);if(o<16||o<f||o>1024)throw new Error(`expected ${f}-1024 bytes of input, got ${o}`);const a=h(n?(0,r.bytesToNumberBE)(t):(0,r.ty)(t),e-s)+s;return n?(0,r.S5)(a,i):(0,r.tL)(a,i)}},880907:(t,e,n)=>{n.d(e,{FF:()=>S,S5:()=>g,_t:()=>s,bytesToNumberBE:()=>d,ci:()=>a,dQ:()=>m,eV:()=>w,gk:()=>i,hexToBytes:()=>l,n$:()=>v,ql:()=>b,tL:()=>y,ty:()=>p});const r=BigInt(1),o=BigInt(2);function s(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}function i(t){if(!s(t))throw new Error("Uint8Array expected")}const f=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function a(t){i(t);let e="";for(let n=0;n<t.length;n++)e+=f[t[n]];return e}function c(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}const u={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function h(t){return t>=u._0&&t<=u._9?t-u._0:t>=u._A&&t<=u._F?t-(u._A-10):t>=u._a&&t<=u._f?t-(u._a-10):void 0}function l(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let e=0,o=0;e<n;e++,o+=2){const n=h(t.charCodeAt(o)),s=h(t.charCodeAt(o+1));if(void 0===n||void 0===s){const e=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+o)}r[e]=16*n+s}return r}function d(t){return c(a(t))}function p(t){return i(t),c(a(Uint8Array.from(t).reverse()))}function y(t,e){return l(t.toString(16).padStart(2*e,"0"))}function g(t,e){return y(t,e).reverse()}function b(t,e,n){let r;if("string"==typeof e)try{r=l(e)}catch(n){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${n}`)}else{if(!s(e))throw new Error(`${t} must be hex string or Uint8Array`);r=Uint8Array.from(e)}const o=r.length;if("number"==typeof n&&o!==n)throw new Error(`${t} expected ${n} bytes, got ${o}`);return r}function w(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];i(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n}const m=t=>(o<<BigInt(t-1))-r,E=t=>new Uint8Array(t),B=t=>Uint8Array.from(t);function v(t,e,n){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let r=E(t),o=E(t),s=0;const i=()=>{r.fill(1),o.fill(0),s=0},f=(...t)=>n(o,r,...t),a=(t=E())=>{o=f(B([0]),t),r=f(),0!==t.length&&(o=f(B([1]),t),r=f())},c=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const n=[];for(;t<e;){r=f();const e=r.slice();n.push(e),t+=r.length}return w(...n)};return(t,e)=>{let n;for(i(),a(t);!(n=e(c()));)a();return i(),n}}const x={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||s(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function S(t,e,n={}){const r=(e,n,r)=>{const o=x[n];if("function"!=typeof o)throw new Error(`Invalid validator "${n}", expected function`);const s=t[e];if(!(r&&void 0===s||o(s,t)))throw new Error(`Invalid param ${String(e)}=${s} (${typeof s}), expected ${n}`)};for(const[t,n]of Object.entries(e))r(t,n,!1);for(const[t,e]of Object.entries(n))r(t,e,!0);return t}},127743:(t,e,n)=>{n.d(e,{e4:()=>l});var r=n(529613),o=n(748193),s=n(880907);const{bytesToNumberBE:i,hexToBytes:f}=s,a={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(t){const{Err:e}=a;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(128&r[0])throw new e("Invalid signature integer: negative");if(0===r[0]&&!(128&r[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:i(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=a,n="string"==typeof t?f(t):t;s.gk(n);let r=n.length;if(r<2||48!=n[0])throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:o,l:i}=a._parseInt(n.subarray(2)),{d:c,l:u}=a._parseInt(i);if(u.length)throw new e("Invalid signature: left bytes after parsing");return{r:o,s:c}},hexFromSig(t){const e=t=>8&Number.parseInt(t[0],16)?"00"+t:t,n=t=>{const e=t.toString(16);return 1&e.length?`0${e}`:e},r=e(n(t.s)),o=e(n(t.r)),s=r.length/2,i=o.length/2,f=n(s),a=n(i);return`30${n(i+s+4)}02${a}${o}02${f}${r}`}},c=BigInt(0),u=BigInt(1),h=(BigInt(2),BigInt(3));function l(t){const e=function(t){const e=(0,r.K)(t);return s.FF(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:n,n:i}=e,f=n.BYTES+1,l=2*n.BYTES+1;function d(t){return o.wQ(t,i)}function p(t){return o.U_(t,i)}const{ProjectivePoint:y,normPrivateKeyToScalar:g,weierstrassEquation:b,isWithinCurveOrder:w}=function(t){const e=function(t){const e=(0,r.K)(t);s.FF(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:o,a:i}=e;if(n){if(!o.eql(i,o.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:n}=e,i=e.toBytes||((t,e,r)=>{const o=e.toAffine();return s.eV(Uint8Array.from([4]),n.toBytes(o.x),n.toBytes(o.y))}),f=e.fromBytes||(t=>{const e=t.subarray(1);return{x:n.fromBytes(e.subarray(0,n.BYTES)),y:n.fromBytes(e.subarray(n.BYTES,2*n.BYTES))}});function a(t){const{a:r,b:o}=e,s=n.sqr(t),i=n.mul(s,t);return n.add(n.add(i,n.mul(t,r)),o)}if(!n.eql(n.sqr(e.Gy),a(e.Gx)))throw new Error("bad generator point: equation left != right");function l(t){return"bigint"==typeof t&&c<t&&t<e.n}function d(t){if(!l(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function p(t){const{allowedPrivateKeyLengths:n,nByteLength:r,wrapPrivateKey:i,n:f}=e;if(n&&"bigint"!=typeof t){if(s._t(t)&&(t=s.ci(t)),"string"!=typeof t||!n.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*r,"0")}let a;try{a="bigint"==typeof t?t:s.bytesToNumberBE((0,s.ql)("private key",t,r))}catch(e){throw new Error(`private key must be ${r} bytes, hex or bigint, not ${typeof t}`)}return i&&(a=o.wQ(a,f)),d(a),a}const y=new Map;function g(t){if(!(t instanceof b))throw new Error("ProjectivePoint expected")}class b{constructor(t,e,r){if(this.px=t,this.py=e,this.pz=r,null==t||!n.isValid(t))throw new Error("x required");if(null==e||!n.isValid(e))throw new Error("y required");if(null==r||!n.isValid(r))throw new Error("z required")}static fromAffine(t){const{x:e,y:r}=t||{};if(!t||!n.isValid(e)||!n.isValid(r))throw new Error("invalid affine point");if(t instanceof b)throw new Error("projective point not allowed");const o=t=>n.eql(t,n.ZERO);return o(e)&&o(r)?b.ZERO:new b(e,r,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=n.invertBatch(t.map((t=>t.pz)));return t.map(((t,n)=>t.toAffine(e[n]))).map(b.fromAffine)}static fromHex(t){const e=b.fromAffine(f((0,s.ql)("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return b.BASE.multiply(p(t))}_setWindowSize(t){this._WINDOW_SIZE=t,y.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:t,y:r}=this.toAffine();if(!n.isValid(t)||!n.isValid(r))throw new Error("bad point: x or y not FE");const o=n.sqr(r),s=a(t);if(!n.eql(o,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(n.isOdd)return!n.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){g(t);const{px:e,py:r,pz:o}=this,{px:s,py:i,pz:f}=t,a=n.eql(n.mul(e,f),n.mul(s,o)),c=n.eql(n.mul(r,f),n.mul(i,o));return a&&c}negate(){return new b(this.px,n.neg(this.py),this.pz)}double(){const{a:t,b:r}=e,o=n.mul(r,h),{px:s,py:i,pz:f}=this;let a=n.ZERO,c=n.ZERO,u=n.ZERO,l=n.mul(s,s),d=n.mul(i,i),p=n.mul(f,f),y=n.mul(s,i);return y=n.add(y,y),u=n.mul(s,f),u=n.add(u,u),a=n.mul(t,u),c=n.mul(o,p),c=n.add(a,c),a=n.sub(d,c),c=n.add(d,c),c=n.mul(a,c),a=n.mul(y,a),u=n.mul(o,u),p=n.mul(t,p),y=n.sub(l,p),y=n.mul(t,y),y=n.add(y,u),u=n.add(l,l),l=n.add(u,l),l=n.add(l,p),l=n.mul(l,y),c=n.add(c,l),p=n.mul(i,f),p=n.add(p,p),l=n.mul(p,y),a=n.sub(a,l),u=n.mul(p,d),u=n.add(u,u),u=n.add(u,u),new b(a,c,u)}add(t){g(t);const{px:r,py:o,pz:s}=this,{px:i,py:f,pz:a}=t;let c=n.ZERO,u=n.ZERO,l=n.ZERO;const d=e.a,p=n.mul(e.b,h);let y=n.mul(r,i),w=n.mul(o,f),m=n.mul(s,a),E=n.add(r,o),B=n.add(i,f);E=n.mul(E,B),B=n.add(y,w),E=n.sub(E,B),B=n.add(r,s);let v=n.add(i,a);return B=n.mul(B,v),v=n.add(y,m),B=n.sub(B,v),v=n.add(o,s),c=n.add(f,a),v=n.mul(v,c),c=n.add(w,m),v=n.sub(v,c),l=n.mul(d,B),c=n.mul(p,m),l=n.add(c,l),c=n.sub(w,l),l=n.add(w,l),u=n.mul(c,l),w=n.add(y,y),w=n.add(w,y),m=n.mul(d,m),B=n.mul(p,B),w=n.add(w,m),m=n.sub(y,m),m=n.mul(d,m),B=n.add(B,m),y=n.mul(w,B),u=n.add(u,y),y=n.mul(v,B),c=n.mul(E,c),c=n.sub(c,y),y=n.mul(E,w),l=n.mul(v,l),l=n.add(l,y),new b(c,u,l)}subtract(t){return this.add(t.negate())}is0(){return this.equals(b.ZERO)}wNAF(t){return m.wNAFCached(this,y,t,(t=>{const e=n.invertBatch(t.map((t=>t.pz)));return t.map(((t,n)=>t.toAffine(e[n]))).map(b.fromAffine)}))}multiplyUnsafe(t){const r=b.ZERO;if(t===c)return r;if(d(t),t===u)return this;const{endo:o}=e;if(!o)return m.unsafeLadder(this,t);let{k1neg:s,k1:i,k2neg:f,k2:a}=o.splitScalar(t),h=r,l=r,p=this;for(;i>c||a>c;)i&u&&(h=h.add(p)),a&u&&(l=l.add(p)),p=p.double(),i>>=u,a>>=u;return s&&(h=h.negate()),f&&(l=l.negate()),l=new b(n.mul(l.px,o.beta),l.py,l.pz),h.add(l)}multiply(t){d(t);let r,o,s=t;const{endo:i}=e;if(i){const{k1neg:t,k1:e,k2neg:f,k2:a}=i.splitScalar(s);let{p:c,f:u}=this.wNAF(e),{p:h,f:l}=this.wNAF(a);c=m.constTimeNegate(t,c),h=m.constTimeNegate(f,h),h=new b(n.mul(h.px,i.beta),h.py,h.pz),r=c.add(h),o=u.add(l)}else{const{p:t,f:e}=this.wNAF(s);r=t,o=e}return b.normalizeZ([r,o])[0]}multiplyAndAddUnsafe(t,e,n){const r=b.BASE,o=(t,e)=>e!==c&&e!==u&&t.equals(r)?t.multiply(e):t.multiplyUnsafe(e),s=o(this,e).add(o(t,n));return s.is0()?void 0:s}toAffine(t){const{px:e,py:r,pz:o}=this,s=this.is0();null==t&&(t=s?n.ONE:n.inv(o));const i=n.mul(e,t),f=n.mul(r,t),a=n.mul(o,t);if(s)return{x:n.ZERO,y:n.ZERO};if(!n.eql(a,n.ONE))throw new Error("invZ was invalid");return{x:i,y:f}}isTorsionFree(){const{h:t,isTorsionFree:n}=e;if(t===u)return!0;if(n)return n(b,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:n}=e;return t===u?this:n?n(b,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),i(b,this,t)}toHex(t=!0){return s.ci(this.toRawBytes(t))}}b.BASE=new b(e.Gx,e.Gy,n.ONE),b.ZERO=new b(n.ZERO,n.ONE,n.ZERO);const w=e.nBitLength,m=(0,r.M)(b,e.endo?Math.ceil(w/2):w);return{CURVE:e,ProjectivePoint:b,normPrivateKeyToScalar:p,weierstrassEquation:a,isWithinCurveOrder:l}}({...e,toBytes(t,e,r){const o=e.toAffine(),i=n.toBytes(o.x),f=s.eV;return r?f(Uint8Array.from([e.hasEvenY()?2:3]),i):f(Uint8Array.from([4]),i,n.toBytes(o.y))},fromBytes(t){const e=t.length,r=t[0],o=t.subarray(1);if(e!==f||2!==r&&3!==r){if(e===l&&4===r)return{x:n.fromBytes(o.subarray(0,n.BYTES)),y:n.fromBytes(o.subarray(n.BYTES,2*n.BYTES))};throw new Error(`Point of length ${e} was invalid. Expected ${f} compressed bytes or ${l} uncompressed bytes`)}{const t=s.bytesToNumberBE(o);if(!(c<(i=t)&&i<n.ORDER))throw new Error("Point is not on curve");const e=b(t);let f;try{f=n.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+e)}return 1==(1&r)!=((f&u)===u)&&(f=n.neg(f)),{x:t,y:f}}var i}}),m=t=>s.ci(s.tL(t,e.nByteLength));function E(t){return t>i>>u}const B=(t,e,n)=>s.bytesToNumberBE(t.slice(e,n));class v{constructor(t,e,n){this.r=t,this.s=e,this.recovery=n,this.assertValidity()}static fromCompact(t){const n=e.nByteLength;return t=(0,s.ql)("compactSignature",t,2*n),new v(B(t,0,n),B(t,n,2*n))}static fromDER(t){const{r:e,s:n}=a.toSig((0,s.ql)("DER",t));return new v(e,n)}assertValidity(){if(!w(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!w(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new v(this.r,this.s,t)}recoverPublicKey(t){const{r,s:o,recovery:i}=this,f=A((0,s.ql)("msgHash",t));if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");const a=2===i||3===i?r+e.n:r;if(a>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const c=0==(1&i)?"02":"03",u=y.fromHex(c+m(a)),h=p(a),l=d(-f*h),g=d(o*h),b=y.BASE.multiplyAndAddUnsafe(u,l,g);if(!b)throw new Error("point at infinify");return b.assertValidity(),b}hasHighS(){return E(this.s)}normalizeS(){return this.hasHighS()?new v(this.r,d(-this.s),this.recovery):this}toDERRawBytes(){return s.hexToBytes(this.toDERHex())}toDERHex(){return a.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return s.hexToBytes(this.toCompactHex())}toCompactHex(){return m(this.r)+m(this.s)}}const x={isValidPrivateKey(t){try{return g(t),!0}catch(t){return!1}},normPrivateKeyToScalar:g,randomPrivateKey:()=>{const t=o.PS(e.n);return o.Us(e.randomBytes(t),e.n)},precompute:(t=8,e=y.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function S(t){const e=s._t(t),n="string"==typeof t,r=(e||n)&&t.length;return e?r===f||r===l:n?r===2*f||r===2*l:t instanceof y}const I=e.bits2int||function(t){const n=s.bytesToNumberBE(t),r=8*t.length-e.nBitLength;return r>0?n>>BigInt(r):n},A=e.bits2int_modN||function(t){return d(I(t))},O=s.dQ(e.nBitLength);function _(t){if("bigint"!=typeof t)throw new Error("bigint expected");if(!(c<=t&&t<O))throw new Error(`bigint expected < 2^${e.nBitLength}`);return s.tL(t,e.nByteLength)}const R={lowS:e.lowS,prehash:!1},F={lowS:e.lowS,prehash:!1};return y.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return y.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,n=!0){if(S(t))throw new Error("first arg must be private key");if(!S(e))throw new Error("second arg must be public key");return y.fromHex(e).multiply(g(t)).toRawBytes(n)},sign:function(t,r,o=R){const{seed:i,k2sig:f}=function(t,r,o=R){if(["recovered","canonical"].some((t=>t in o)))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:f}=e;let{lowS:a,prehash:h,extraEntropy:l}=o;null==a&&(a=!0),t=(0,s.ql)("msgHash",t),h&&(t=(0,s.ql)("prehashed msgHash",i(t)));const b=A(t),m=g(r),B=[_(m),_(b)];if(null!=l&&!1!==l){const t=!0===l?f(n.BYTES):l;B.push((0,s.ql)("extraEntropy",t))}const x=s.eV(...B),S=b;return{seed:x,k2sig:function(t){const e=I(t);if(!w(e))return;const n=p(e),r=y.BASE.multiply(e).toAffine(),o=d(r.x);if(o===c)return;const s=d(n*d(S+o*m));if(s===c)return;let i=(r.x===o?0:2)|Number(r.y&u),f=s;return a&&E(s)&&(f=function(t){return E(t)?d(-t):t}(s),i^=1),new v(o,f,i)}}}(t,r,o),a=e;return s.n$(a.hash.outputLen,a.nByteLength,a.hmac)(i,f)},verify:function(t,n,r,o=F){const i=t;if(n=(0,s.ql)("msgHash",n),r=(0,s.ql)("publicKey",r),"strict"in o)throw new Error("options.strict was renamed to lowS");const{lowS:f,prehash:c}=o;let u,h;try{if("string"==typeof i||s._t(i))try{u=v.fromDER(i)}catch(t){if(!(t instanceof a.Err))throw t;u=v.fromCompact(i)}else{if("object"!=typeof i||"bigint"!=typeof i.r||"bigint"!=typeof i.s)throw new Error("PARSE");{const{r:t,s:e}=i;u=new v(t,e)}}h=y.fromHex(r)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(f&&u.hasHighS())return!1;c&&(n=e.hash(n));const{r:l,s:g}=u,b=A(n),w=p(g),m=d(b*w),E=d(l*w),B=y.BASE.multiplyAndAddUnsafe(h,m,E)?.toAffine();return!!B&&d(B.x)===l},ProjectivePoint:y,Signature:v,utils:x}}BigInt(4)},80411:(t,e,n)=>{n.d(e,{kA:()=>l});var r=n(493476),o=n(757226),s=n(748193);const i=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),f=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),a=BigInt(1),c=BigInt(2),u=(t,e)=>(t+e/c)/e;const h=(0,s.gN)(i,void 0,void 0,{sqrt:function(t){const e=i,n=BigInt(3),r=BigInt(6),o=BigInt(11),f=BigInt(22),a=BigInt(23),u=BigInt(44),l=BigInt(88),d=t*t*t%e,p=d*d*t%e,y=(0,s.oA)(p,n,e)*p%e,g=(0,s.oA)(y,n,e)*p%e,b=(0,s.oA)(g,c,e)*d%e,w=(0,s.oA)(b,o,e)*b%e,m=(0,s.oA)(w,f,e)*w%e,E=(0,s.oA)(m,u,e)*m%e,B=(0,s.oA)(E,l,e)*E%e,v=(0,s.oA)(B,u,e)*m%e,x=(0,s.oA)(v,n,e)*p%e,S=(0,s.oA)(x,a,e)*w%e,I=(0,s.oA)(S,r,e)*d%e,A=(0,s.oA)(I,c,e);if(!h.eql(h.sqr(A),t))throw new Error("Cannot find square root");return A}}),l=(0,o._)({a:BigInt(0),b:BigInt(7),Fp:h,n:f,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=f,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-a*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=n,c=BigInt("0x100000000000000000000000000000000"),h=u(i*t,e),l=u(-r*t,e);let d=(0,s.wQ)(t-h*n-l*o,e),p=(0,s.wQ)(-h*r-l*i,e);const y=d>c,g=p>c;if(y&&(d=e-d),g&&(p=e-p),d>c||p>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:y,k1:d,k2neg:g,k2:p}}}},r.J);BigInt(0),l.ProjectivePoint},116830:(t,e,n)=>{function r(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`positive integer expected, not ${t}`)}function o(t,...e){if(!((n=t)instanceof Uint8Array||null!=n&&"object"==typeof n&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(e.length>0&&!e.includes(t.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}function s(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");r(t.outputLen),r(t.blockLen)}function i(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function f(t,e){o(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}n.d(e,{Gg:()=>i,J8:()=>f,aI:()=>o,vp:()=>s})},294008:(t,e,n)=>{n.d(e,{VR:()=>f,bc:()=>s,l3:()=>i});var r=n(116830),o=n(467222);const s=(t,e,n)=>t&e^~t&n,i=(t,e,n)=>t&e^t&n^e&n;class f extends o.kb{constructor(t,e,n,r){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=(0,o.GL)(this.buffer)}update(t){(0,r.Gg)(this);const{view:e,buffer:n,blockLen:s}=this,i=(t=(0,o.O0)(t)).length;for(let r=0;r<i;){const f=Math.min(s-this.pos,i-r);if(f!==s)n.set(t.subarray(r,r+f),this.pos),this.pos+=f,r+=f,this.pos===s&&(this.process(e,0),this.pos=0);else{const e=(0,o.GL)(t);for(;s<=i-r;r+=s)this.process(e,r)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){(0,r.Gg)(this),(0,r.J8)(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:s,isLE:i}=this;let{pos:f}=this;e[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>s-f&&(this.process(n,0),f=0);for(let t=f;t<s;t++)e[t]=0;!function(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),i=Number(n>>o&s),f=Number(n&s),a=r?4:0,c=r?0:4;t.setUint32(e+a,i,r),t.setUint32(e+c,f,r)}(n,s-8,BigInt(8*this.length),i),this.process(n,0);const a=(0,o.GL)(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,h=this.get();if(u>h.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<u;t++)a.setUint32(4*t,h[t],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:o,destroyed:s,pos:i}=this;return t.length=r,t.pos=i,t.finished=o,t.destroyed=s,r%e&&t.buffer.set(n),t}}},805826:(t,e,n)=>{n.d(e,{e:()=>r});const r="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},563682:(t,e,n)=>{n.d(e,{b:()=>i});var r=n(116830),o=n(467222);class s extends o.kb{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,(0,r.vp)(t);const n=(0,o.O0)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(n.length>s?t.create().update(n).digest():n);for(let t=0;t<i.length;t++)i[t]^=54;this.iHash.update(i),this.oHash=t.create();for(let t=0;t<i.length;t++)i[t]^=106;this.oHash.update(i),i.fill(0)}update(t){return(0,r.Gg)(this),this.iHash.update(t),this}digestInto(t){(0,r.Gg)(this),(0,r.aI)(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:o,blockLen:s,outputLen:i}=this;return t.finished=r,t.destroyed=o,t.blockLen=s,t.outputLen=i,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const i=(t,e,n)=>new s(t,e).update(n).digest();i.create=(t,e)=>new s(t,e)},493476:(t,e,n)=>{n.d(e,{J:()=>c});var r=n(294008),o=n(467222);const s=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),i=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),f=new Uint32Array(64);class a extends r.VR{constructor(){super(64,32,8,!1),this.A=0|i[0],this.B=0|i[1],this.C=0|i[2],this.D=0|i[3],this.E=0|i[4],this.F=0|i[5],this.G=0|i[6],this.H=0|i[7]}get(){const{A:t,B:e,C:n,D:r,E:o,F:s,G:i,H:f}=this;return[t,e,n,r,o,s,i,f]}set(t,e,n,r,o,s,i,f){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|o,this.F=0|s,this.G=0|i,this.H=0|f}process(t,e){for(let n=0;n<16;n++,e+=4)f[n]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=f[t-15],n=f[t-2],r=(0,o.np)(e,7)^(0,o.np)(e,18)^e>>>3,s=(0,o.np)(n,17)^(0,o.np)(n,19)^n>>>10;f[t]=s+f[t-7]+r+f[t-16]|0}let{A:n,B:i,C:a,D:c,E:u,F:h,G:l,H:d}=this;for(let t=0;t<64;t++){const e=d+((0,o.np)(u,6)^(0,o.np)(u,11)^(0,o.np)(u,25))+(0,r.bc)(u,h,l)+s[t]+f[t]|0,p=((0,o.np)(n,2)^(0,o.np)(n,13)^(0,o.np)(n,22))+(0,r.l3)(n,i,a)|0;d=l,l=h,h=u,u=c+e|0,c=a,a=i,i=n,n=e+p|0}n=n+this.A|0,i=i+this.B|0,a=a+this.C|0,c=c+this.D|0,u=u+this.E|0,h=h+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(n,i,a,c,u,h,l,d)}roundClean(){f.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const c=(0,o.hE)((()=>new a))},467222:(t,e,n)=>{n.d(e,{GL:()=>s,O0:()=>f,O6:()=>h,eV:()=>a,hE:()=>u,kb:()=>c,np:()=>i});var r=n(805826),o=n(116830);const s=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),i=(t,e)=>t<<32-e|t>>>e;function f(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),(0,o.aI)(t),t}function a(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];(0,o.aI)(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n}new Uint8Array(new Uint32Array([287454020]).buffer)[0];class c{clone(){return this._cloneInto()}}function u(t){const e=e=>t().update(f(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function h(t=32){if(r.e&&"function"==typeof r.e.getRandomValues)return r.e.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}}}]);