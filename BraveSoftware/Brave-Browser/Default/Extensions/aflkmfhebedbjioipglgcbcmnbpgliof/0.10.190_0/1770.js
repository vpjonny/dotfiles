"use strict";(globalThis.webpackChunk_coral_xyz_app_extension=globalThis.webpackChunk_coral_xyz_app_extension||[]).push([[1770],{831770:(t,e,a)=>{a.d(e,{LiFiClient:()=>g});var n=a(883739),o=a(602267),s=a(817967),i=a(861326),r=a(627158),c=a(759813),u=a(71093),f=a(313929),d=a(639460),h=a(733748);const l=["function approve(address spender, uint256 amount) public returns (bool)","function allowance(address owner, address spender) public view returns (uint256)"],w=["0x0000000000000000000000000000000000000000","0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee","0x0000000000000000000000000000000000001010"];BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");var m=a(348834).Buffer;const p="https://lifi.workers.madlads.com";class g{blockChainClientMap;activeBlockchainIds;quoteMetadata={};inFlightRequests=new Map;outputTokensCache=new Map;outputTokensInFlightRequests=new Map;constructor(t,e){this.activeBlockchainIds=[];const a=(0,n.AF)(e),o=Object.fromEntries(Object.entries(a).filter((([t,e])=>void 0!==e.lifiChainId)));this.activeBlockchainIds=Object.keys(o),this.blockChainClientMap={};for(const[e,a]of Object.entries(o))try{this.blockChainClientMap[e]=(0,h.G)(t,a)}catch(t){console.error(`Failed to create client for ${e}:`,t)}}getLiFiChainId(t){const e=this.blockChainClientMap[t];if(!e)throw new Error(`Blockchain client not found for chain: ${t}`);const a=e.networkConfig.lifiChainId;if(!a)throw new Error(`LiFi chain ID not found for chain: ${t}`);return a}async getOutputTokens(t,e,a){const n=`${t}-${e}-${a}`,o=this.outputTokensCache.get(n);if(o)return o;const s=this.outputTokensInFlightRequests.get(n);if(s)return s;const i=(async()=>{try{const o=this.getLiFiChainId(t),s=this.getLiFiChainId(a),i=await fetch(`${p}/connections?`+new URLSearchParams({fromChain:o.toString(),toChain:s.toString(),fromToken:e,allowSwitchChain:"false",allowDestinationCall:"false"}));if(!i.ok)throw new Error(`LiFi API error: ${i.statusText}`);const r=await i.json(),c=[],u=new Set;return r.connections?.forEach((t=>{t.toTokens?.forEach((t=>{t.address&&!u.has(t.address)&&(u.add(t.address),c.push(t.address))}))})),this.outputTokensCache.set(n,c),c}finally{this.outputTokensInFlightRequests.delete(n)}})();return this.outputTokensInFlightRequests.set(n,i),i}async getQuote(t){const e=`${t.srcChain}-${t.srcToken}-${t.dstChain}-${t.dstToken}-${t.amount}-${t.slippage||.01}-${t.order||""}`,a=this.inFlightRequests.get(e);if(a)return a;const n=this.getLiFiChainId(t.srcChain),o=this.getLiFiChainId(t.dstChain),s=(async()=>{try{const e=new URLSearchParams({fromChain:n.toString(),toChain:o.toString(),fromToken:t.srcToken,toToken:t.dstToken,fromAmount:t.amount,fromAddress:t.srcAddress,toAddress:t.dstAddress||t.srcAddress,slippage:(t.slippage||.01).toString()});t.order&&e.set("order",t.order);const a=await fetch(`${p}/quote?${e}`),s=await a.json();if(1002===s.code||s.message?.includes("No available quotes"))throw new Error("No routes found. Try a larger amount.");if(!a.ok)throw new Error(`LiFi API error: ${a.status} ${a.statusText} - ${JSON.stringify(s)}`);const i=s,r=(0,d.Z)();return this.quoteMetadata[r]={quote:i},{quoteId:r,quote:{outAmount:i.estimate.toAmount,sourceToken:{token:i.action.fromToken.address,amount:i.action.fromAmount,chainId:t.srcChain},destinationToken:{token:i.action.toToken.address,amount:i.estimate.toAmount,chainId:t.dstChain},estimate:{fromAmount:i.action.fromAmount,toAmount:i.estimate.toAmount,toAmountMin:i.estimate.toAmountMin,approvalAddress:i.estimate.approvalAddress,executionDuration:i.estimate.executionDuration||0,feeCosts:i.estimate.feeCosts||[],gasCosts:i.estimate.gasCosts||[],fromAmountUSD:i.estimate.fromAmountUSD,toAmountUSD:i.estimate.toAmountUSD},toolDetails:i.toolDetails}}}finally{this.inFlightRequests.delete(e)}})();return this.inFlightRequests.set(e,s),s}async executeSwap(t){let e=t.quoteId;e&&this.quoteMetadata[e]||(e=(await this.getQuote(t)).quoteId);const a=this.quoteMetadata[e];if(!a)throw new Error("Quote not found. Please request a new quote.");const n=a.quote,o=this.blockChainClientMap[t.srcChain];if(!o)throw new Error(`No client available for chain ${t.srcChain}`);const i=t.srcChain===s.Ek.SOLANA_MAINNET,r=t.srcChain===s.Ek.SUI_MAINNET||t.srcChain===s.Ek.SUI_DEVNET;i||r||await this.handleEVMApproval(o,t,n.estimate?.approvalAddress);const c=n.transactionRequest;if(!c)throw new Error("No transaction data found in quote");const u=await this.executeTransaction(t.srcChain,o,t.srcAddress,c);if(!u)throw new Error("Failed to get transaction hash from execution");return{txid:u,srcChain:t.srcChain,dstChain:t.dstChain,amount:t.amount,srcToken:t.srcToken,dstToken:t.dstToken,quoteId:e}}async executeTransaction(t,e,a,n){switch(t){case s.Ek.SOLANA_MAINNET:return await this.executeSolanaTransaction(e,a,n);case s.Ek.SUI_MAINNET:case s.Ek.SUI_DEVNET:return await this.executeSuiTransaction(e,a,n);default:return await this.executeEVMTransaction(e,a,n)}}async handleEVMApproval(t,e,a){const n=w.includes(e.srcToken.toLowerCase());if(!a||n)return;const o=t.getSigner(e.srcAddress),s=new c.CH(e.srcToken,l,o),i=await s.allowance(e.srcAddress,a),r=BigInt(e.amount);if(i<r){const e=await s.approve(a,r);await t.confirmTransaction(e.hash)}}async executeSolanaTransaction(t,e,a){const n=a;if(!n.data)throw new Error("No transaction data found for Solana swap");const o=m.from(n.data,"base64"),s=(()=>{try{return r.VersionedTransaction.deserialize(o)}catch{return r.Transaction.from(o)}})();return(await t.wallet.signAndSendTransaction({publicKey:(0,i.u)(e),tx:s})).txHash}async executeSuiTransaction(t,e,a){const n=a;if(!n.data)throw new Error("No transaction data found for Sui swap");const s=f.Y.from(n.data);s.setSenderIfNotSet(e);const i=await s.build({client:t.getProvider()}),r=(0,u.s3)(i),{signature:c,tx:d}=await(0,o.W)(t.signTransaction({tx:r,publicKey:e,blockchainId:t.networkConfig.blockchainId}));return(await t.executeTransaction({transactionBlock:d,signature:c,requestType:"WaitForLocalExecution"})).digest}async executeEVMTransaction(t,e,a){const n=t.getSigner(e),o={to:a.to,data:a.data,value:a.value,gasLimit:a.gasLimit,gasPrice:a.gasPrice};a.maxFeePerGas&&(o.maxFeePerGas=a.maxFeePerGas),a.maxPriorityFeePerGas&&(o.maxPriorityFeePerGas=a.maxPriorityFeePerGas);const s=await n.sendTransaction(o),i=s.hash;try{const t=await s.wait();if(0===t?.status)throw new Error("Swap failed. This may be due to price movement (slippage), insufficient liquidity, or the quote expired. Please try again.");return i}catch(t){if("CALL_EXCEPTION"===t?.code)throw new Error("Swap failed on-chain. This is usually caused by price slippage exceeding your tolerance, insufficient liquidity, or an expired quote. Please try again with a fresh quote.");throw t}}}}}]);