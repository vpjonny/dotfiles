"use strict";(globalThis.webpackChunk_coral_xyz_app_extension=globalThis.webpackChunk_coral_xyz_app_extension||[]).push([[2726],{772726:(t,n,e)=>{e.d(n,{Iz:()=>G,V0:()=>V,aH:()=>K,eC:()=>F,jH:()=>b,mD:()=>J,qC:()=>S,vB:()=>B});var o=["int","uint","bytes","array","switch"],r="big",i=6,s=t=>"number"==typeof t||"bigint"==typeof t,l=t=>t instanceof Uint8Array,a=t=>s(t)||l(t),f=t=>o.includes(t?.binary),u=t=>l(t?.from),c=t=>(t=>(t=>"number"==typeof t?.from)(t)||(t=>"bigint"==typeof t?.from)(t))(t)||u(t),h=(t,n)=>{if(t!==n)throw new Error(`size mismatch: layout size: ${t}, data size: ${n}`);return n},g=(t,n)=>"size"in t&&void 0!==t.size?h(t.size,n):n,m=(t,n)=>{if(t!=n)throw new Error(`value mismatch: (constant) layout value: ${t}, data value: ${n}`)},y=(t,n,e)=>{const o=(t,n)=>void 0===n?[0,t.length]:Array.isArray(n)?n:[n,t.length],[r,i]=o(t,e?.customSlice),[s,l]=o(n,e?.dataSlize);h(i-r,l-s);for(let e=0;e<t.length;++e)if(t[e+r]!==n[e+s])throw new Error(`binary data mismatch: layout value: ${t}, offset: ${r}, data value: ${n}, offset: ${s}`)};function d(t,n){const e=n[t.idTag??"id"];return t.layouts.find((([t])=>(Array.isArray(t)?t[1]:t)==e))}function b(t){return p(t,w)}var w=Symbol("staticCalc");function z(t,n,e){const o=t=>(void 0!==e&&e.push(t),t);switch(t.binary){case"int":case"uint":return t.size;case"bytes":{const r="lengthSize"in t?0|t.lengthSize:0;if("layout"in t){const{custom:i}=t,s=p(t.layout,void 0===i?n:"function"==typeof i.from?n!==w?o(i.from(n)):w:i.from,e);return null===s?"size"in t?t.size??null:null:r+g(t,s)}const{custom:i}=t;return l(i)?r+i.length:u(i)?r+i.from.length:void 0===i?n!==w?r+g(t,n.length):null:n!==w?r+g(t,o(i.from(n)).length):null}case"array":{const o="length"in t?t.length:void 0;if(n===w){if(void 0!==o){const n=p(t.layout,w,e);return null!==n?o*n:null}return null}let r=0;if(void 0!==o&&o!==n.length)throw new Error(`array length mismatch: layout length: ${o}, data length: ${n.length}`);"lengthSize"in t&&void 0!==t.lengthSize&&(r+=t.lengthSize);for(let o=0;o<n.length;++o){const i=p(t.layout,n[o],e);if(null===i)return null;r+=i}return r}case"switch":{if(n!==w){const[o,r]=d(t,n),i=p(r,n,e);return null!==i?t.idSize+i:null}let o=null;for(const[n,r]of t.layouts){const t=p(r,w,e);if(null===o)o=t;else if(t!==o)return null}return t.idSize+o}}}function p(t,n,e){if(f(t))return z(t,n,e);let o=0;for(const r of t){let t;if(n===w)t=w;else if(!("omit"in r)||!r.omit){if(!(r.name in n))throw new Error(`missing data for layout item: ${r.name}`);t=n[r.name]}const i=z(r,t,e);if(null===i){if(n!==w)throw new Error(`coding error: couldn't calculate size for layout item: ${r.name}`);return null}o+=i}return o}var v=(t,n)=>{t.bytes.set(n,t.offset),t.offset+=n.length},$=t=>t.bytesConversions[t.position++];function S(t,n,e){const[o,r]=function(t,n){const e=[],o=p(t,n,e);if(null===o)throw new Error(`coding error: couldn't calculate layout size for layout ${t} with data ${n}`);return[o,e]}(t,n),i={bytes:e??new Uint8Array(o),offset:0};if(I(t,n,i,{bytesConversions:r,position:0}),!e&&i.offset!==i.bytes.length)throw new Error(`encoded data is shorter than expected: ${i.bytes.length} > ${i.offset}`);return e?i.offset:i.bytes}var E=2**(8*i);function A(t,n,e,o=r,s=!1){if(!s&&t<0)throw new Error(`Value ${t} is negative but unsigned`);if("number"==typeof t){if(!Number.isInteger(t))throw new Error(`Value ${t} is not an integer`);if(n>i){if(t>=E)throw new Error(`Value ${t} is too large to be safely converted into an integer`);if(s&&t<-E)throw new Error(`Value ${t} is too small to be safely converted into an integer`)}}const l=2n**BigInt(8*n-(s?1:0));if(t>=l)throw new Error(`Value ${t} is too large for ${n} bytes`);if(s&&t<-l)throw new Error(`Value ${t} is too small for ${n} bytes`);for(let r=0;r<n;++r)e.bytes[e.offset+r]=Number(BigInt(t)>>BigInt(8*("big"===o?n-r-1:r))&0xffn);e.offset+=n}function I(t,n,e,o){if(f(t))M(t,n,e,o);else for(const r of t)try{M(r,n[r.name],e,o)}catch(t){throw t.message=`when serializing item '${r.name}': ${t.message}`,t}}function M(t,n,e,o){switch(t.binary){case"int":case"uint":A(s(t.custom)?("omit"in t&&t.omit||m(t.custom,n),t.custom):s(t?.custom?.from)?t.custom.from:void 0!==t.custom?t.custom.from(n):n,t.size,e,t.endianness,"int"===t.binary);break;case"bytes":{const r=e.offset;if("lengthSize"in t&&void 0!==t.lengthSize&&(e.offset+=t.lengthSize),"layout"in t){const{custom:r}=t;let i;i=void 0===r?n:"function"!=typeof r.from?r.from:$(o),I(t.layout,i,e,o)}else{const{custom:r}=t;l(r)?("omit"in t&&t.omit||y(r,n),v(e,r)):u(r)?v(e,r.from):v(e,void 0!==r?$(o):n)}if("lengthSize"in t&&void 0!==t.lengthSize){const n=e.offset-r-t.lengthSize,o=e.offset;e.offset=r,A(n,t.lengthSize,e,t.lengthEndianness),e.offset=o}else g(t,e.offset-r);break}case"array":if("length"in t&&t.length!==n.length)throw new Error(`array length mismatch: layout length: ${t.length}, data length: ${n.length}`);"lengthSize"in t&&void 0!==t.lengthSize&&A(n.length,t.lengthSize,e,t.lengthEndianness);for(let r=0;r<n.length;++r)I(t.layout,n[r],e,o);break;case"switch":{const[r,i]=d(t,n);A(Array.isArray(r)?r[0]:r,t.idSize,e,t.idEndianness),I(i,n,e,o);break}}}function x(t){const n=t.custom;if(!("cachedSerializedFrom"in n)&&(n.cachedSerializedFrom=S(t.layout,n.from),"size"in t&&void 0!==t.size&&t.size!==n.cachedSerializedFrom.length))throw new Error("Layout specification error: custom.from does not serialize to specified size");return n.cachedSerializedFrom}function B(t,n,e){const o=e??!0,r={bytes:n,offset:0,end:n.length},i=C(t,r);if(o&&r.offset!==r.end)throw new Error(`encoded data is longer than expected: ${r.end} > ${r.offset}`);return o?i:[i,r.offset]}function k(t,n){const e=t.offset+n;if(e>t.end)throw new Error(`chunk is shorter than expected: ${t.end} < ${e}`);t.offset=e}function C(t,n){if(!Array.isArray(t))return U(t,n);let e={};for(const o of t)try{(o.omit?{}:e)[o.name]=U(o,n)}catch(t){throw t.message=`when deserializing item '${o.name}': ${t.message}`,t}return e}function _(t,n,e=r,o=!1){let s=0n;for(let o=0;o<n;++o)s|=BigInt(t.bytes[t.offset+o])<<BigInt(8*("big"===e?n-o-1:o));return o&&128&t.bytes[t.offset+("big"===e?0:n-1)]&&(s-=1n<<BigInt(8*n)),k(t,n),n>i?s:Number(s)}function U(t,n){switch(t.binary){case"int":case"uint":{const e=_(n,t.size,t.endianness,"int"===t.binary),{custom:o}=t;return s(o)?(m(o,e),o):s(o?.from)?(m(o.from,e),o.to):void 0!==o?o.to(e):e}case"bytes":{const e="lengthSize"in t&&void 0!==t.lengthSize?_(n,t.lengthSize,t.lengthEndianness):t?.size;if("layout"in t){const{custom:o}=t,r=n.offset;let i;if(void 0===e)i=C(t.layout,n);else{const o={...n,end:n.offset+e};if(k(n,e),i=C(t.layout,o),o.offset!==o.end)throw new Error(`read less data than expected: ${o.offset-n.offset} < ${e}`)}return void 0!==o?"function"!=typeof o.from?(y(x(t),n.bytes,{dataSlize:[r,n.offset]}),o.to):o.to(i):i}const{custom:o}=t;{let t,r;if(l(o)?t=o:u(o)&&(t=o.from,r=o.to),void 0!==t){const o=e??t.length,i=n.bytes.subarray(n.offset,n.offset+o);return y(t,i),k(n,o),r??t}}const r=n.offset,i=void 0!==e?n.offset+e:n.end;k(n,i-r);const s=n.bytes.subarray(r,i);return void 0!==o?o.to(s):s}case"array":{let e=[];const{layout:o}=t,r=()=>{const t=C(o,n);e.push(t)};let i=null;if("length"in t&&void 0!==t.length?i=t.length:"lengthSize"in t&&void 0!==t.lengthSize&&(i=_(n,t.lengthSize,t.lengthEndianness)),null!==i)for(let t=0;t<i;++t)r();else for(;n.offset<n.end;)r();return e}case"switch":{const e=_(n,t.idSize,t.idEndianness),{layouts:o}=t;if(0===o.length)throw new Error("switch item has no layouts");const r="number"==typeof o[0][0],i=o.find((([t])=>r?t===e:t[0]===e));if(void 0===i)throw new Error(`unknown id value: ${e}`);const[s,l]=i,a=C(l,n);return{[t.idTag??"id"]:r?e:s[1],...a}}}}function V(t,n){return T(t,n)}function N(t,n){switch(t.binary){case"bytes":if("layout"in t){const{custom:e}=t;return void 0===e||"function"!=typeof e.from?T(t.layout,e?e.from:n):n}case"int":case"uint":{const{custom:e}=t;return t?.omit?void 0:a(e)?e:c(e)?e.to:n}case"array":return Array.isArray(n)?n.map((n=>T(t.layout,n))):void 0;case"switch":{const e=n[t.idTag??"id"],[o,r]=t.layouts.find((([t])=>(Array.isArray(t)?t[1]:t)==e));return{[t.idTag??"id"]:e,...T(r,n)}}}}function T(t,n){if(n=n??{},f(t))return N(t,n);const e={};for(const o of t){const t=N(o,n[o.name]??{});void 0!==t&&(e[o.name]=t)}return e}function F(t,n){const[e,o]=function(t){if(0===t.length)throw new Error("Cannot discriminate empty set of layouts");const n=0n,e=(1n<<BigInt(t.length))-1n,o=t.map((()=>[])),r=t.map(((t,n)=>L(t,0,o[n]))),i=r.map(((t,n)=>[t,n])).sort((([[t]],[[n]])=>t-n)),s=(()=>{let t=e;const n=new Map;for(const[[e],o]of i)t^=1n<<BigInt(o),n.set(e,t);return n})(),l=function(t){const n=new Map;let e=[];const o=t=>{for(;e.length>0&&e[0][0]<t;){const t=e[0][0]+1,o=e.findIndex((([n])=>t<=n));-1===o?e=[]:e.splice(0,o),n.set(t,j(e.map((([,t])=>t))))}};for(const[[r,i],s]of t){o(r);const t=e.findIndex((([t])=>t>i));-1===t?e.push([i,s]):e.splice(t,0,[i,s]),n.set(r,j(e.map((([,t])=>t))))}return o(1/0),n}(i),a=t.length-Math.max(...[...l.values()].map((t=>H(t)))),f=t=>{let n=e;for(const[e,o]of s){if(t<e)break;n=o}return n},u=t=>{let e=n;for(const[n,o]of l){if(t<n)break;e=o}return e},c=Array.from({length:Math.max(...o.map((t=>t.length>0?t.at(-1)[0]+t.at(-1)[1].length:0)))}).map((()=>[]));for(let t=0;t<o.length;++t)for(const[n,e]of o[t])for(let o=0;o<e.length;++o)c[n+o].push([e[o],t]);let h=[];for(const[o,r]of c.entries()){const i=f(o),s=i^j(r.map((([,t])=>t))),l=e^i,a=new Map;for(const[t,e]of r)a.has(t)||a.set(t,n),a.set(t,a.get(t)|1n<<BigInt(e));let u=t.length-Math.max(H(s),H(l));for(const t of a.values()){const n=r.length-H(t)+H(l);u=Math.min(u,n)}if(0!==u){if(u===t.length-1)return[!0,t=>q(t.length<=o?l:a.get(t[o])??n)];h.push([u,o,l,a,s])}}if(a===t.length-1)return[!0,t=>q(u(t.length))];h.sort((([t],[n])=>n-t));let g=!0;const m=new Map,y=new Map,d=(t,n)=>{m.set(t,n),y.has(H(t))||y.set(H(t),[]),y.get(H(t)).push(t)},b=(t,n)=>{if(H(t)<=1||m.has(t))return;let e=0;const o=new Map;for(const n of q(t)){const i=r[n][0],s=l.get(i)&t;o.set(i,s),e=Math.max(e,H(s))}e=H(t)-e;const i=[];for(const[e,o,r,s,l]of n){const n=new Map;let a=0;for(const[e,o]of s){const r=o&t;H(r)>0&&(n.set(e,r),a+=H(r))}const f=r&t;let u=n.size>0?e:0;for(const t of n.values()){const n=a-H(t)+H(f);u=Math.min(u,n)}if(0!==u){if(u===H(t)-1)return void d(t,[o,f,n]);i.push([u,o,f,n,l&t])}}if(e!==H(t)-1)if(i.sort((([t],[n])=>n-t)),i.length>0&&i[0][0]>=e){const[,n,e,o,r]=i[0];d(t,[n,e,o]),b(e,i);for(const t of o.values())b(t|r,i.slice(1))}else if(e>0){d(t,"size");for(const t of o.values())b(t,i)}else d(t,"indistinguishable"),g=!1;else d(t,"size")};b(e,h);const w=n=>{for(let e=H(n)+1;e<t.length-2;++e)for(const t of y.get(e)??[])if((n&t)==n)return m.get(t);throw new Error("Implementation error in layout discrimination algorithm")};return[g,t=>{let n=e,o=m.get(n);for(;"indistinguishable"!==o;){if("size"===o)n&=u(t.length);else{const[e,r,i]=o;if(t.length<=e)n&=r;else{const o=t[e];for(const[t,e]of i)t!==o&&(n^=n&e);n^=n&r}}if(H(n)<=1)break;o=m.get(n)??w(n)}return q(n)}]}(t);if(!e&&!n)throw new Error("Cannot uniquely distinguished the given layouts");return n?o:t=>{const n=o(t);return 0===n.length?null:n[0]}}function j(t){return t.reduce(((t,n)=>t|BigInt(1)<<BigInt(n)),BigInt(0))}function q(t){const n=[];for(let e=0n;t>0n;t>>=1n,++e)1n&t&&n.push(Number(e));return n}function H(t){let n=0;for(;t>0n;t>>=1n)n+=Number(1n&t);return n}var O=t=>t>0?2**(8*t)-1:1/0;function D(t,n,e){switch(t.binary){case"int":case"uint":{const o=s(t.custom)?t.custom:s(t?.custom?.from)?t.custom.from:null;if(null!==o&&null!==n){const r={bytes:new Uint8Array(t.size),offset:0};A(o,t.size,r,t.endianness,"int"===t.binary),e.push([n,r.bytes])}return[t.size,t.size]}case"bytes":{const o="lengthSize"in t?0|t.lengthSize:0;let r,i;if("layout"in t){const{custom:n}=t;if(void 0!==n&&"function"!=typeof n.from)r=x(t),i=r.length;else{const n=b(t.layout);null!==n&&(i=n)}}else{const{custom:n}=t;l(n)?(r=n,i=n.length):u(n)&&(r=n.from,i=n.from.length)}if(o>0&&null!==n){if(void 0!==i){const r={bytes:new Uint8Array(o),offset:0};A(i,o,r,t.lengthEndianness,!1),e.push([n,r.bytes])}n+=o}if(void 0!==r)return null!==n&&e.push([n,r]),[o+r.length,o+r.length];const s="size"in t&&void 0!==t.size?[t.size,t.size]:void 0;if("layout"in t){const r=L(t.layout,n,e);return s??[o+r[0],o+r[1]]}return s??[o,O(o)]}case"array":{if("length"in t){let o=[];const r=L(t.layout,0,o);if(null!==n)if(r[0]!==r[1]){if(t.length>0)for(const[t,r]of o)e.push([n+t,r])}else for(let i=0;i<t.length;++i)for(const[t,s]of o)e.push([n+t+i*r[0],s]);return[t.length*r[0],t.length*r[1]]}const o=0|t.lengthSize;return[o,O(o)]}case"switch":{const o=t.layouts.map((t=>[])),{idSize:r,idEndianness:i}=t,s=t.layouts.map((([t,e],s)=>{const l=Array.isArray(t)?t[0]:t;if(null!==n){const t={bytes:new Uint8Array(r),offset:0};A(l,r,t,i),o[s].push([0,t.bytes])}const a=L(e,null!==n?r:null,o[s]);return[a[0]+r,a[1]+r]}));return null!==n&&o.every((t=>t.length>0))&&(()=>{const t=Math.min(...o.map((t=>t.at(-1)[0]+t.at(-1)[1].length))),r=o.map((t=>0));for(let i=0;i<t;){let t=null,s=0;for(;s<o.length;){let n=r[s];const e=o[s],[l,a]=e[n];if(l+a.length<=i){if(++n,n===e.length)return;r[s]=n,i=e[n][0];break}const f=a[i-l];if(null===t&&(t=f),f!==t){++i;break}++s}s===o.length&&(e.push([n+i,new Uint8Array([t])]),++i)}})(),[Math.min(...s.map((([t])=>t))),Math.max(...s.map((([t,n])=>n)))]}}}function L(t,n,e){if(!Array.isArray(t))return D(t,n,e);let o=[0,0];for(const r of t){const t=D(r,n,e);o[0]+=t[0],o[1]+=t[1],null!==n&&(n=t[0]===t[1]?n+t[0]:null)}return o}var G=(t,n)=>{return{...t,binary:"bytes",...void 0===n?{}:f(e=n)||Array.isArray(e)&&e.every(f)?{layout:n}:n instanceof Uint8Array||u(n)||!Array.isArray(n)?{custom:n}:{layout:n[0],custom:n[1]}};var e};function J(t,n){const e=Object.fromEntries(t.map((([t,n])=>[n,t]))),o=Object.fromEntries(t);return{binary:"uint",size:n?.size??1,endianness:n?.endianness??"big",custom:{to:t=>{const n=e[t];if(void 0===n)throw new Error(`Invalid enum value: ${t}`);return n},from:t=>o[t]}}}function K(t,n){return{binary:"uint",size:n??Math.ceil(t.length/8),custom:{to:n=>{const e={};for(let o=0;o<t.length;++o)t[o]&&(e[t[o]]=0n!==(BigInt(n)&1n<<BigInt(o)));return e},from:n=>{let e=0n;for(let o=0;o<t.length;++o)t[o]&&n[t[o]]&&(e|=1n<<BigInt(o));return t.length>i?e:Number(e)}}}}}}]);