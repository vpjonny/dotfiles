/*! For license information please see vendor-lightprotocol.js.LICENSE.txt */
"use strict";(globalThis.webpackChunk_coral_xyz_app_extension=globalThis.webpackChunk_coral_xyz_app_extension||[]).push([[697],{978596:(e,t,n)=>{var r=n(348834).Buffer,o=n(679176),s=n(627158),i=n(564861),a=n(348834);const c={version:"1.2.0",name:"light_compressed_token",instructions:[{name:"createTokenPool",docs:["This instruction creates a token pool for a given mint. Every spl mint","can have one token pool. When a token is compressed the tokens are","transferrred to the token pool, and their compressed equivalent is","minted into a Merkle tree."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"tokenPoolPda",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"mint",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1}],args:[]},{name:"mintTo",docs:["Mints tokens from an spl token mint to a list of compressed accounts.","Minted tokens are transferred to a pool account owned by the compressed","token program. The instruction creates one compressed output account for","every amount and pubkey input pair. A constant amount of lamports can be","transferred to each output account to enable. A use case to add lamports","to a compressed token account is to prevent spam. This is the only way","to add lamports to a compressed token account."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"mint",isMut:!0,isSigner:!1},{name:"tokenPoolPda",isMut:!0,isSigner:!1,docs:["account to a token account of a different mint will fail"]},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1,docs:["programs"]},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"merkleTree",isMut:!0,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"solPoolPda",isMut:!0,isSigner:!1,isOptional:!0}],args:[{name:"publicKeys",type:{vec:"publicKey"}},{name:"amounts",type:{vec:"u64"}},{name:"lamports",type:{option:"u64"}}]},{name:"transfer",docs:["Transfers compressed tokens from one account to another. All accounts","must be of the same mint. Additional spl tokens can be compressed or","decompressed. In one transaction only compression or decompression is","possible. Lamports can be transferred alongside tokens. If output token","accounts specify less lamports than inputs the remaining lamports are","transferred to an output compressed account. Signer must be owner or","delegate. If a delegated token account is transferred the delegate is","not preserved."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1,docs:["this program is the signer of the cpi."]},{name:"tokenPoolPda",isMut:!0,isSigner:!1,isOptional:!0},{name:"compressOrDecompressTokenAccount",isMut:!0,isSigner:!1,isOptional:!0},{name:"tokenProgram",isMut:!1,isSigner:!1,isOptional:!0},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"inputs",type:"bytes"}]},{name:"approve",docs:["Delegates an amount to a delegate. A compressed token account is either","completely delegated or not. Prior delegates are not preserved. Cannot","be called by a delegate.","The instruction creates two output accounts:","1. one account with delegated amount","2. one account with remaining(change) amount"],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1,docs:["this program is the signer of the cpi."]},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"inputs",type:"bytes"}]},{name:"revoke",docs:["Revokes a delegation. The instruction merges all inputs into one output","account. Cannot be called by a delegate. Delegates are not preserved."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1,docs:["this program is the signer of the cpi."]},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"inputs",type:"bytes"}]},{name:"freeze",docs:["Freezes compressed token accounts. Inputs must not be frozen. Creates as","many outputs as inputs. Balances and delegates are preserved."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1,docs:["that this program is the signer of the cpi."]},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1}],args:[{name:"inputs",type:"bytes"}]},{name:"thaw",docs:["Thaws frozen compressed token accounts. Inputs must be frozen. Creates","as many outputs as inputs. Balances and delegates are preserved."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1,docs:["that this program is the signer of the cpi."]},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1}],args:[{name:"inputs",type:"bytes"}]},{name:"burn",docs:["Burns compressed tokens and spl tokens from the pool account. Delegates","can burn tokens. The output compressed token account remains delegated.","Creates one output compressed token account."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"mint",isMut:!0,isSigner:!1},{name:"tokenPoolPda",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"inputs",type:"bytes"}]},{name:"stubIdlBuild",docs:["This function is a stub to allow Anchor to include the input types in","the IDL. It should not be included in production builds nor be called in","practice."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1,docs:["this program is the signer of the cpi."]},{name:"tokenPoolPda",isMut:!0,isSigner:!1,isOptional:!0},{name:"compressOrDecompressTokenAccount",isMut:!0,isSigner:!1,isOptional:!0},{name:"tokenProgram",isMut:!1,isSigner:!1,isOptional:!0},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"inputs1",type:{defined:"CompressedTokenInstructionDataTransfer"}},{name:"inputs2",type:{defined:"TokenData"}}]}],types:[{name:"AccessMetadata",type:{kind:"struct",fields:[{name:"owner",docs:["Owner of the Merkle tree."],type:"publicKey"},{name:"programOwner",docs:["Program owner of the Merkle tree. This will be used for program owned Merkle trees."],type:"publicKey"},{name:"forester",docs:["Optional privileged forester pubkey, can be set for custom Merkle trees","without a network fee. Merkle trees without network fees are not","forested by light foresters. The variable is not used in the account","compression program but the registry program. The registry program","implements access control to prevent contention during forester. The","forester pubkey specified in this struct can bypass contention checks."],type:"publicKey"}]}},{name:"AccountState",type:{kind:"enum",variants:[{name:"Initialized"},{name:"Frozen"}]}},{name:"CompressedAccount",type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"lamports",type:"u64"},{name:"address",type:{option:{array:["u8",32]}}},{name:"data",type:{option:{defined:"CompressedAccountData"}}}]}},{name:"CompressedAccountData",type:{kind:"struct",fields:[{name:"discriminator",type:{array:["u8",8]}},{name:"data",type:"bytes"},{name:"dataHash",type:{array:["u8",32]}}]}},{name:"CompressedCpiContext",type:{kind:"struct",fields:[{name:"setContext",docs:["Is set by the program that is invoking the CPI to signal that is should","set the cpi context."],type:"bool"},{name:"firstSetContext",docs:["Is set to wipe the cpi context since someone could have set it before","with unrelated data."],type:"bool"},{name:"cpiContextAccountIndex",docs:["Index of cpi context account in remaining accounts."],type:"u8"}]}},{name:"CompressedProof",type:{kind:"struct",fields:[{name:"a",type:{array:["u8",32]}},{name:"b",type:{array:["u8",64]}},{name:"c",type:{array:["u8",32]}}]}},{name:"CompressedTokenInstructionDataTransfer",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"mint",type:"publicKey"},{name:"delegatedTransfer",docs:["Is required if the signer is delegate,","-> delegate is authority account,","owner = Some(owner) is the owner of the token account."],type:{option:{defined:"DelegatedTransfer"}}},{name:"inputTokenDataWithContext",type:{vec:{defined:"InputTokenDataWithContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"PackedTokenTransferOutputData"}}},{name:"isCompress",type:"bool"},{name:"compressOrDecompressAmount",type:{option:"u64"}},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}},{name:"lamportsChangeAccountMerkleTreeIndex",type:{option:"u8"}}]}},{name:"DelegatedTransfer",docs:["Struct to provide the owner when the delegate is signer of the transaction."],type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"delegateChangeAccountIndex",docs:["Index of change compressed account in output compressed accounts. In","case that the delegate didn't spend the complete delegated compressed","account balance the change compressed account will be delegated to her","as well."],type:{option:"u8"}}]}},{name:"InputTokenDataWithContext",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"delegateIndex",type:{option:"u8"}},{name:"merkleContext",type:{defined:"PackedMerkleContext"}},{name:"rootIndex",type:"u16"},{name:"lamports",type:{option:"u64"}},{name:"tlv",docs:["Placeholder for TokenExtension tlv data (unimplemented)"],type:{option:"bytes"}}]}},{name:"InstructionDataInvoke",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"inputCompressedAccountsWithMerkleContext",type:{vec:{defined:"PackedCompressedAccountWithMerkleContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"relayFee",type:{option:"u64"}},{name:"newAddressParams",type:{vec:{defined:"NewAddressParamsPacked"}}},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"isCompress",type:"bool"}]}},{name:"InstructionDataInvokeCpi",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"newAddressParams",type:{vec:{defined:"NewAddressParamsPacked"}}},{name:"inputCompressedAccountsWithMerkleContext",type:{vec:{defined:"PackedCompressedAccountWithMerkleContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"relayFee",type:{option:"u64"}},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"isCompress",type:"bool"},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}}]}},{name:"MerkleTreeMetadata",type:{kind:"struct",fields:[{name:"accessMetadata",type:{defined:"AccessMetadata"}},{name:"rolloverMetadata",type:{defined:"RolloverMetadata"}},{name:"associatedQueue",type:"publicKey"},{name:"nextMerkleTree",type:"publicKey"}]}},{name:"MerkleTreeSequenceNumber",type:{kind:"struct",fields:[{name:"pubkey",type:"publicKey"},{name:"seq",type:"u64"}]}},{name:"NewAddressParamsPacked",type:{kind:"struct",fields:[{name:"seed",type:{array:["u8",32]}},{name:"addressQueueAccountIndex",type:"u8"},{name:"addressMerkleTreeAccountIndex",type:"u8"},{name:"addressMerkleTreeRootIndex",type:"u16"}]}},{name:"OutputCompressedAccountWithPackedContext",type:{kind:"struct",fields:[{name:"compressedAccount",type:{defined:"CompressedAccount"}},{name:"merkleTreeIndex",type:"u8"}]}},{name:"PackedCompressedAccountWithMerkleContext",type:{kind:"struct",fields:[{name:"compressedAccount",type:{defined:"CompressedAccount"}},{name:"merkleContext",type:{defined:"PackedMerkleContext"}},{name:"rootIndex",docs:["Index of root used in inclusion validity proof."],type:"u16"},{name:"readOnly",docs:["Placeholder to mark accounts read-only unimplemented set to false."],type:"bool"}]}},{name:"PackedMerkleContext",type:{kind:"struct",fields:[{name:"merkleTreePubkeyIndex",type:"u8"},{name:"nullifierQueuePubkeyIndex",type:"u8"},{name:"leafIndex",type:"u32"},{name:"queueIndex",docs:["Index of leaf in queue. Placeholder of batched Merkle tree updates","currently unimplemented."],type:{option:{defined:"QueueIndex"}}}]}},{name:"PackedTokenTransferOutputData",type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"amount",type:"u64"},{name:"lamports",type:{option:"u64"}},{name:"merkleTreeIndex",type:"u8"},{name:"tlv",docs:["Placeholder for TokenExtension tlv data (unimplemented)"],type:{option:"bytes"}}]}},{name:"PublicTransactionEvent",type:{kind:"struct",fields:[{name:"inputCompressedAccountHashes",type:{vec:{array:["u8",32]}}},{name:"outputCompressedAccountHashes",type:{vec:{array:["u8",32]}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"outputLeafIndices",type:{vec:"u32"}},{name:"sequenceNumbers",type:{vec:{defined:"MerkleTreeSequenceNumber"}}},{name:"relayFee",type:{option:"u64"}},{name:"isCompress",type:"bool"},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"pubkeyArray",type:{vec:"publicKey"}},{name:"message",type:{option:"bytes"}}]}},{name:"QueueIndex",type:{kind:"struct",fields:[{name:"queueId",docs:["Id of queue in queue account."],type:"u8"},{name:"index",docs:["Index of compressed account hash in queue."],type:"u16"}]}},{name:"RolloverMetadata",type:{kind:"struct",fields:[{name:"index",docs:["Unique index."],type:"u64"},{name:"rolloverFee",docs:["This fee is used for rent for the next account.","It accumulates in the account so that once the corresponding Merkle tree account is full it can be rolled over"],type:"u64"},{name:"rolloverThreshold",docs:["The threshold in percentage points when the account should be rolled over (95 corresponds to 95% filled)."],type:"u64"},{name:"networkFee",docs:["Tip for maintaining the account."],type:"u64"},{name:"rolledoverSlot",docs:["The slot when the account was rolled over, a rolled over account should not be written to."],type:"u64"},{name:"closeThreshold",docs:["If current slot is greater than rolledover_slot + close_threshold and","the account is empty it can be closed. No 'close' functionality has been","implemented yet."],type:"u64"},{name:"additionalBytes",docs:["Placeholder for bytes of additional accounts which are tied to the","Merkle trees operation and need to be rolled over as well."],type:"u64"}]}},{name:"TokenData",type:{kind:"struct",fields:[{name:"mint",docs:["The mint associated with this account"],type:"publicKey"},{name:"owner",docs:["The owner of this account."],type:"publicKey"},{name:"amount",docs:["The amount of tokens this account holds."],type:"u64"},{name:"delegate",docs:["If `delegate` is `Some` then `delegated_amount` represents","the amount authorized by the delegate"],type:{option:"publicKey"}},{name:"state",docs:["The account's state"],type:{defined:"AccountState"}},{name:"tlv",docs:["Placeholder for TokenExtension tlv data (unimplemented)"],type:{option:"bytes"}}]}}],errors:[{code:6e3,name:"SignerCheckFailed",msg:"Signer check failed"},{code:6001,name:"CreateTransferInstructionFailed",msg:"Create transfer instruction failed"},{code:6002,name:"AccountNotFound",msg:"Account not found"},{code:6003,name:"SerializationError",msg:"Serialization error"}]};function u(e){const{inputCompressedTokenAccounts:t,outputStateTrees:n,remainingAccounts:r=[],rootIndices:s,tokenTransferOutputs:i}=e,a=r.slice();let c=null;t.length>0&&t[0].parsed.delegate&&(c=o.getIndexOrAdd(a,t[0].parsed.delegate));const u=[];t.forEach(((e,t)=>{const n=o.getIndexOrAdd(a,e.compressedAccount.merkleTree),r=o.getIndexOrAdd(a,e.compressedAccount.nullifierQueue);u.push({amount:e.parsed.amount,delegateIndex:c,merkleContext:{merkleTreePubkeyIndex:n,nullifierQueuePubkeyIndex:r,leafIndex:e.compressedAccount.leafIndex,queueIndex:null},rootIndex:s[t],lamports:e.compressedAccount.lamports.eq(o.bn(0))?null:e.compressedAccount.lamports,tlv:null})}));const d=o.padOutputStateMerkleTrees(n,i.length,t.map((e=>e.compressedAccount))),l=[];d.forEach(((e,t)=>{var n;const r=o.getIndexOrAdd(a,e);l.push({owner:i[t].owner,amount:i[t].amount,lamports:(null===(n=i[t].lamports)||void 0===n?void 0:n.eq(o.bn(0)))?null:i[t].lamports,merkleTreeIndex:r,tlv:null})}));const p=a.map((e=>({pubkey:e,isWritable:!0,isSigner:!1})));return{inputTokenDataWithContext:u,remainingAccountMetas:p,packedOutputTokenData:l}}const d=r.from("pool"),l=r.from("cpi_authority"),p=new s.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");new s.PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");const m=new s.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new s.PublicKey("So11111111111111111111111111111111111111112"),new s.PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");var h={};Object.defineProperty(h,"__esModule",{value:!0}),h.s16=h.s8=h.nu64be=h.u48be=h.u40be=h.u32be=h.u24be=h.u16be=h.nu64=h.u48=h.u40=ee=h.u32=h.u24=h.u16=Z=h.u8=h.offset=h.greedy=h.Constant=h.UTF8=h.CString=h.Blob=h.Boolean=h.BitField=h.BitStructure=h.VariantLayout=h.Union=h.UnionLayoutDiscriminator=h.UnionDiscriminator=h.Structure=h.Sequence=h.DoubleBE=h.Double=h.FloatBE=h.Float=h.NearInt64BE=h.NearInt64=h.NearUInt64BE=h.NearUInt64=h.IntBE=h.Int=h.UIntBE=h.UInt=h.OffsetLayout=h.GreedyCount=h.ExternalLayout=h.bindConstructorLayout=h.nameWithProperty=h.Layout=h.uint8ArrayToBuffer=h.checkUint8Array=void 0,h.constant=h.utf8=h.cstr=ne=h.blob=h.unionLayoutDiscriminator=h.union=h.seq=h.bits=te=h.struct=h.f64be=h.f64=h.f32be=h.f32=h.ns64be=h.s48be=h.s40be=h.s32be=h.s24be=h.s16be=h.ns64=h.s48=h.s40=h.s32=h.s24=void 0;const f=a;function g(e){if(!(e instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}function y(e){return g(e),f.Buffer.from(e.buffer,e.byteOffset,e.length)}h.checkUint8Array=g,h.uint8ArrayToBuffer=y;class w{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}var b=h.Layout=w;function A(e,t){return t.property?e+"["+t.property+"]":e}h.nameWithProperty=A,h.bindConstructorLayout=function(e,t){if("function"!=typeof e)throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(e,"layout_"))throw new Error("Class is already bound to a layout");if(!(t&&t instanceof w))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(t,"boundConstructor_"))throw new Error("layout is already bound to a constructor");e.layout_=t,t.boundConstructor_=e,t.makeDestinationObject=()=>new e,Object.defineProperty(e.prototype,"encode",{value(e,n){return t.encode(this,e,n)},writable:!0}),Object.defineProperty(e,"decode",{value:(e,n)=>t.decode(e,n),writable:!0})};class S extends w{isCount(){throw new Error("ExternalLayout is abstract")}}h.ExternalLayout=S;class k extends S{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){g(e);const n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}}h.GreedyCount=k;class P extends S{constructor(e,t=0,n){if(!(e instanceof w))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof E||this.layout instanceof v}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}}h.OffsetLayout=P;class E extends w{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return y(e).readUIntLE(t,this.span)}encode(e,t,n=0){return y(t).writeUIntLE(e,n,this.span),this.span}}h.UInt=E;class v extends w{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return y(e).readUIntBE(t,this.span)}encode(e,t,n=0){return y(t).writeUIntBE(e,n,this.span),this.span}}h.UIntBE=v;class T extends w{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return y(e).readIntLE(t,this.span)}encode(e,t,n=0){return y(t).writeIntLE(e,n,this.span),this.span}}h.Int=T;class C extends w{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return y(e).readIntBE(t,this.span)}encode(e,t,n=0){return y(t).writeIntBE(e,n,this.span),this.span}}h.IntBE=C;const M=Math.pow(2,32);function I(e){const t=Math.floor(e/M);return{hi32:t,lo32:e-t*M}}function x(e,t){return e*M+t}class _ extends w{constructor(e){super(8,e)}decode(e,t=0){const n=y(e),r=n.readUInt32LE(t);return x(n.readUInt32LE(t+4),r)}encode(e,t,n=0){const r=I(e),o=y(t);return o.writeUInt32LE(r.lo32,n),o.writeUInt32LE(r.hi32,n+4),8}}h.NearUInt64=_;class O extends w{constructor(e){super(8,e)}decode(e,t=0){const n=y(e);return x(n.readUInt32BE(t),n.readUInt32BE(t+4))}encode(e,t,n=0){const r=I(e),o=y(t);return o.writeUInt32BE(r.hi32,n),o.writeUInt32BE(r.lo32,n+4),8}}h.NearUInt64BE=O;class N extends w{constructor(e){super(8,e)}decode(e,t=0){const n=y(e),r=n.readUInt32LE(t);return x(n.readInt32LE(t+4),r)}encode(e,t,n=0){const r=I(e),o=y(t);return o.writeUInt32LE(r.lo32,n),o.writeInt32LE(r.hi32,n+4),8}}h.NearInt64=N;class D extends w{constructor(e){super(8,e)}decode(e,t=0){const n=y(e);return x(n.readInt32BE(t),n.readUInt32BE(t+4))}encode(e,t,n=0){const r=I(e),o=y(t);return o.writeInt32BE(r.hi32,n),o.writeUInt32BE(r.lo32,n+4),8}}h.NearInt64BE=D;class B extends w{constructor(e){super(4,e)}decode(e,t=0){return y(e).readFloatLE(t)}encode(e,t,n=0){return y(t).writeFloatLE(e,n),4}}h.Float=B;class L extends w{constructor(e){super(4,e)}decode(e,t=0){return y(e).readFloatBE(t)}encode(e,t,n=0){return y(t).writeFloatBE(e,n),4}}h.FloatBE=L;class U extends w{constructor(e){super(8,e)}decode(e,t=0){return y(e).readDoubleLE(t)}encode(e,t,n=0){return y(t).writeDoubleLE(e,n),8}}h.Double=U;class R extends w{constructor(e){super(8,e)}decode(e,t=0){return y(e).readDoubleBE(t)}encode(e,t,n=0){return y(t).writeDoubleBE(e,n),8}}h.DoubleBE=R;class F extends w{constructor(e,t,n){if(!(e instanceof w))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof S&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let r=-1;!(t instanceof S)&&0<e.span&&(r=t*e.span),super(r,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,r=this.count;if(r instanceof S&&(r=r.decode(e,t)),0<this.elementLayout.span)n=r*this.elementLayout.span;else{let o=0;for(;o<r;)n+=this.elementLayout.getSpan(e,t+n),++o}return n}decode(e,t=0){const n=[];let r=0,o=this.count;for(o instanceof S&&(o=o.decode(e,t));r<o;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),r+=1;return n}encode(e,t,n=0){const r=this.elementLayout,o=e.reduce(((e,o)=>e+r.encode(o,t,n+e)),0);return this.count instanceof S&&this.count.encode(e.length,t,n),o}}h.Sequence=F;class K extends w{constructor(e,t,n){if(!Array.isArray(e)||!e.reduce(((e,t)=>e&&t instanceof w),!0))throw new TypeError("fields must be array of Layout instances");"boolean"==typeof t&&void 0===n&&(n=t,t=void 0);for(const t of e)if(0>t.span&&void 0===t.property)throw new Error("fields cannot contain unnamed variable-length layout");let r=-1;try{r=e.reduce(((e,t)=>e+t.getSpan()),0)}catch(e){}super(r,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce(((n,r)=>{const o=r.getSpan(e,t);return t+=o,n+o}),0)}catch(e){throw new RangeError("indeterminate span")}return n}decode(e,t=0){g(e);const n=this.makeDestinationObject();for(const r of this.fields)if(void 0!==r.property&&(n[r.property]=r.decode(e,t)),t+=r.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){const r=n;let o=0,s=0;for(const r of this.fields){let i=r.span;if(s=0<i?i:0,void 0!==r.property){const o=e[r.property];void 0!==o&&(s=r.encode(o,t,n),0>i&&(i=r.getSpan(t,n)))}o=n,n+=i}return o+s-r}fromArray(e){const t=this.makeDestinationObject();for(const n of this.fields)void 0!==n.property&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if("string"!=typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if("string"!=typeof e)throw new TypeError("property must be string");let t=0;for(const n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}}h.Structure=K;class z{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}}h.UnionDiscriminator=z;class $ extends z{constructor(e,t){if(!(e instanceof S&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}}h.UnionLayoutDiscriminator=$;class V extends w{constructor(e,t,n){let r;if(e instanceof E||e instanceof v)r=new $(new P(e));else if(e instanceof S&&e.isCount())r=new $(e);else{if(!(e instanceof z))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");r=e}if(void 0===t&&(t=null),!(null===t||t instanceof w))throw new TypeError("defaultLayout must be null or a Layout");if(null!==t){if(0>t.span)throw new Error("defaultLayout must have constant span");void 0===t.property&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof E||e instanceof v)&&(o+=r.layout.span)),super(o,n),this.discriminator=r,this.usesPrefixDiscriminator=e instanceof E||e instanceof v,this.defaultLayout=t,this.registry={};let s=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(e){return s(e)},this.configGetSourceVariant=function(e){s=e.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n;const r=this.discriminator,o=r.decode(e,t),s=this.registry[o];if(void 0===s){const s=this.defaultLayout;let i=0;this.usesPrefixDiscriminator&&(i=r.layout.span),n=this.makeDestinationObject(),n[r.property]=o,n[s.property]=s.decode(e,t+i)}else n=s.decode(e,t);return n}encode(e,t,n=0){const r=this.getSourceVariant(e);if(void 0===r){const r=this.discriminator,o=this.defaultLayout;let s=0;return this.usesPrefixDiscriminator&&(s=r.layout.span),r.encode(e[r.property],t,n),s+o.encode(e[o.property],t,n+s)}return r.encode(e,t,n)}addVariant(e,t,n){const r=new W(this,e,t,n);return this.registry[e]=r,r}getVariant(e,t=0){let n;return n=e instanceof Uint8Array?this.discriminator.decode(e,t):e,this.registry[n]}}h.Union=V;class W extends w{constructor(e,t,n,r){if(!(e instanceof V))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if("string"==typeof n&&void 0===r&&(r=n,n=null),n){if(!(n instanceof w))throw new TypeError("layout must be a Layout");if(null!==e.defaultLayout&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if("string"!=typeof r)throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=n?n.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,r),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let r=0;return this.layout&&(r=this.layout.getSpan(e,t+n)),n+r}decode(e,t=0){const n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let r=0;return this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+r):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let r=0;if(this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let o=r;if(this.layout&&(this.layout.encode(e[this.property],t,n+r),o+=this.layout.getSpan(t,n+r),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}function H(e){return 0>e&&(e+=4294967296),e}h.VariantLayout=W;class q extends w{constructor(e,t,n){if(!(e instanceof E||e instanceof v))throw new TypeError("word must be a UInt or UIntBE layout");if("string"==typeof t&&void 0===n&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let r=0;this._packedSetValue=function(e){return r=H(e),this},this._packedGetValue=function(){return r}}decode(e,t=0){const n=this.makeDestinationObject(),r=this.word.decode(e,t);this._packedSetValue(r);for(const t of this.fields)void 0!==t.property&&(n[t.property]=t.decode(e));return n}encode(e,t,n=0){const r=this.word.decode(t,n);this._packedSetValue(r);for(const t of this.fields)if(void 0!==t.property){const n=e[t.property];void 0!==n&&t.encode(n)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){const n=new j(this,e,t);return this.fields.push(n),n}addBoolean(e){const t=new Q(this,e);return this.fields.push(t),t}fieldFor(e){if("string"!=typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}h.BitStructure=q;class j{constructor(e,t,n){if(!(e instanceof q))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const r=8*e.span,o=e.fields.reduce(((e,t)=>e+t.bits),0);if(t+o>r)throw new Error("bits too long for span remainder ("+(r-o)+" of "+r+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,32===t&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=r-o-t),this.wordMask=H(this.valueMask<<this.start),this.property=n}decode(e,t){return H(this.container._packedGetValue()&this.wordMask)>>>this.start}encode(e){if("number"!=typeof e||!Number.isInteger(e)||e!==H(e&this.valueMask))throw new TypeError(A("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),n=H(e<<this.start);this.container._packedSetValue(H(t&~this.wordMask)|n)}}h.BitField=j;class Q extends j{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){"boolean"==typeof e&&(e=+e),super.encode(e)}}h.Boolean=Q;class G extends w{constructor(e,t){if(!(e instanceof S&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof S||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),y(e).slice(t,t+n)}encode(e,t,n){let r=this.length;if(this.length instanceof S&&(r=e.length),!(e instanceof Uint8Array&&r===e.length))throw new TypeError(A("Blob.encode",this)+" requires (length "+r+") Uint8Array as src");if(n+r>t.length)throw new RangeError("encoding overruns Uint8Array");const o=y(e);return y(t).write(o.toString("hex"),n,r,"hex"),this.length instanceof S&&this.length.encode(r,t,n),r}}h.Blob=G;class Y extends w{constructor(e){super(-1,e)}getSpan(e,t=0){g(e);let n=t;for(;n<e.length&&0!==e[n];)n+=1;return 1+n-t}decode(e,t=0){const n=this.getSpan(e,t);return y(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){"string"!=typeof e&&(e=String(e));const r=f.Buffer.from(e,"utf8"),o=r.length;if(n+o>t.length)throw new RangeError("encoding overruns Buffer");const s=y(t);return r.copy(s,n),s[n+o]=0,o+1}}h.CString=Y;class X extends w{constructor(e,t){if("string"==typeof e&&void 0===t&&(t=e,e=void 0),void 0===e)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return g(e),e.length-t}decode(e,t=0){const n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return y(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){"string"!=typeof e&&(e=String(e));const r=f.Buffer.from(e,"utf8"),o=r.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(n+o>t.length)throw new RangeError("encoding overruns Buffer");return r.copy(y(t),n),o}}h.UTF8=X;class J extends w{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}}h.Constant=J,h.greedy=(e,t)=>new k(e,t),h.offset=(e,t,n)=>new P(e,t,n);var Z=h.u8=e=>new E(1,e);h.u16=e=>new E(2,e),h.u24=e=>new E(3,e);var ee=h.u32=e=>new E(4,e);h.u40=e=>new E(5,e),h.u48=e=>new E(6,e),h.nu64=e=>new _(e),h.u16be=e=>new v(2,e),h.u24be=e=>new v(3,e),h.u32be=e=>new v(4,e),h.u40be=e=>new v(5,e),h.u48be=e=>new v(6,e),h.nu64be=e=>new O(e),h.s8=e=>new T(1,e),h.s16=e=>new T(2,e),h.s24=e=>new T(3,e),h.s32=e=>new T(4,e),h.s40=e=>new T(5,e),h.s48=e=>new T(6,e),h.ns64=e=>new N(e),h.s16be=e=>new C(2,e),h.s24be=e=>new C(3,e),h.s32be=e=>new C(4,e),h.s40be=e=>new C(5,e),h.s48be=e=>new C(6,e),h.ns64be=e=>new D(e),h.f32=e=>new B(e),h.f32be=e=>new L(e),h.f64=e=>new U(e),h.f64be=e=>new R(e);var te=h.struct=(e,t,n)=>new K(e,t,n);h.bits=(e,t,n)=>new q(e,t,n),h.seq=(e,t,n)=>new F(e,t,n),h.union=(e,t,n)=>new V(e,t,n),h.unionLayoutDiscriminator=(e,t)=>new $(e,t);var ne=h.blob=(e,t)=>new G(e,t);h.cstr=e=>new Y(e),h.utf8=(e,t)=>new X(e,t),h.constant=(e,t)=>new J(e,t);const re=e=>({decode:e.decode.bind(e),encode:e.encode.bind(e)});var oe={};Object.defineProperty(oe,"__esModule",{value:!0});var se=oe.toBigIntLE=function(e){{const t=r.from(e);t.reverse();const n=t.toString("hex");return 0===n.length?BigInt(0):BigInt(`0x${n}`)}};oe.toBigIntBE=function(e){{const t=e.toString("hex");return 0===t.length?BigInt(0):BigInt(`0x${t}`)}};var ie=oe.toBufferLE=function(e,t){{const n=e.toString(16),o=r.from(n.padStart(2*t,"0").slice(0,2*t),"hex");return o.reverse(),o}};oe.toBufferBE=function(e,t){{const n=e.toString(16);return r.from(n.padStart(2*t,"0").slice(0,2*t),"hex")}};const ae=(8,e=>{const t=ne(8,e),{encode:n,decode:o}=re(t),s=t;return s.decode=(e,t)=>{const n=o(e,t);return se(r.from(n))},s.encode=(e,t,r)=>{const o=ie(e,8);return n(o,t,r)},s});const ce=e=>{const t=Z(e),{encode:n,decode:r}=re(t),o=t;return o.decode=(e,t)=>!!r(e,t),o.encode=(e,t,r)=>{const o=Number(e);return n(o,t,r)},o},ue=e=>{const t=ne(32,e),{encode:n,decode:r}=re(t),o=t;return o.decode=(e,t)=>{const n=r(e,t);return new s.PublicKey(n)},o.encode=(e,t,r)=>{const o=e.toBuffer();return n(o,t,r)},o};class de extends Error{constructor(e){super(e)}}class le extends de{constructor(){super(...arguments),this.name="TokenAccountNotFoundError"}}class pe extends de{constructor(){super(...arguments),this.name="TokenInvalidAccountError"}}class me extends de{constructor(){super(...arguments),this.name="TokenInvalidAccountOwnerError"}}class he extends de{constructor(){super(...arguments),this.name="TokenInvalidAccountSizeError"}}class fe extends de{constructor(){super(...arguments),this.name="TokenInvalidMintError"}}class ge extends de{constructor(){super(...arguments),this.name="TokenInvalidOwnerError"}}class ye extends de{constructor(){super(...arguments),this.name="TokenOwnerOffCurveError"}}var we,be;!function(e){e[e.InitializeMint=0]="InitializeMint",e[e.InitializeAccount=1]="InitializeAccount",e[e.InitializeMultisig=2]="InitializeMultisig",e[e.Transfer=3]="Transfer",e[e.Approve=4]="Approve",e[e.Revoke=5]="Revoke",e[e.SetAuthority=6]="SetAuthority",e[e.MintTo=7]="MintTo",e[e.Burn=8]="Burn",e[e.CloseAccount=9]="CloseAccount",e[e.FreezeAccount=10]="FreezeAccount",e[e.ThawAccount=11]="ThawAccount",e[e.TransferChecked=12]="TransferChecked",e[e.ApproveChecked=13]="ApproveChecked",e[e.MintToChecked=14]="MintToChecked",e[e.BurnChecked=15]="BurnChecked",e[e.InitializeAccount2=16]="InitializeAccount2",e[e.SyncNative=17]="SyncNative",e[e.InitializeAccount3=18]="InitializeAccount3",e[e.InitializeMultisig2=19]="InitializeMultisig2",e[e.InitializeMint2=20]="InitializeMint2",e[e.GetAccountDataSize=21]="GetAccountDataSize",e[e.InitializeImmutableOwner=22]="InitializeImmutableOwner",e[e.AmountToUiAmount=23]="AmountToUiAmount",e[e.UiAmountToAmount=24]="UiAmountToAmount",e[e.InitializeMintCloseAuthority=25]="InitializeMintCloseAuthority",e[e.TransferFeeExtension=26]="TransferFeeExtension",e[e.ConfidentialTransferExtension=27]="ConfidentialTransferExtension",e[e.DefaultAccountStateExtension=28]="DefaultAccountStateExtension",e[e.Reallocate=29]="Reallocate",e[e.MemoTransferExtension=30]="MemoTransferExtension",e[e.CreateNativeMint=31]="CreateNativeMint",e[e.InitializeNonTransferableMint=32]="InitializeNonTransferableMint",e[e.InterestBearingMintExtension=33]="InterestBearingMintExtension",e[e.CpiGuardExtension=34]="CpiGuardExtension",e[e.InitializePermanentDelegate=35]="InitializePermanentDelegate",e[e.TransferHookExtension=36]="TransferHookExtension",e[e.MetadataPointerExtension=39]="MetadataPointerExtension",e[e.GroupPointerExtension=40]="GroupPointerExtension",e[e.GroupMemberPointerExtension=41]="GroupMemberPointerExtension"}(we||(we={})),function(e){e[e.Uninitialized=0]="Uninitialized",e[e.Mint=1]="Mint",e[e.Account=2]="Account"}(be||(be={}));const Ae=1,Se=te([Z("m"),Z("n"),ce("isInitialized"),ue("signer1"),ue("signer2"),ue("signer3"),ue("signer4"),ue("signer5"),ue("signer6"),ue("signer7"),ue("signer8"),ue("signer9"),ue("signer10"),ue("signer11")]).span;var ke;!function(e){e[e.Uninitialized=0]="Uninitialized",e[e.Initialized=1]="Initialized",e[e.Frozen=2]="Frozen"}(ke||(ke={}));const Pe=te([ue("mint"),ue("owner"),ae("amount"),ee("delegateOption"),ue("delegate"),Z("state"),ee("isNativeOption"),ae("isNative"),ae("delegatedAmount"),ee("closeAuthorityOption"),ue("closeAuthority")]),Ee=Pe.span;async function ve(e,t,n,o=p){return function(e,t,n=p){if(!t)throw new le;if(!t.owner.equals(n))throw new me;if(t.data.length<Ee)throw new he;const o=Pe.decode(t.data.slice(0,Ee));let s=r.alloc(0);if(t.data.length>Ee){if(t.data.length===Se)throw new he;if(t.data[Ee]!=be.Account)throw new pe;s=t.data.slice(Ee+Ae)}return{address:e,mint:o.mint,owner:o.owner,amount:o.amount,delegate:o.delegateOption?o.delegate:null,delegatedAmount:o.delegatedAmount,isInitialized:o.state!==ke.Uninitialized,isFrozen:o.state===ke.Frozen,isNative:!!o.isNativeOption,rentExemptReserve:o.isNativeOption?o.isNative:null,closeAuthority:o.closeAuthorityOption?o.closeAuthority:null,tlvData:s}}(t,await e.getAccountInfo(t,n),o)}const Te=te([ee("mintAuthorityOption"),ue("mintAuthority"),ae("supply"),Z("decimals"),ce("isInitialized"),ee("freezeAuthorityOption"),ue("freezeAuthority")]).span;const Ce=te([Z("instruction"),Z("decimals"),ue("mintAuthority"),new class extends b{constructor(e){super(-1,e),this.publicKeyLayout=ue()}decode(e,t=0){return 0===e[t]?null:this.publicKeyLayout.decode(e,t+1)}encode(e,t,n=0){return null===e?(t[n]=0,1):(t[n]=1,this.publicKeyLayout.encode(e,t,n+1),33)}getSpan(e,t=0){return e&&0===e[t]?1:1+this.publicKeyLayout.span}}("freezeAuthority")]);async function Me(e,t,n,o,i=!1,a,c,u=p,d=m){const l=function(e,t,n=!1,r=p,o=m){if(!n&&!s.PublicKey.isOnCurve(t.toBuffer()))throw new ye;const[i]=s.PublicKey.findProgramAddressSync([t.toBuffer(),r.toBuffer(),e.toBuffer()],o);return i}(n,o,i,u,d);let h;try{h=await ve(e,l,a,u)}catch(i){if(!(i instanceof le||i instanceof me))throw i;try{const i=(new s.Transaction).add(function(e,t,n,o,i=p,a=m){return function(e,t,n,r,o,i=p,a=m){const c=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:s.SystemProgram.programId,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1}];return new s.TransactionInstruction({keys:c,programId:a,data:o})}(e,t,n,o,r.alloc(0),i,a)}(t.publicKey,l,o,n,u,d));await s.sendAndConfirmTransaction(e,i,[t],c)}catch(e){}h=await ve(e,l,a,u)}if(!h.mint.equals(n))throw new fe;if(!h.owner.equals(o))throw new ge;return h}const Ie=te([Z("instruction"),ae("amount")]);function xe(e,t,n,o,i=[],a=p){const c=function(e,t,n){if(n.length){e.push({pubkey:t,isSigner:!1,isWritable:!1});for(const t of n)e.push({pubkey:t instanceof s.PublicKey?t:t.publicKey,isSigner:!0,isWritable:!1})}else e.push({pubkey:t,isSigner:!0,isWritable:!1});return e}([{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0}],n,i),u=r.alloc(Ie.span);return Ie.encode({instruction:we.MintTo,amount:BigInt(o)},u),new s.TransactionInstruction({keys:c,programId:a,data:u})}const _e=e=>e.reduce(((e,t)=>e.add(t.parsed.amount)),o.bn(0)),Oe=e=>{const t=e[0].parsed.owner;e.forEach((e=>{if(!e.parsed.owner.equals(t))throw new Error("Token accounts must be owned by the same owner")}))},Ne=e=>({mint:e[0].parsed.mint,currentOwner:e[0].parsed.owner,delegate:e[0].parsed.delegate});function De(e,t,n){n=o.bn(n);const r=_e(e),s=o.sumUpLamports(e.map((e=>e.compressedAccount))),i=r.sub(n);return o.validateSufficientBalance(i),i.eq(o.bn(0))&&s.eq(o.bn(0))?[{owner:t,amount:n,lamports:s,tlv:null}]:(o.validateSameOwner(e.map((e=>e.compressedAccount))),Oe(e),[{owner:e[0].parsed.owner,amount:i,lamports:s,tlv:null},{owner:t,amount:n,lamports:o.bn(0),tlv:null}])}function Be(e,t){t=o.bn(t);const n=o.sumUpLamports(e.map((e=>e.compressedAccount))),r=_e(e).sub(t);return o.validateSufficientBalance(r),r.eq(o.bn(0))&&n.eq(o.bn(0))?[]:(o.validateSameOwner(e.map((e=>e.compressedAccount))),Oe(e),[{owner:e[0].parsed.owner,amount:r,lamports:n,tlv:null}])}class Le{constructor(){}static get program(){return this._program||this.initializeProgram(),this._program}static initializeProgram(){if(!this._program){const e=s.Keypair.generate(),t=new s.Connection("http://127.0.0.1:8899","confirmed"),n=new i.AnchorProvider(t,o.useWallet(e),o.confirmConfig);i.setProvider(n),this._program=new i.Program(c,this.programId,n)}}static deriveTokenPoolPda(e){const t=[d,e.toBuffer()],[n,r]=s.PublicKey.findProgramAddressSync(t,this.programId);return n}static get deriveCpiAuthorityPda(){const[e,t]=s.PublicKey.findProgramAddressSync([l],this.programId);return e}static async createMint(e){const{mint:t,authority:n,feePayer:o,rentExemptBalance:i}=e,a=s.SystemProgram.createAccount({fromPubkey:o,lamports:i,newAccountPubkey:t,programId:p,space:Te}),c=function(e,t,n,o,i=p){const a=[{pubkey:e,isSigner:!1,isWritable:!0}],c=r.alloc(Ce.span);return Ce.encode({instruction:we.InitializeMint2,decimals:t,mintAuthority:n,freezeAuthority:o},c),new s.TransactionInstruction({keys:a,programId:i,data:c})}(t,e.decimals,n,e.freezeAuthority,p);return[a,c,await this.createTokenPool({feePayer:o,mint:t})]}static async createTokenPool(e){const{mint:t,feePayer:n}=e,r=this.deriveTokenPoolPda(t);return await this.program.methods.createTokenPool().accounts({mint:t,feePayer:n,tokenPoolPda:r,systemProgram:s.SystemProgram.programId,tokenProgram:p,cpiAuthorityPda:this.deriveCpiAuthorityPda}).instruction()}static async mintTo(e){const t=o.defaultStaticAccountsStruct(),{mint:n,feePayer:r,authority:s,merkleTree:i,toPubkey:a,amount:c}=e,u=this.deriveTokenPoolPda(n),d=o.toArray(c).map((e=>o.bn(e))),l=o.toArray(a);if(d.length!==l.length)throw new Error("Amount and toPubkey arrays must have the same length");return await this.program.methods.mintTo(l,d,null).accounts({feePayer:r,authority:s,cpiAuthorityPda:this.deriveCpiAuthorityPda,mint:n,tokenPoolPda:u,tokenProgram:p,lightSystemProgram:o.LightSystemProgram.programId,registeredProgramPda:t.registeredProgramPda,noopProgram:t.noopProgram,accountCompressionAuthority:t.accountCompressionAuthority,accountCompressionProgram:t.accountCompressionProgram,merkleTree:null!=i?i:o.defaultTestStateTreeAccounts().merkleTree,selfProgram:this.programId,solPoolPda:null}).instruction()}static async approveAndMintTo(e){const{mint:t,feePayer:n,authorityTokenAccount:r,authority:o,merkleTree:s,toPubkey:i}=e;return[xe(t,r,o,BigInt(e.amount.toString())),await this.compress({payer:n,owner:o,source:r,toAddress:i,mint:t,amount:e.amount,outputStateTree:s})]}static async transfer(e){const{payer:t,inputCompressedTokenAccounts:n,recentInputStateRootIndices:r,recentValidityProof:s,amount:i,outputStateTrees:a,toAddress:c}=e,d=De(n,c,i),{inputTokenDataWithContext:l,packedOutputTokenData:p,remainingAccountMetas:m}=u({inputCompressedTokenAccounts:n,outputStateTrees:a,rootIndices:r,tokenTransferOutputs:d}),{mint:h,currentOwner:f}=Ne(n),g={proof:s,mint:h,delegatedTransfer:null,inputTokenDataWithContext:l,outputCompressedAccounts:p,compressOrDecompressAmount:null,isCompress:!1,cpiContext:null,lamportsChangeAccountMerkleTreeIndex:null},y=this.program.coder.types.encode("CompressedTokenInstructionDataTransfer",g),{accountCompressionAuthority:w,noopProgram:b,registeredProgramPda:A,accountCompressionProgram:S}=o.defaultStaticAccountsStruct();return await this.program.methods.transfer(y).accounts({feePayer:t,authority:f,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:o.LightSystemProgram.programId,registeredProgramPda:A,noopProgram:b,accountCompressionAuthority:w,accountCompressionProgram:S,selfProgram:this.programId,tokenPoolPda:null,compressOrDecompressTokenAccount:null,tokenProgram:null}).remainingAccounts(m).instruction()}static async createTokenProgramLookupTable(e){const{authority:t,mints:n,recentSlot:r,payer:i,remainingAccounts:a}=e,[c,u]=s.AddressLookupTableProgram.createLookupTable({authority:t,payer:t,recentSlot:r});let d=[];return n&&(d=[...n,...n.map((e=>this.deriveTokenPoolPda(e)))]),{instructions:[c,s.AddressLookupTableProgram.extendLookupTable({payer:i,authority:t,lookupTable:u,addresses:[this.deriveCpiAuthorityPda,o.LightSystemProgram.programId,o.defaultStaticAccountsStruct().registeredProgramPda,o.defaultStaticAccountsStruct().noopProgram,o.defaultStaticAccountsStruct().accountCompressionAuthority,o.defaultStaticAccountsStruct().accountCompressionProgram,o.defaultTestStateTreeAccounts().merkleTree,o.defaultTestStateTreeAccounts().nullifierQueue,o.defaultTestStateTreeAccounts().addressTree,o.defaultTestStateTreeAccounts().addressQueue,this.programId,p,t,...d,...null!=a?a:[]]})],address:u}}static async compress(e){const{payer:t,owner:n,source:r,toAddress:s,mint:a,outputStateTree:c}=e;if(Array.isArray(e.amount)!==Array.isArray(e.toAddress))throw new Error("Both amount and toAddress must be arrays or both must be single values");let d;if(Array.isArray(e.amount)&&Array.isArray(e.toAddress)){if(e.amount.length!==e.toAddress.length)throw new Error("Amount and toAddress arrays must have the same length");d=e.amount.map(((t,n)=>{const r=o.bn(t);return{owner:e.toAddress[n],amount:r,lamports:o.bn(0),tlv:null}}))}else d=[{owner:s,amount:o.bn(e.amount),lamports:o.bn(0),tlv:null}];const{inputTokenDataWithContext:l,packedOutputTokenData:m,remainingAccountMetas:h}=u({inputCompressedTokenAccounts:[],outputStateTrees:c,rootIndices:[],tokenTransferOutputs:d}),f={proof:null,mint:a,delegatedTransfer:null,inputTokenDataWithContext:l,outputCompressedAccounts:m,compressOrDecompressAmount:Array.isArray(e.amount)?e.amount.map((e=>new i.BN(e))).reduce(((e,t)=>e.add(t)),new i.BN(0)):new i.BN(e.amount),isCompress:!0,cpiContext:null,lamportsChangeAccountMerkleTreeIndex:null},g=this.program.coder.types.encode("CompressedTokenInstructionDataTransfer",f);return await this.program.methods.transfer(g).accounts({feePayer:t,authority:n,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:o.LightSystemProgram.programId,registeredProgramPda:o.defaultStaticAccountsStruct().registeredProgramPda,noopProgram:o.defaultStaticAccountsStruct().noopProgram,accountCompressionAuthority:o.defaultStaticAccountsStruct().accountCompressionAuthority,accountCompressionProgram:o.defaultStaticAccountsStruct().accountCompressionProgram,selfProgram:this.programId,tokenPoolPda:this.deriveTokenPoolPda(a),compressOrDecompressTokenAccount:r,tokenProgram:p}).remainingAccounts(h).instruction()}static async decompress(e){const{payer:t,inputCompressedTokenAccounts:n,toAddress:r,outputStateTree:s,recentValidityProof:i,recentInputStateRootIndices:a}=e,c=o.bn(e.amount),d=Be(n,c),{inputTokenDataWithContext:l,packedOutputTokenData:m,remainingAccountMetas:h}=u({inputCompressedTokenAccounts:n,outputStateTrees:s,rootIndices:a,tokenTransferOutputs:d}),{mint:f,currentOwner:g}=Ne(n),y={proof:i,mint:f,delegatedTransfer:null,inputTokenDataWithContext:l,outputCompressedAccounts:m,compressOrDecompressAmount:c,isCompress:!1,cpiContext:null,lamportsChangeAccountMerkleTreeIndex:null},w=this.program.coder.types.encode("CompressedTokenInstructionDataTransfer",y),{accountCompressionAuthority:b,noopProgram:A,registeredProgramPda:S,accountCompressionProgram:k}=o.defaultStaticAccountsStruct();return await this.program.methods.transfer(w).accounts({feePayer:t,authority:g,cpiAuthorityPda:this.deriveCpiAuthorityPda,lightSystemProgram:o.LightSystemProgram.programId,registeredProgramPda:S,noopProgram:A,accountCompressionAuthority:b,accountCompressionProgram:k,selfProgram:this.programId,tokenPoolPda:this.deriveTokenPoolPda(f),compressOrDecompressTokenAccount:r,tokenProgram:p}).remainingAccounts(h).instruction()}static async mergeTokenAccounts(e){const{payer:t,owner:n,inputCompressedTokenAccounts:r,outputStateTree:o,recentValidityProof:s,recentInputStateRootIndices:a}=e;if(r.length>3)throw new Error("Cannot merge more than 3 token accounts at once");return[await this.transfer({payer:t,inputCompressedTokenAccounts:r,toAddress:n,amount:r.reduce(((e,t)=>e.add(t.parsed.amount)),new i.BN(0)),outputStateTrees:o,recentInputStateRootIndices:a,recentValidityProof:s})]}}function Ue(e,t){let n=o.bn(0),r=o.bn(0);const s=[];e.sort(((e,t)=>t.parsed.amount.cmp(e.parsed.amount)));for(const i of e){if(n.gte(o.bn(t)))break;n=n.add(i.parsed.amount),r=r.add(i.compressedAccount.lamports),s.push(i)}if(n.lt(o.bn(t)))throw new Error(`Not enough balance for transfer. Required: ${t.toString()}, available: ${n.toString()}`);return[s,n,r.lt(o.bn(0))?r:null]}Le.programId=new s.PublicKey("cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m"),Le._program=null,t.CPI_AUTHORITY_SEED=l,t.CompressedTokenProgram=Le,t.IDL=c,t.POOL_SEED=d,t.SPL_TOKEN_MINT_RENT_EXEMPT_BALANCE=1461600,t.approveAndMintTo=async function(e,t,n,r,i,a,c,u){const d=await Me(e,t,n,i.publicKey),l=await Le.approveAndMintTo({feePayer:t.publicKey,mint:n,authority:i.publicKey,authorityTokenAccount:d.address,amount:a,toPubkey:r,merkleTree:c}),{blockhash:p}=await e.getLatestBlockhash(),m=o.dedupeSigner(t,[i]),h=o.buildAndSignTx([s.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),...l],t,p,m);return await o.sendAndConfirmTx(e,h,u)},t.compress=async function(e,t,n,r,i,a,c,u,d){const l=await Le.compress({payer:t.publicKey,owner:i.publicKey,source:a,toAddress:c,amount:r,mint:n,outputStateTree:u}),p=await e.getLatestBlockhash(),m=o.dedupeSigner(t,[i]),h=o.buildAndSignTx([s.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),l],t,p.blockhash,m);return await o.sendAndConfirmTx(e,h,d,p)},t.createDecompressOutputState=Be,t.createMint=async function(e,t,n,r,i=s.Keypair.generate(),a){const c=await e.getMinimumBalanceForRentExemption(Te),u=await Le.createMint({feePayer:t.publicKey,mint:i.publicKey,decimals:r,authority:n,freezeAuthority:null,rentExemptBalance:c}),{blockhash:d}=await e.getLatestBlockhash(),l=o.dedupeSigner(t,[i]),p=o.buildAndSignTx(u,t,d,l),m=await o.sendAndConfirmTx(e,p,a);return{mint:i.publicKey,transactionSignature:m}},t.createTokenPool=async function(e,t,n,r){const s=await Le.createTokenPool({feePayer:t.publicKey,mint:n}),{blockhash:i}=await e.getLatestBlockhash(),a=o.buildAndSignTx([s],t,i);return await o.sendAndConfirmTx(e,a,r)},t.createTokenProgramLookupTable=async function(e,t,n,r,s){const i=await e.getSlot("finalized"),{instructions:a,address:c}=await Le.createTokenProgramLookupTable({payer:t.publicKey,authority:n.publicKey,mints:r,remainingAccounts:s,recentSlot:i}),u=o.dedupeSigner(t,[n]),d=await e.getLatestBlockhash(),l=o.buildAndSignTx([a[0]],t,d.blockhash,u),p=await o.sendAndConfirmTx(e,l,{commitment:"finalized"},d),m=await e.getLatestBlockhash(),h=o.buildAndSignTx([a[1]],t,m.blockhash,u);return{txIds:[p,await o.sendAndConfirmTx(e,h,{commitment:"finalized"},m)],address:c}},t.createTransferOutputState=De,t.decompress=async function(e,t,n,r,i,a,c,u){r=o.bn(r);const d=await e.getCompressedTokenAccountsByOwner(i.publicKey,{mint:n}),[l]=Ue(d.items,r),p=await e.getValidityProof(l.map((e=>o.bn(e.compressedAccount.hash)))),m=await Le.decompress({payer:t.publicKey,inputCompressedTokenAccounts:l,toAddress:a,amount:r,outputStateTree:c,recentInputStateRootIndices:p.rootIndices,recentValidityProof:p.compressedProof}),{blockhash:h}=await e.getLatestBlockhash(),f=o.dedupeSigner(t,[i]),g=o.buildAndSignTx([s.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),m],t,h,f);return await o.sendAndConfirmTx(e,g,u)},t.mergeTokenAccounts=async function(e,t,n,r,i,a){const c=await e.getCompressedTokenAccountsByOwner(r.publicKey,{mint:n});if(0===c.items.length)throw new Error(`No compressed token accounts found for mint ${n.toBase58()}`);if(c.items.length>=6)throw new Error(`Too many compressed token accounts used for mint ${n.toBase58()}`);const u=[s.ComputeBudgetProgram.setComputeUnitLimit({units:1e6})];for(let s=0;s<c.items.slice(0,6).length;s+=3){const a=c.items.slice(s,s+3),d=await e.getValidityProof(a.map((e=>o.bn(e.compressedAccount.hash)))),l=await Le.mergeTokenAccounts({payer:t.publicKey,owner:r.publicKey,mint:n,inputCompressedTokenAccounts:a,outputStateTree:i,recentValidityProof:d.compressedProof,recentInputStateRootIndices:d.rootIndices});u.push(...l)}const{blockhash:d}=await e.getLatestBlockhash(),l=o.dedupeSigner(t,[r]),p=o.buildAndSignTx(u,t,d,l);return await o.sendAndConfirmTx(e,p,a)},t.mintTo=async function(e,t,n,r,i,a,c,u){const d=o.dedupeSigner(t,[i]),l=await Le.mintTo({feePayer:t.publicKey,mint:n,authority:i.publicKey,amount:a,toPubkey:r,merkleTree:c}),{blockhash:p}=await e.getLatestBlockhash(),m=o.buildAndSignTx([s.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),l],t,p,d);return await o.sendAndConfirmTx(e,m,u)},t.packCompressedTokenAccounts=u,t.parseTokenData=Ne,t.selectMinCompressedTokenAccountsForTransfer=Ue,t.sumUpTokenAmount=_e,t.transfer=async function(e,t,n,r,i,a,c,u){r=o.bn(r);const d=await e.getCompressedTokenAccountsByOwner(i.publicKey,{mint:n}),[l]=Ue(d.items,r),p=await e.getValidityProof(l.map((e=>o.bn(e.compressedAccount.hash)))),m=await Le.transfer({payer:t.publicKey,inputCompressedTokenAccounts:l,toAddress:a,amount:r,recentInputStateRootIndices:p.rootIndices,recentValidityProof:p.compressedProof,outputStateTrees:c}),{blockhash:h}=await e.getLatestBlockhash(),f=o.dedupeSigner(t,[i]),g=o.buildAndSignTx([s.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),m],t,h,f);return await o.sendAndConfirmTx(e,g,u)},t.validateSameTokenOwner=Oe},679176:(e,t,n)=>{var r=n(348834).Buffer,o=n(627158),s=n(564861),i=n(348834),a=n(405634),c=n(443335);const u={version:"1.2.0",name:"light_system_program",constants:[{name:"SOL_POOL_PDA_SEED",type:"bytes",value:"[115, 111, 108, 95, 112, 111, 111, 108, 95, 112, 100, 97]"}],instructions:[{name:"initCpiContextAccount",accounts:[{name:"feePayer",isMut:!0,isSigner:!0},{name:"cpiContextAccount",isMut:!0,isSigner:!1},{name:"associatedMerkleTree",isMut:!1,isSigner:!1}],args:[]},{name:"invoke",accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["Fee payer needs to be mutable to pay rollover and protocol fees."]},{name:"authority",isMut:!1,isSigner:!0},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1,docs:["This pda is used to invoke the account compression program."]},{name:"accountCompressionProgram",isMut:!1,isSigner:!1,docs:["Merkle trees."]},{name:"solPoolPda",isMut:!0,isSigner:!1,isOptional:!0,docs:["Sol pool pda is used to store the native sol that has been compressed.","It's only required when compressing or decompressing sol."]},{name:"decompressionRecipient",isMut:!0,isSigner:!1,isOptional:!0,docs:["Only needs to be provided for decompression as a recipient for the","decompressed sol.","Compressed sol originate from authority."]},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"inputs",type:"bytes"}]},{name:"invokeCpi",accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["Fee payer needs to be mutable to pay rollover and protocol fees."]},{name:"authority",isMut:!1,isSigner:!0},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"invokingProgram",isMut:!1,isSigner:!1},{name:"solPoolPda",isMut:!0,isSigner:!1,isOptional:!0},{name:"decompressionRecipient",isMut:!0,isSigner:!1,isOptional:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"cpiContextAccount",isMut:!0,isSigner:!1,isOptional:!0}],args:[{name:"inputs",type:"bytes"}]},{name:"stubIdlBuild",docs:["This function is a stub to allow Anchor to include the input types in","the IDL. It should not be included in production builds nor be called in","practice."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["Fee payer needs to be mutable to pay rollover and protocol fees."]},{name:"authority",isMut:!1,isSigner:!0},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1,docs:["This pda is used to invoke the account compression program."]},{name:"accountCompressionProgram",isMut:!1,isSigner:!1,docs:["Merkle trees."]},{name:"solPoolPda",isMut:!0,isSigner:!1,isOptional:!0,docs:["Sol pool pda is used to store the native sol that has been compressed.","It's only required when compressing or decompressing sol."]},{name:"decompressionRecipient",isMut:!0,isSigner:!1,isOptional:!0,docs:["Only needs to be provided for decompression as a recipient for the","decompressed sol.","Compressed sol originate from authority."]},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"inputs1",type:{defined:"InstructionDataInvoke"}},{name:"inputs2",type:{defined:"InstructionDataInvokeCpi"}},{name:"inputs3",type:{defined:"PublicTransactionEvent"}}]}],accounts:[{name:"stateMerkleTreeAccount",docs:["Concurrent state Merkle tree used for public compressed transactions."],type:{kind:"struct",fields:[{name:"metadata",type:{defined:"MerkleTreeMetadata"}}]}},{name:"cpiContextAccount",docs:["Collects instruction data without executing a compressed transaction.","Signer checks are performed on instruction data.","Collected instruction data is combined with the instruction data of the executing cpi,","and executed as a single transaction.","This enables to use input compressed accounts that are owned by multiple programs,","with one zero-knowledge proof."],type:{kind:"struct",fields:[{name:"feePayer",type:"publicKey"},{name:"associatedMerkleTree",type:"publicKey"},{name:"context",type:{vec:{defined:"InstructionDataInvokeCpi"}}}]}}],types:[{name:"AccessMetadata",type:{kind:"struct",fields:[{name:"owner",docs:["Owner of the Merkle tree."],type:"publicKey"},{name:"programOwner",docs:["Program owner of the Merkle tree. This will be used for program owned Merkle trees."],type:"publicKey"},{name:"forester",docs:["Optional privileged forester pubkey, can be set for custom Merkle trees","without a network fee. Merkle trees without network fees are not","forested by light foresters. The variable is not used in the account","compression program but the registry program. The registry program","implements access control to prevent contention during forester. The","forester pubkey specified in this struct can bypass contention checks."],type:"publicKey"}]}},{name:"MerkleTreeMetadata",type:{kind:"struct",fields:[{name:"accessMetadata",type:{defined:"AccessMetadata"}},{name:"rolloverMetadata",type:{defined:"RolloverMetadata"}},{name:"associatedQueue",type:"publicKey"},{name:"nextMerkleTree",type:"publicKey"}]}},{name:"RolloverMetadata",type:{kind:"struct",fields:[{name:"index",docs:["Unique index."],type:"u64"},{name:"rolloverFee",docs:["This fee is used for rent for the next account.","It accumulates in the account so that once the corresponding Merkle tree account is full it can be rolled over"],type:"u64"},{name:"rolloverThreshold",docs:["The threshold in percentage points when the account should be rolled over (95 corresponds to 95% filled)."],type:"u64"},{name:"networkFee",docs:["Tip for maintaining the account."],type:"u64"},{name:"rolledoverSlot",docs:["The slot when the account was rolled over, a rolled over account should not be written to."],type:"u64"},{name:"closeThreshold",docs:["If current slot is greater than rolledover_slot + close_threshold and","the account is empty it can be closed. No 'close' functionality has been","implemented yet."],type:"u64"},{name:"additionalBytes",docs:["Placeholder for bytes of additional accounts which are tied to the","Merkle trees operation and need to be rolled over as well."],type:"u64"}]}},{name:"InstructionDataInvoke",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"inputCompressedAccountsWithMerkleContext",type:{vec:{defined:"PackedCompressedAccountWithMerkleContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"relayFee",type:{option:"u64"}},{name:"newAddressParams",type:{vec:{defined:"NewAddressParamsPacked"}}},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"isCompress",type:"bool"}]}},{name:"NewAddressParamsPacked",type:{kind:"struct",fields:[{name:"seed",type:{array:["u8",32]}},{name:"addressQueueAccountIndex",type:"u8"},{name:"addressMerkleTreeAccountIndex",type:"u8"},{name:"addressMerkleTreeRootIndex",type:"u16"}]}},{name:"OutputCompressedAccountWithPackedContext",type:{kind:"struct",fields:[{name:"compressedAccount",type:{defined:"CompressedAccount"}},{name:"merkleTreeIndex",type:"u8"}]}},{name:"CompressedProof",type:{kind:"struct",fields:[{name:"a",type:{array:["u8",32]}},{name:"b",type:{array:["u8",64]}},{name:"c",type:{array:["u8",32]}}]}},{name:"InstructionDataInvokeCpi",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"newAddressParams",type:{vec:{defined:"NewAddressParamsPacked"}}},{name:"inputCompressedAccountsWithMerkleContext",type:{vec:{defined:"PackedCompressedAccountWithMerkleContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"relayFee",type:{option:"u64"}},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"isCompress",type:"bool"},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}}]}},{name:"CompressedCpiContext",type:{kind:"struct",fields:[{name:"setContext",docs:["Is set by the program that is invoking the CPI to signal that is should","set the cpi context."],type:"bool"},{name:"firstSetContext",docs:["Is set to wipe the cpi context since someone could have set it before","with unrelated data."],type:"bool"},{name:"cpiContextAccountIndex",docs:["Index of cpi context account in remaining accounts."],type:"u8"}]}},{name:"CompressedAccount",type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"lamports",type:"u64"},{name:"address",type:{option:{array:["u8",32]}}},{name:"data",type:{option:{defined:"CompressedAccountData"}}}]}},{name:"CompressedAccountData",type:{kind:"struct",fields:[{name:"discriminator",type:{array:["u8",8]}},{name:"data",type:"bytes"},{name:"dataHash",type:{array:["u8",32]}}]}},{name:"PackedCompressedAccountWithMerkleContext",type:{kind:"struct",fields:[{name:"compressedAccount",type:{defined:"CompressedAccount"}},{name:"merkleContext",type:{defined:"PackedMerkleContext"}},{name:"rootIndex",docs:["Index of root used in inclusion validity proof."],type:"u16"},{name:"readOnly",docs:["Placeholder to mark accounts read-only unimplemented set to false."],type:"bool"}]}},{name:"PackedMerkleContext",type:{kind:"struct",fields:[{name:"merkleTreePubkeyIndex",type:"u8"},{name:"nullifierQueuePubkeyIndex",type:"u8"},{name:"leafIndex",type:"u32"},{name:"queueIndex",docs:["Index of leaf in queue. Placeholder of batched Merkle tree updates","currently unimplemented."],type:{option:{defined:"QueueIndex"}}}]}},{name:"QueueIndex",type:{kind:"struct",fields:[{name:"queueId",docs:["Id of queue in queue account."],type:"u8"},{name:"index",docs:["Index of compressed account hash in queue."],type:"u16"}]}},{name:"MerkleTreeSequenceNumber",type:{kind:"struct",fields:[{name:"pubkey",type:"publicKey"},{name:"seq",type:"u64"}]}},{name:"PublicTransactionEvent",type:{kind:"struct",fields:[{name:"inputCompressedAccountHashes",type:{vec:{array:["u8",32]}}},{name:"outputCompressedAccountHashes",type:{vec:{array:["u8",32]}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"outputLeafIndices",type:{vec:"u32"}},{name:"sequenceNumbers",type:{vec:{defined:"MerkleTreeSequenceNumber"}}},{name:"relayFee",type:{option:"u64"}},{name:"isCompress",type:"bool"},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"pubkeyArray",type:{vec:"publicKey"}},{name:"message",type:{option:"bytes"}}]}}],errors:[{code:6e3,name:"SumCheckFailed",msg:"Sum check failed"},{code:6001,name:"SignerCheckFailed",msg:"Signer check failed"},{code:6002,name:"CpiSignerCheckFailed",msg:"Cpi signer check failed"},{code:6003,name:"ComputeInputSumFailed",msg:"Computing input sum failed."},{code:6004,name:"ComputeOutputSumFailed",msg:"Computing output sum failed."},{code:6005,name:"ComputeRpcSumFailed",msg:"Computing rpc sum failed."},{code:6006,name:"InvalidAddress",msg:"InvalidAddress"},{code:6007,name:"DeriveAddressError",msg:"DeriveAddressError"},{code:6008,name:"CompressedSolPdaUndefinedForCompressSol",msg:"CompressedSolPdaUndefinedForCompressSol"},{code:6009,name:"DeCompressLamportsUndefinedForCompressSol",msg:"DeCompressLamportsUndefinedForCompressSol"},{code:6010,name:"CompressedSolPdaUndefinedForDecompressSol",msg:"CompressedSolPdaUndefinedForDecompressSol"},{code:6011,name:"DeCompressLamportsUndefinedForDecompressSol",msg:"DeCompressLamportsUndefinedForDecompressSol"},{code:6012,name:"DecompressRecipientUndefinedForDecompressSol",msg:"DecompressRecipientUndefinedForDecompressSol"},{code:6013,name:"WriteAccessCheckFailed",msg:"WriteAccessCheckFailed"},{code:6014,name:"InvokingProgramNotProvided",msg:"InvokingProgramNotProvided"},{code:6015,name:"InvalidCapacity",msg:"InvalidCapacity"},{code:6016,name:"InvalidMerkleTreeOwner",msg:"InvalidMerkleTreeOwner"},{code:6017,name:"ProofIsNone",msg:"ProofIsNone"},{code:6018,name:"ProofIsSome",msg:"Proof is some but no input compressed accounts or new addresses provided."},{code:6019,name:"EmptyInputs",msg:"EmptyInputs"},{code:6020,name:"CpiContextAccountUndefined",msg:"CpiContextAccountUndefined"},{code:6021,name:"CpiContextEmpty",msg:"CpiContextEmpty"},{code:6022,name:"CpiContextMissing",msg:"CpiContextMissing"},{code:6023,name:"DecompressionRecipientDefined",msg:"DecompressionRecipientDefined"},{code:6024,name:"SolPoolPdaDefined",msg:"SolPoolPdaDefined"},{code:6025,name:"AppendStateFailed",msg:"AppendStateFailed"},{code:6026,name:"InstructionNotCallable",msg:"The instruction is not callable"},{code:6027,name:"CpiContextFeePayerMismatch",msg:"CpiContextFeePayerMismatch"},{code:6028,name:"CpiContextAssociatedMerkleTreeMismatch",msg:"CpiContextAssociatedMerkleTreeMismatch"},{code:6029,name:"NoInputs",msg:"NoInputs"},{code:6030,name:"InputMerkleTreeIndicesNotInOrder",msg:"Input merkle tree indices are not in ascending order."},{code:6031,name:"OutputMerkleTreeIndicesNotInOrder",msg:"Output merkle tree indices are not in ascending order."},{code:6032,name:"OutputMerkleTreeNotUnique"},{code:6033,name:"DataFieldUndefined"}]};var d="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:void 0!==n.g?n.g:"undefined"!=typeof self?self:{};function l(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function p(e){throw new Error('Could not dynamically require "'+e+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var m,h={exports:{}};!function(e){var t=function(e){var t,n=new Float64Array(16);if(e)for(t=0;t<e.length;t++)n[t]=e[t];return n},n=function(){throw new Error("no PRNG")},r=new Uint8Array(16),o=new Uint8Array(32);o[0]=9;var s=t(),i=t([1]),c=t([56129,1]),u=t([30883,4953,19914,30187,55467,16705,2637,112,59544,30585,16505,36039,65139,11119,27886,20995]),d=t([61785,9906,39828,60374,45398,33411,5274,224,53552,61171,33010,6542,64743,22239,55772,9222]),l=t([54554,36645,11616,51542,42930,38181,51040,26924,56412,64982,57905,49316,21502,52590,14035,8553]),m=t([26200,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214]),h=t([41136,18958,6951,50414,58488,44335,6150,12099,55207,15867,153,11085,57099,20417,9344,11139]);function f(e,t,n,r){e[t]=n>>24&255,e[t+1]=n>>16&255,e[t+2]=n>>8&255,e[t+3]=255&n,e[t+4]=r>>24&255,e[t+5]=r>>16&255,e[t+6]=r>>8&255,e[t+7]=255&r}function g(e,t,n,r,o){var s,i=0;for(s=0;s<o;s++)i|=e[t+s]^n[r+s];return(1&i-1>>>8)-1}function y(e,t,n,r){return g(e,t,n,r,16)}function w(e,t,n,r){return g(e,t,n,r,32)}function b(e,t,n,r){!function(e,t,n,r){for(var o,s=255&r[0]|(255&r[1])<<8|(255&r[2])<<16|(255&r[3])<<24,i=255&n[0]|(255&n[1])<<8|(255&n[2])<<16|(255&n[3])<<24,a=255&n[4]|(255&n[5])<<8|(255&n[6])<<16|(255&n[7])<<24,c=255&n[8]|(255&n[9])<<8|(255&n[10])<<16|(255&n[11])<<24,u=255&n[12]|(255&n[13])<<8|(255&n[14])<<16|(255&n[15])<<24,d=255&r[4]|(255&r[5])<<8|(255&r[6])<<16|(255&r[7])<<24,l=255&t[0]|(255&t[1])<<8|(255&t[2])<<16|(255&t[3])<<24,p=255&t[4]|(255&t[5])<<8|(255&t[6])<<16|(255&t[7])<<24,m=255&t[8]|(255&t[9])<<8|(255&t[10])<<16|(255&t[11])<<24,h=255&t[12]|(255&t[13])<<8|(255&t[14])<<16|(255&t[15])<<24,f=255&r[8]|(255&r[9])<<8|(255&r[10])<<16|(255&r[11])<<24,g=255&n[16]|(255&n[17])<<8|(255&n[18])<<16|(255&n[19])<<24,y=255&n[20]|(255&n[21])<<8|(255&n[22])<<16|(255&n[23])<<24,w=255&n[24]|(255&n[25])<<8|(255&n[26])<<16|(255&n[27])<<24,b=255&n[28]|(255&n[29])<<8|(255&n[30])<<16|(255&n[31])<<24,A=255&r[12]|(255&r[13])<<8|(255&r[14])<<16|(255&r[15])<<24,S=s,k=i,P=a,E=c,v=u,T=d,C=l,M=p,I=m,x=h,_=f,O=g,N=y,D=w,B=b,L=A,U=0;U<20;U+=2)S^=(o=(N^=(o=(I^=(o=(v^=(o=S+N|0)<<7|o>>>25)+S|0)<<9|o>>>23)+v|0)<<13|o>>>19)+I|0)<<18|o>>>14,T^=(o=(k^=(o=(D^=(o=(x^=(o=T+k|0)<<7|o>>>25)+T|0)<<9|o>>>23)+x|0)<<13|o>>>19)+D|0)<<18|o>>>14,_^=(o=(C^=(o=(P^=(o=(B^=(o=_+C|0)<<7|o>>>25)+_|0)<<9|o>>>23)+B|0)<<13|o>>>19)+P|0)<<18|o>>>14,L^=(o=(O^=(o=(M^=(o=(E^=(o=L+O|0)<<7|o>>>25)+L|0)<<9|o>>>23)+E|0)<<13|o>>>19)+M|0)<<18|o>>>14,S^=(o=(E^=(o=(P^=(o=(k^=(o=S+E|0)<<7|o>>>25)+S|0)<<9|o>>>23)+k|0)<<13|o>>>19)+P|0)<<18|o>>>14,T^=(o=(v^=(o=(M^=(o=(C^=(o=T+v|0)<<7|o>>>25)+T|0)<<9|o>>>23)+C|0)<<13|o>>>19)+M|0)<<18|o>>>14,_^=(o=(x^=(o=(I^=(o=(O^=(o=_+x|0)<<7|o>>>25)+_|0)<<9|o>>>23)+O|0)<<13|o>>>19)+I|0)<<18|o>>>14,L^=(o=(B^=(o=(D^=(o=(N^=(o=L+B|0)<<7|o>>>25)+L|0)<<9|o>>>23)+N|0)<<13|o>>>19)+D|0)<<18|o>>>14;S=S+s|0,k=k+i|0,P=P+a|0,E=E+c|0,v=v+u|0,T=T+d|0,C=C+l|0,M=M+p|0,I=I+m|0,x=x+h|0,_=_+f|0,O=O+g|0,N=N+y|0,D=D+w|0,B=B+b|0,L=L+A|0,e[0]=S>>>0&255,e[1]=S>>>8&255,e[2]=S>>>16&255,e[3]=S>>>24&255,e[4]=k>>>0&255,e[5]=k>>>8&255,e[6]=k>>>16&255,e[7]=k>>>24&255,e[8]=P>>>0&255,e[9]=P>>>8&255,e[10]=P>>>16&255,e[11]=P>>>24&255,e[12]=E>>>0&255,e[13]=E>>>8&255,e[14]=E>>>16&255,e[15]=E>>>24&255,e[16]=v>>>0&255,e[17]=v>>>8&255,e[18]=v>>>16&255,e[19]=v>>>24&255,e[20]=T>>>0&255,e[21]=T>>>8&255,e[22]=T>>>16&255,e[23]=T>>>24&255,e[24]=C>>>0&255,e[25]=C>>>8&255,e[26]=C>>>16&255,e[27]=C>>>24&255,e[28]=M>>>0&255,e[29]=M>>>8&255,e[30]=M>>>16&255,e[31]=M>>>24&255,e[32]=I>>>0&255,e[33]=I>>>8&255,e[34]=I>>>16&255,e[35]=I>>>24&255,e[36]=x>>>0&255,e[37]=x>>>8&255,e[38]=x>>>16&255,e[39]=x>>>24&255,e[40]=_>>>0&255,e[41]=_>>>8&255,e[42]=_>>>16&255,e[43]=_>>>24&255,e[44]=O>>>0&255,e[45]=O>>>8&255,e[46]=O>>>16&255,e[47]=O>>>24&255,e[48]=N>>>0&255,e[49]=N>>>8&255,e[50]=N>>>16&255,e[51]=N>>>24&255,e[52]=D>>>0&255,e[53]=D>>>8&255,e[54]=D>>>16&255,e[55]=D>>>24&255,e[56]=B>>>0&255,e[57]=B>>>8&255,e[58]=B>>>16&255,e[59]=B>>>24&255,e[60]=L>>>0&255,e[61]=L>>>8&255,e[62]=L>>>16&255,e[63]=L>>>24&255}(e,t,n,r)}function A(e,t,n,r){!function(e,t,n,r){for(var o,s=255&r[0]|(255&r[1])<<8|(255&r[2])<<16|(255&r[3])<<24,i=255&n[0]|(255&n[1])<<8|(255&n[2])<<16|(255&n[3])<<24,a=255&n[4]|(255&n[5])<<8|(255&n[6])<<16|(255&n[7])<<24,c=255&n[8]|(255&n[9])<<8|(255&n[10])<<16|(255&n[11])<<24,u=255&n[12]|(255&n[13])<<8|(255&n[14])<<16|(255&n[15])<<24,d=255&r[4]|(255&r[5])<<8|(255&r[6])<<16|(255&r[7])<<24,l=255&t[0]|(255&t[1])<<8|(255&t[2])<<16|(255&t[3])<<24,p=255&t[4]|(255&t[5])<<8|(255&t[6])<<16|(255&t[7])<<24,m=255&t[8]|(255&t[9])<<8|(255&t[10])<<16|(255&t[11])<<24,h=255&t[12]|(255&t[13])<<8|(255&t[14])<<16|(255&t[15])<<24,f=255&r[8]|(255&r[9])<<8|(255&r[10])<<16|(255&r[11])<<24,g=255&n[16]|(255&n[17])<<8|(255&n[18])<<16|(255&n[19])<<24,y=255&n[20]|(255&n[21])<<8|(255&n[22])<<16|(255&n[23])<<24,w=255&n[24]|(255&n[25])<<8|(255&n[26])<<16|(255&n[27])<<24,b=255&n[28]|(255&n[29])<<8|(255&n[30])<<16|(255&n[31])<<24,A=255&r[12]|(255&r[13])<<8|(255&r[14])<<16|(255&r[15])<<24,S=0;S<20;S+=2)s^=(o=(y^=(o=(m^=(o=(u^=(o=s+y|0)<<7|o>>>25)+s|0)<<9|o>>>23)+u|0)<<13|o>>>19)+m|0)<<18|o>>>14,d^=(o=(i^=(o=(w^=(o=(h^=(o=d+i|0)<<7|o>>>25)+d|0)<<9|o>>>23)+h|0)<<13|o>>>19)+w|0)<<18|o>>>14,f^=(o=(l^=(o=(a^=(o=(b^=(o=f+l|0)<<7|o>>>25)+f|0)<<9|o>>>23)+b|0)<<13|o>>>19)+a|0)<<18|o>>>14,A^=(o=(g^=(o=(p^=(o=(c^=(o=A+g|0)<<7|o>>>25)+A|0)<<9|o>>>23)+c|0)<<13|o>>>19)+p|0)<<18|o>>>14,s^=(o=(c^=(o=(a^=(o=(i^=(o=s+c|0)<<7|o>>>25)+s|0)<<9|o>>>23)+i|0)<<13|o>>>19)+a|0)<<18|o>>>14,d^=(o=(u^=(o=(p^=(o=(l^=(o=d+u|0)<<7|o>>>25)+d|0)<<9|o>>>23)+l|0)<<13|o>>>19)+p|0)<<18|o>>>14,f^=(o=(h^=(o=(m^=(o=(g^=(o=f+h|0)<<7|o>>>25)+f|0)<<9|o>>>23)+g|0)<<13|o>>>19)+m|0)<<18|o>>>14,A^=(o=(b^=(o=(w^=(o=(y^=(o=A+b|0)<<7|o>>>25)+A|0)<<9|o>>>23)+y|0)<<13|o>>>19)+w|0)<<18|o>>>14;e[0]=s>>>0&255,e[1]=s>>>8&255,e[2]=s>>>16&255,e[3]=s>>>24&255,e[4]=d>>>0&255,e[5]=d>>>8&255,e[6]=d>>>16&255,e[7]=d>>>24&255,e[8]=f>>>0&255,e[9]=f>>>8&255,e[10]=f>>>16&255,e[11]=f>>>24&255,e[12]=A>>>0&255,e[13]=A>>>8&255,e[14]=A>>>16&255,e[15]=A>>>24&255,e[16]=l>>>0&255,e[17]=l>>>8&255,e[18]=l>>>16&255,e[19]=l>>>24&255,e[20]=p>>>0&255,e[21]=p>>>8&255,e[22]=p>>>16&255,e[23]=p>>>24&255,e[24]=m>>>0&255,e[25]=m>>>8&255,e[26]=m>>>16&255,e[27]=m>>>24&255,e[28]=h>>>0&255,e[29]=h>>>8&255,e[30]=h>>>16&255,e[31]=h>>>24&255}(e,t,n,r)}var S=new Uint8Array([101,120,112,97,110,100,32,51,50,45,98,121,116,101,32,107]);function k(e,t,n,r,o,s,i){var a,c,u=new Uint8Array(16),d=new Uint8Array(64);for(c=0;c<16;c++)u[c]=0;for(c=0;c<8;c++)u[c]=s[c];for(;o>=64;){for(b(d,u,i,S),c=0;c<64;c++)e[t+c]=n[r+c]^d[c];for(a=1,c=8;c<16;c++)a=a+(255&u[c])|0,u[c]=255&a,a>>>=8;o-=64,t+=64,r+=64}if(o>0)for(b(d,u,i,S),c=0;c<o;c++)e[t+c]=n[r+c]^d[c];return 0}function P(e,t,n,r,o){var s,i,a=new Uint8Array(16),c=new Uint8Array(64);for(i=0;i<16;i++)a[i]=0;for(i=0;i<8;i++)a[i]=r[i];for(;n>=64;){for(b(c,a,o,S),i=0;i<64;i++)e[t+i]=c[i];for(s=1,i=8;i<16;i++)s=s+(255&a[i])|0,a[i]=255&s,s>>>=8;n-=64,t+=64}if(n>0)for(b(c,a,o,S),i=0;i<n;i++)e[t+i]=c[i];return 0}function E(e,t,n,r,o){var s=new Uint8Array(32);A(s,r,o,S);for(var i=new Uint8Array(8),a=0;a<8;a++)i[a]=r[a+16];return P(e,t,n,i,s)}function v(e,t,n,r,o,s,i){var a=new Uint8Array(32);A(a,s,i,S);for(var c=new Uint8Array(8),u=0;u<8;u++)c[u]=s[u+16];return k(e,t,n,r,o,c,a)}var T=function(e){var t,n,r,o,s,i,a,c;this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.leftover=0,this.fin=0,t=255&e[0]|(255&e[1])<<8,this.r[0]=8191&t,n=255&e[2]|(255&e[3])<<8,this.r[1]=8191&(t>>>13|n<<3),r=255&e[4]|(255&e[5])<<8,this.r[2]=7939&(n>>>10|r<<6),o=255&e[6]|(255&e[7])<<8,this.r[3]=8191&(r>>>7|o<<9),s=255&e[8]|(255&e[9])<<8,this.r[4]=255&(o>>>4|s<<12),this.r[5]=s>>>1&8190,i=255&e[10]|(255&e[11])<<8,this.r[6]=8191&(s>>>14|i<<2),a=255&e[12]|(255&e[13])<<8,this.r[7]=8065&(i>>>11|a<<5),c=255&e[14]|(255&e[15])<<8,this.r[8]=8191&(a>>>8|c<<8),this.r[9]=c>>>5&127,this.pad[0]=255&e[16]|(255&e[17])<<8,this.pad[1]=255&e[18]|(255&e[19])<<8,this.pad[2]=255&e[20]|(255&e[21])<<8,this.pad[3]=255&e[22]|(255&e[23])<<8,this.pad[4]=255&e[24]|(255&e[25])<<8,this.pad[5]=255&e[26]|(255&e[27])<<8,this.pad[6]=255&e[28]|(255&e[29])<<8,this.pad[7]=255&e[30]|(255&e[31])<<8};function C(e,t,n,r,o,s){var i=new T(s);return i.update(n,r,o),i.finish(e,t),0}function M(e,t,n,r,o,s){var i=new Uint8Array(16);return C(i,0,n,r,o,s),y(e,t,i,0)}function I(e,t,n,r,o){var s;if(n<32)return-1;for(v(e,0,t,0,n,r,o),C(e,16,e,32,n-32,e),s=0;s<16;s++)e[s]=0;return 0}function x(e,t,n,r,o){var s,i=new Uint8Array(32);if(n<32)return-1;if(E(i,0,32,r,o),0!==M(t,16,t,32,n-32,i))return-1;for(v(e,0,t,0,n,r,o),s=0;s<32;s++)e[s]=0;return 0}function _(e,t){var n;for(n=0;n<16;n++)e[n]=0|t[n]}function O(e){var t,n,r=1;for(t=0;t<16;t++)n=e[t]+r+65535,r=Math.floor(n/65536),e[t]=n-65536*r;e[0]+=r-1+37*(r-1)}function N(e,t,n){for(var r,o=~(n-1),s=0;s<16;s++)r=o&(e[s]^t[s]),e[s]^=r,t[s]^=r}function D(e,n){var r,o,s,i=t(),a=t();for(r=0;r<16;r++)a[r]=n[r];for(O(a),O(a),O(a),o=0;o<2;o++){for(i[0]=a[0]-65517,r=1;r<15;r++)i[r]=a[r]-65535-(i[r-1]>>16&1),i[r-1]&=65535;i[15]=a[15]-32767-(i[14]>>16&1),s=i[15]>>16&1,i[14]&=65535,N(a,i,1-s)}for(r=0;r<16;r++)e[2*r]=255&a[r],e[2*r+1]=a[r]>>8}function B(e,t){var n=new Uint8Array(32),r=new Uint8Array(32);return D(n,e),D(r,t),w(n,0,r,0)}function L(e){var t=new Uint8Array(32);return D(t,e),1&t[0]}function U(e,t){var n;for(n=0;n<16;n++)e[n]=t[2*n]+(t[2*n+1]<<8);e[15]&=32767}function R(e,t,n){for(var r=0;r<16;r++)e[r]=t[r]+n[r]}function F(e,t,n){for(var r=0;r<16;r++)e[r]=t[r]-n[r]}function K(e,t,n){var r,o,s=0,i=0,a=0,c=0,u=0,d=0,l=0,p=0,m=0,h=0,f=0,g=0,y=0,w=0,b=0,A=0,S=0,k=0,P=0,E=0,v=0,T=0,C=0,M=0,I=0,x=0,_=0,O=0,N=0,D=0,B=0,L=n[0],U=n[1],R=n[2],F=n[3],K=n[4],z=n[5],$=n[6],V=n[7],W=n[8],H=n[9],q=n[10],j=n[11],Q=n[12],G=n[13],Y=n[14],X=n[15];s+=(r=t[0])*L,i+=r*U,a+=r*R,c+=r*F,u+=r*K,d+=r*z,l+=r*$,p+=r*V,m+=r*W,h+=r*H,f+=r*q,g+=r*j,y+=r*Q,w+=r*G,b+=r*Y,A+=r*X,i+=(r=t[1])*L,a+=r*U,c+=r*R,u+=r*F,d+=r*K,l+=r*z,p+=r*$,m+=r*V,h+=r*W,f+=r*H,g+=r*q,y+=r*j,w+=r*Q,b+=r*G,A+=r*Y,S+=r*X,a+=(r=t[2])*L,c+=r*U,u+=r*R,d+=r*F,l+=r*K,p+=r*z,m+=r*$,h+=r*V,f+=r*W,g+=r*H,y+=r*q,w+=r*j,b+=r*Q,A+=r*G,S+=r*Y,k+=r*X,c+=(r=t[3])*L,u+=r*U,d+=r*R,l+=r*F,p+=r*K,m+=r*z,h+=r*$,f+=r*V,g+=r*W,y+=r*H,w+=r*q,b+=r*j,A+=r*Q,S+=r*G,k+=r*Y,P+=r*X,u+=(r=t[4])*L,d+=r*U,l+=r*R,p+=r*F,m+=r*K,h+=r*z,f+=r*$,g+=r*V,y+=r*W,w+=r*H,b+=r*q,A+=r*j,S+=r*Q,k+=r*G,P+=r*Y,E+=r*X,d+=(r=t[5])*L,l+=r*U,p+=r*R,m+=r*F,h+=r*K,f+=r*z,g+=r*$,y+=r*V,w+=r*W,b+=r*H,A+=r*q,S+=r*j,k+=r*Q,P+=r*G,E+=r*Y,v+=r*X,l+=(r=t[6])*L,p+=r*U,m+=r*R,h+=r*F,f+=r*K,g+=r*z,y+=r*$,w+=r*V,b+=r*W,A+=r*H,S+=r*q,k+=r*j,P+=r*Q,E+=r*G,v+=r*Y,T+=r*X,p+=(r=t[7])*L,m+=r*U,h+=r*R,f+=r*F,g+=r*K,y+=r*z,w+=r*$,b+=r*V,A+=r*W,S+=r*H,k+=r*q,P+=r*j,E+=r*Q,v+=r*G,T+=r*Y,C+=r*X,m+=(r=t[8])*L,h+=r*U,f+=r*R,g+=r*F,y+=r*K,w+=r*z,b+=r*$,A+=r*V,S+=r*W,k+=r*H,P+=r*q,E+=r*j,v+=r*Q,T+=r*G,C+=r*Y,M+=r*X,h+=(r=t[9])*L,f+=r*U,g+=r*R,y+=r*F,w+=r*K,b+=r*z,A+=r*$,S+=r*V,k+=r*W,P+=r*H,E+=r*q,v+=r*j,T+=r*Q,C+=r*G,M+=r*Y,I+=r*X,f+=(r=t[10])*L,g+=r*U,y+=r*R,w+=r*F,b+=r*K,A+=r*z,S+=r*$,k+=r*V,P+=r*W,E+=r*H,v+=r*q,T+=r*j,C+=r*Q,M+=r*G,I+=r*Y,x+=r*X,g+=(r=t[11])*L,y+=r*U,w+=r*R,b+=r*F,A+=r*K,S+=r*z,k+=r*$,P+=r*V,E+=r*W,v+=r*H,T+=r*q,C+=r*j,M+=r*Q,I+=r*G,x+=r*Y,_+=r*X,y+=(r=t[12])*L,w+=r*U,b+=r*R,A+=r*F,S+=r*K,k+=r*z,P+=r*$,E+=r*V,v+=r*W,T+=r*H,C+=r*q,M+=r*j,I+=r*Q,x+=r*G,_+=r*Y,O+=r*X,w+=(r=t[13])*L,b+=r*U,A+=r*R,S+=r*F,k+=r*K,P+=r*z,E+=r*$,v+=r*V,T+=r*W,C+=r*H,M+=r*q,I+=r*j,x+=r*Q,_+=r*G,O+=r*Y,N+=r*X,b+=(r=t[14])*L,A+=r*U,S+=r*R,k+=r*F,P+=r*K,E+=r*z,v+=r*$,T+=r*V,C+=r*W,M+=r*H,I+=r*q,x+=r*j,_+=r*Q,O+=r*G,N+=r*Y,D+=r*X,A+=(r=t[15])*L,i+=38*(k+=r*R),a+=38*(P+=r*F),c+=38*(E+=r*K),u+=38*(v+=r*z),d+=38*(T+=r*$),l+=38*(C+=r*V),p+=38*(M+=r*W),m+=38*(I+=r*H),h+=38*(x+=r*q),f+=38*(_+=r*j),g+=38*(O+=r*Q),y+=38*(N+=r*G),w+=38*(D+=r*Y),b+=38*(B+=r*X),s=(r=(s+=38*(S+=r*U))+(o=1)+65535)-65536*(o=Math.floor(r/65536)),i=(r=i+o+65535)-65536*(o=Math.floor(r/65536)),a=(r=a+o+65535)-65536*(o=Math.floor(r/65536)),c=(r=c+o+65535)-65536*(o=Math.floor(r/65536)),u=(r=u+o+65535)-65536*(o=Math.floor(r/65536)),d=(r=d+o+65535)-65536*(o=Math.floor(r/65536)),l=(r=l+o+65535)-65536*(o=Math.floor(r/65536)),p=(r=p+o+65535)-65536*(o=Math.floor(r/65536)),m=(r=m+o+65535)-65536*(o=Math.floor(r/65536)),h=(r=h+o+65535)-65536*(o=Math.floor(r/65536)),f=(r=f+o+65535)-65536*(o=Math.floor(r/65536)),g=(r=g+o+65535)-65536*(o=Math.floor(r/65536)),y=(r=y+o+65535)-65536*(o=Math.floor(r/65536)),w=(r=w+o+65535)-65536*(o=Math.floor(r/65536)),b=(r=b+o+65535)-65536*(o=Math.floor(r/65536)),A=(r=A+o+65535)-65536*(o=Math.floor(r/65536)),s=(r=(s+=o-1+37*(o-1))+(o=1)+65535)-65536*(o=Math.floor(r/65536)),i=(r=i+o+65535)-65536*(o=Math.floor(r/65536)),a=(r=a+o+65535)-65536*(o=Math.floor(r/65536)),c=(r=c+o+65535)-65536*(o=Math.floor(r/65536)),u=(r=u+o+65535)-65536*(o=Math.floor(r/65536)),d=(r=d+o+65535)-65536*(o=Math.floor(r/65536)),l=(r=l+o+65535)-65536*(o=Math.floor(r/65536)),p=(r=p+o+65535)-65536*(o=Math.floor(r/65536)),m=(r=m+o+65535)-65536*(o=Math.floor(r/65536)),h=(r=h+o+65535)-65536*(o=Math.floor(r/65536)),f=(r=f+o+65535)-65536*(o=Math.floor(r/65536)),g=(r=g+o+65535)-65536*(o=Math.floor(r/65536)),y=(r=y+o+65535)-65536*(o=Math.floor(r/65536)),w=(r=w+o+65535)-65536*(o=Math.floor(r/65536)),b=(r=b+o+65535)-65536*(o=Math.floor(r/65536)),A=(r=A+o+65535)-65536*(o=Math.floor(r/65536)),s+=o-1+37*(o-1),e[0]=s,e[1]=i,e[2]=a,e[3]=c,e[4]=u,e[5]=d,e[6]=l,e[7]=p,e[8]=m,e[9]=h,e[10]=f,e[11]=g,e[12]=y,e[13]=w,e[14]=b,e[15]=A}function z(e,t){K(e,t,t)}function $(e,n){var r,o=t();for(r=0;r<16;r++)o[r]=n[r];for(r=253;r>=0;r--)z(o,o),2!==r&&4!==r&&K(o,o,n);for(r=0;r<16;r++)e[r]=o[r]}function V(e,n){var r,o=t();for(r=0;r<16;r++)o[r]=n[r];for(r=250;r>=0;r--)z(o,o),1!==r&&K(o,o,n);for(r=0;r<16;r++)e[r]=o[r]}function W(e,n,r){var o,s,i=new Uint8Array(32),a=new Float64Array(80),u=t(),d=t(),l=t(),p=t(),m=t(),h=t();for(s=0;s<31;s++)i[s]=n[s];for(i[31]=127&n[31]|64,i[0]&=248,U(a,r),s=0;s<16;s++)d[s]=a[s],p[s]=u[s]=l[s]=0;for(u[0]=p[0]=1,s=254;s>=0;--s)N(u,d,o=i[s>>>3]>>>(7&s)&1),N(l,p,o),R(m,u,l),F(u,u,l),R(l,d,p),F(d,d,p),z(p,m),z(h,u),K(u,l,u),K(l,d,m),R(m,u,l),F(u,u,l),z(d,u),F(l,p,h),K(u,l,c),R(u,u,p),K(l,l,u),K(u,p,h),K(p,d,a),z(d,m),N(u,d,o),N(l,p,o);for(s=0;s<16;s++)a[s+16]=u[s],a[s+32]=l[s],a[s+48]=d[s],a[s+64]=p[s];var f=a.subarray(32),g=a.subarray(16);return $(f,f),K(g,g,f),D(e,g),0}function H(e,t){return W(e,t,o)}function q(e,t){return n(t,32),H(e,t)}function j(e,t,n){var o=new Uint8Array(32);return W(o,n,t),A(e,r,o,S)}T.prototype.blocks=function(e,t,n){for(var r,o,s,i,a,c,u,d,l,p,m,h,f,g,y,w,b,A,S,k=this.fin?0:2048,P=this.h[0],E=this.h[1],v=this.h[2],T=this.h[3],C=this.h[4],M=this.h[5],I=this.h[6],x=this.h[7],_=this.h[8],O=this.h[9],N=this.r[0],D=this.r[1],B=this.r[2],L=this.r[3],U=this.r[4],R=this.r[5],F=this.r[6],K=this.r[7],z=this.r[8],$=this.r[9];n>=16;)p=l=0,p+=(P+=8191&(r=255&e[t+0]|(255&e[t+1])<<8))*N,p+=(E+=8191&(r>>>13|(o=255&e[t+2]|(255&e[t+3])<<8)<<3))*(5*$),p+=(v+=8191&(o>>>10|(s=255&e[t+4]|(255&e[t+5])<<8)<<6))*(5*z),p+=(T+=8191&(s>>>7|(i=255&e[t+6]|(255&e[t+7])<<8)<<9))*(5*K),l=(p+=(C+=8191&(i>>>4|(a=255&e[t+8]|(255&e[t+9])<<8)<<12))*(5*F))>>>13,p&=8191,p+=(M+=a>>>1&8191)*(5*R),p+=(I+=8191&(a>>>14|(c=255&e[t+10]|(255&e[t+11])<<8)<<2))*(5*U),p+=(x+=8191&(c>>>11|(u=255&e[t+12]|(255&e[t+13])<<8)<<5))*(5*L),p+=(_+=8191&(u>>>8|(d=255&e[t+14]|(255&e[t+15])<<8)<<8))*(5*B),m=l+=(p+=(O+=d>>>5|k)*(5*D))>>>13,m+=P*D,m+=E*N,m+=v*(5*$),m+=T*(5*z),l=(m+=C*(5*K))>>>13,m&=8191,m+=M*(5*F),m+=I*(5*R),m+=x*(5*U),m+=_*(5*L),l+=(m+=O*(5*B))>>>13,m&=8191,h=l,h+=P*B,h+=E*D,h+=v*N,h+=T*(5*$),l=(h+=C*(5*z))>>>13,h&=8191,h+=M*(5*K),h+=I*(5*F),h+=x*(5*R),h+=_*(5*U),f=l+=(h+=O*(5*L))>>>13,f+=P*L,f+=E*B,f+=v*D,f+=T*N,l=(f+=C*(5*$))>>>13,f&=8191,f+=M*(5*z),f+=I*(5*K),f+=x*(5*F),f+=_*(5*R),g=l+=(f+=O*(5*U))>>>13,g+=P*U,g+=E*L,g+=v*B,g+=T*D,l=(g+=C*N)>>>13,g&=8191,g+=M*(5*$),g+=I*(5*z),g+=x*(5*K),g+=_*(5*F),y=l+=(g+=O*(5*R))>>>13,y+=P*R,y+=E*U,y+=v*L,y+=T*B,l=(y+=C*D)>>>13,y&=8191,y+=M*N,y+=I*(5*$),y+=x*(5*z),y+=_*(5*K),w=l+=(y+=O*(5*F))>>>13,w+=P*F,w+=E*R,w+=v*U,w+=T*L,l=(w+=C*B)>>>13,w&=8191,w+=M*D,w+=I*N,w+=x*(5*$),w+=_*(5*z),b=l+=(w+=O*(5*K))>>>13,b+=P*K,b+=E*F,b+=v*R,b+=T*U,l=(b+=C*L)>>>13,b&=8191,b+=M*B,b+=I*D,b+=x*N,b+=_*(5*$),A=l+=(b+=O*(5*z))>>>13,A+=P*z,A+=E*K,A+=v*F,A+=T*R,l=(A+=C*U)>>>13,A&=8191,A+=M*L,A+=I*B,A+=x*D,A+=_*N,S=l+=(A+=O*(5*$))>>>13,S+=P*$,S+=E*z,S+=v*K,S+=T*F,l=(S+=C*R)>>>13,S&=8191,S+=M*U,S+=I*L,S+=x*B,S+=_*D,P=p=8191&(l=(l=((l+=(S+=O*N)>>>13)<<2)+l|0)+(p&=8191)|0),E=m+=l>>>=13,v=h&=8191,T=f&=8191,C=g&=8191,M=y&=8191,I=w&=8191,x=b&=8191,_=A&=8191,O=S&=8191,t+=16,n-=16;this.h[0]=P,this.h[1]=E,this.h[2]=v,this.h[3]=T,this.h[4]=C,this.h[5]=M,this.h[6]=I,this.h[7]=x,this.h[8]=_,this.h[9]=O},T.prototype.finish=function(e,t){var n,r,o,s,i=new Uint16Array(10);if(this.leftover){for(s=this.leftover,this.buffer[s++]=1;s<16;s++)this.buffer[s]=0;this.fin=1,this.blocks(this.buffer,0,16)}for(n=this.h[1]>>>13,this.h[1]&=8191,s=2;s<10;s++)this.h[s]+=n,n=this.h[s]>>>13,this.h[s]&=8191;for(this.h[0]+=5*n,n=this.h[0]>>>13,this.h[0]&=8191,this.h[1]+=n,n=this.h[1]>>>13,this.h[1]&=8191,this.h[2]+=n,i[0]=this.h[0]+5,n=i[0]>>>13,i[0]&=8191,s=1;s<10;s++)i[s]=this.h[s]+n,n=i[s]>>>13,i[s]&=8191;for(i[9]-=8192,r=(1^n)-1,s=0;s<10;s++)i[s]&=r;for(r=~r,s=0;s<10;s++)this.h[s]=this.h[s]&r|i[s];for(this.h[0]=65535&(this.h[0]|this.h[1]<<13),this.h[1]=65535&(this.h[1]>>>3|this.h[2]<<10),this.h[2]=65535&(this.h[2]>>>6|this.h[3]<<7),this.h[3]=65535&(this.h[3]>>>9|this.h[4]<<4),this.h[4]=65535&(this.h[4]>>>12|this.h[5]<<1|this.h[6]<<14),this.h[5]=65535&(this.h[6]>>>2|this.h[7]<<11),this.h[6]=65535&(this.h[7]>>>5|this.h[8]<<8),this.h[7]=65535&(this.h[8]>>>8|this.h[9]<<5),o=this.h[0]+this.pad[0],this.h[0]=65535&o,s=1;s<8;s++)o=(this.h[s]+this.pad[s]|0)+(o>>>16)|0,this.h[s]=65535&o;e[t+0]=this.h[0]>>>0&255,e[t+1]=this.h[0]>>>8&255,e[t+2]=this.h[1]>>>0&255,e[t+3]=this.h[1]>>>8&255,e[t+4]=this.h[2]>>>0&255,e[t+5]=this.h[2]>>>8&255,e[t+6]=this.h[3]>>>0&255,e[t+7]=this.h[3]>>>8&255,e[t+8]=this.h[4]>>>0&255,e[t+9]=this.h[4]>>>8&255,e[t+10]=this.h[5]>>>0&255,e[t+11]=this.h[5]>>>8&255,e[t+12]=this.h[6]>>>0&255,e[t+13]=this.h[6]>>>8&255,e[t+14]=this.h[7]>>>0&255,e[t+15]=this.h[7]>>>8&255},T.prototype.update=function(e,t,n){var r,o;if(this.leftover){for((o=16-this.leftover)>n&&(o=n),r=0;r<o;r++)this.buffer[this.leftover+r]=e[t+r];if(n-=o,t+=o,this.leftover+=o,this.leftover<16)return;this.blocks(this.buffer,0,16),this.leftover=0}if(n>=16&&(o=n-n%16,this.blocks(e,t,o),t+=o,n-=o),n){for(r=0;r<n;r++)this.buffer[this.leftover+r]=e[t+r];this.leftover+=n}};var Q=I,G=x,Y=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function X(e,t,n,r){for(var o,s,i,a,c,u,d,l,p,m,h,f,g,y,w,b,A,S,k,P,E,v,T,C,M,I,x=new Int32Array(16),_=new Int32Array(16),O=e[0],N=e[1],D=e[2],B=e[3],L=e[4],U=e[5],R=e[6],F=e[7],K=t[0],z=t[1],$=t[2],V=t[3],W=t[4],H=t[5],q=t[6],j=t[7],Q=0;r>=128;){for(k=0;k<16;k++)P=8*k+Q,x[k]=n[P+0]<<24|n[P+1]<<16|n[P+2]<<8|n[P+3],_[k]=n[P+4]<<24|n[P+5]<<16|n[P+6]<<8|n[P+7];for(k=0;k<80;k++)if(o=O,s=N,i=D,a=B,c=L,u=U,d=R,p=K,m=z,h=$,f=V,g=W,y=H,w=q,T=65535&(v=j),C=v>>>16,M=65535&(E=F),I=E>>>16,T+=65535&(v=(W>>>14|L<<18)^(W>>>18|L<<14)^(L>>>9|W<<23)),C+=v>>>16,M+=65535&(E=(L>>>14|W<<18)^(L>>>18|W<<14)^(W>>>9|L<<23)),I+=E>>>16,T+=65535&(v=W&H^~W&q),C+=v>>>16,M+=65535&(E=L&U^~L&R),I+=E>>>16,E=Y[2*k],T+=65535&(v=Y[2*k+1]),C+=v>>>16,M+=65535&E,I+=E>>>16,E=x[k%16],C+=(v=_[k%16])>>>16,M+=65535&E,I+=E>>>16,M+=(C+=(T+=65535&v)>>>16)>>>16,T=65535&(v=S=65535&T|C<<16),C=v>>>16,M=65535&(E=A=65535&M|(I+=M>>>16)<<16),I=E>>>16,T+=65535&(v=(K>>>28|O<<4)^(O>>>2|K<<30)^(O>>>7|K<<25)),C+=v>>>16,M+=65535&(E=(O>>>28|K<<4)^(K>>>2|O<<30)^(K>>>7|O<<25)),I+=E>>>16,C+=(v=K&z^K&$^z&$)>>>16,M+=65535&(E=O&N^O&D^N&D),I+=E>>>16,l=65535&(M+=(C+=(T+=65535&v)>>>16)>>>16)|(I+=M>>>16)<<16,b=65535&T|C<<16,T=65535&(v=f),C=v>>>16,M=65535&(E=a),I=E>>>16,C+=(v=S)>>>16,M+=65535&(E=A),I+=E>>>16,N=o,D=s,B=i,L=a=65535&(M+=(C+=(T+=65535&v)>>>16)>>>16)|(I+=M>>>16)<<16,U=c,R=u,F=d,O=l,z=p,$=m,V=h,W=f=65535&T|C<<16,H=g,q=y,j=w,K=b,k%16==15)for(P=0;P<16;P++)E=x[P],T=65535&(v=_[P]),C=v>>>16,M=65535&E,I=E>>>16,E=x[(P+9)%16],T+=65535&(v=_[(P+9)%16]),C+=v>>>16,M+=65535&E,I+=E>>>16,A=x[(P+1)%16],T+=65535&(v=((S=_[(P+1)%16])>>>1|A<<31)^(S>>>8|A<<24)^(S>>>7|A<<25)),C+=v>>>16,M+=65535&(E=(A>>>1|S<<31)^(A>>>8|S<<24)^A>>>7),I+=E>>>16,A=x[(P+14)%16],C+=(v=((S=_[(P+14)%16])>>>19|A<<13)^(A>>>29|S<<3)^(S>>>6|A<<26))>>>16,M+=65535&(E=(A>>>19|S<<13)^(S>>>29|A<<3)^A>>>6),I+=E>>>16,I+=(M+=(C+=(T+=65535&v)>>>16)>>>16)>>>16,x[P]=65535&M|I<<16,_[P]=65535&T|C<<16;T=65535&(v=K),C=v>>>16,M=65535&(E=O),I=E>>>16,E=e[0],C+=(v=t[0])>>>16,M+=65535&E,I+=E>>>16,I+=(M+=(C+=(T+=65535&v)>>>16)>>>16)>>>16,e[0]=O=65535&M|I<<16,t[0]=K=65535&T|C<<16,T=65535&(v=z),C=v>>>16,M=65535&(E=N),I=E>>>16,E=e[1],C+=(v=t[1])>>>16,M+=65535&E,I+=E>>>16,I+=(M+=(C+=(T+=65535&v)>>>16)>>>16)>>>16,e[1]=N=65535&M|I<<16,t[1]=z=65535&T|C<<16,T=65535&(v=$),C=v>>>16,M=65535&(E=D),I=E>>>16,E=e[2],C+=(v=t[2])>>>16,M+=65535&E,I+=E>>>16,I+=(M+=(C+=(T+=65535&v)>>>16)>>>16)>>>16,e[2]=D=65535&M|I<<16,t[2]=$=65535&T|C<<16,T=65535&(v=V),C=v>>>16,M=65535&(E=B),I=E>>>16,E=e[3],C+=(v=t[3])>>>16,M+=65535&E,I+=E>>>16,I+=(M+=(C+=(T+=65535&v)>>>16)>>>16)>>>16,e[3]=B=65535&M|I<<16,t[3]=V=65535&T|C<<16,T=65535&(v=W),C=v>>>16,M=65535&(E=L),I=E>>>16,E=e[4],C+=(v=t[4])>>>16,M+=65535&E,I+=E>>>16,I+=(M+=(C+=(T+=65535&v)>>>16)>>>16)>>>16,e[4]=L=65535&M|I<<16,t[4]=W=65535&T|C<<16,T=65535&(v=H),C=v>>>16,M=65535&(E=U),I=E>>>16,E=e[5],C+=(v=t[5])>>>16,M+=65535&E,I+=E>>>16,I+=(M+=(C+=(T+=65535&v)>>>16)>>>16)>>>16,e[5]=U=65535&M|I<<16,t[5]=H=65535&T|C<<16,T=65535&(v=q),C=v>>>16,M=65535&(E=R),I=E>>>16,E=e[6],C+=(v=t[6])>>>16,M+=65535&E,I+=E>>>16,I+=(M+=(C+=(T+=65535&v)>>>16)>>>16)>>>16,e[6]=R=65535&M|I<<16,t[6]=q=65535&T|C<<16,T=65535&(v=j),C=v>>>16,M=65535&(E=F),I=E>>>16,E=e[7],C+=(v=t[7])>>>16,M+=65535&E,I+=E>>>16,I+=(M+=(C+=(T+=65535&v)>>>16)>>>16)>>>16,e[7]=F=65535&M|I<<16,t[7]=j=65535&T|C<<16,Q+=128,r-=128}return r}function J(e,t,n){var r,o=new Int32Array(8),s=new Int32Array(8),i=new Uint8Array(256),a=n;for(o[0]=1779033703,o[1]=3144134277,o[2]=1013904242,o[3]=2773480762,o[4]=1359893119,o[5]=2600822924,o[6]=528734635,o[7]=1541459225,s[0]=4089235720,s[1]=2227873595,s[2]=4271175723,s[3]=1595750129,s[4]=2917565137,s[5]=725511199,s[6]=4215389547,s[7]=327033209,X(o,s,t,n),n%=128,r=0;r<n;r++)i[r]=t[a-n+r];for(i[n]=128,i[(n=256-128*(n<112?1:0))-9]=0,f(i,n-8,a/536870912|0,a<<3),X(o,s,i,n),r=0;r<8;r++)f(e,8*r,o[r],s[r]);return 0}function Z(e,n){var r=t(),o=t(),s=t(),i=t(),a=t(),c=t(),u=t(),l=t(),p=t();F(r,e[1],e[0]),F(p,n[1],n[0]),K(r,r,p),R(o,e[0],e[1]),R(p,n[0],n[1]),K(o,o,p),K(s,e[3],n[3]),K(s,s,d),K(i,e[2],n[2]),R(i,i,i),F(a,o,r),F(c,i,s),R(u,i,s),R(l,o,r),K(e[0],a,c),K(e[1],l,u),K(e[2],u,c),K(e[3],a,l)}function ee(e,t,n){var r;for(r=0;r<4;r++)N(e[r],t[r],n)}function te(e,n){var r=t(),o=t(),s=t();$(s,n[2]),K(r,n[0],s),K(o,n[1],s),D(e,o),e[31]^=L(r)<<7}function ne(e,t,n){var r,o;for(_(e[0],s),_(e[1],i),_(e[2],i),_(e[3],s),o=255;o>=0;--o)ee(e,t,r=n[o/8|0]>>(7&o)&1),Z(t,e),Z(e,e),ee(e,t,r)}function re(e,n){var r=[t(),t(),t(),t()];_(r[0],l),_(r[1],m),_(r[2],i),K(r[3],l,m),ne(e,r,n)}function oe(e,r,o){var s,i=new Uint8Array(64),a=[t(),t(),t(),t()];for(o||n(r,32),J(i,r,32),i[0]&=248,i[31]&=127,i[31]|=64,re(a,i),te(e,a),s=0;s<32;s++)r[s+32]=e[s];return 0}var se=new Float64Array([237,211,245,92,26,99,18,88,214,156,247,162,222,249,222,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16]);function ie(e,t){var n,r,o,s;for(r=63;r>=32;--r){for(n=0,o=r-32,s=r-12;o<s;++o)t[o]+=n-16*t[r]*se[o-(r-32)],n=Math.floor((t[o]+128)/256),t[o]-=256*n;t[o]+=n,t[r]=0}for(n=0,o=0;o<32;o++)t[o]+=n-(t[31]>>4)*se[o],n=t[o]>>8,t[o]&=255;for(o=0;o<32;o++)t[o]-=n*se[o];for(r=0;r<32;r++)t[r+1]+=t[r]>>8,e[r]=255&t[r]}function ae(e){var t,n=new Float64Array(64);for(t=0;t<64;t++)n[t]=e[t];for(t=0;t<64;t++)e[t]=0;ie(e,n)}function ce(e,n,r,o){var s,i,a=new Uint8Array(64),c=new Uint8Array(64),u=new Uint8Array(64),d=new Float64Array(64),l=[t(),t(),t(),t()];J(a,o,32),a[0]&=248,a[31]&=127,a[31]|=64;var p=r+64;for(s=0;s<r;s++)e[64+s]=n[s];for(s=0;s<32;s++)e[32+s]=a[32+s];for(J(u,e.subarray(32),r+32),ae(u),re(l,u),te(e,l),s=32;s<64;s++)e[s]=o[s];for(J(c,e,r+64),ae(c),s=0;s<64;s++)d[s]=0;for(s=0;s<32;s++)d[s]=u[s];for(s=0;s<32;s++)for(i=0;i<32;i++)d[s+i]+=c[s]*a[i];return ie(e.subarray(32),d),p}function ue(e,n,r,o){var a,c=new Uint8Array(32),d=new Uint8Array(64),l=[t(),t(),t(),t()],p=[t(),t(),t(),t()];if(r<64)return-1;if(function(e,n){var r=t(),o=t(),a=t(),c=t(),d=t(),l=t(),p=t();return _(e[2],i),U(e[1],n),z(a,e[1]),K(c,a,u),F(a,a,e[2]),R(c,e[2],c),z(d,c),z(l,d),K(p,l,d),K(r,p,a),K(r,r,c),V(r,r),K(r,r,a),K(r,r,c),K(r,r,c),K(e[0],r,c),z(o,e[0]),K(o,o,c),B(o,a)&&K(e[0],e[0],h),z(o,e[0]),K(o,o,c),B(o,a)?-1:(L(e[0])===n[31]>>7&&F(e[0],s,e[0]),K(e[3],e[0],e[1]),0)}(p,o))return-1;for(a=0;a<r;a++)e[a]=n[a];for(a=0;a<32;a++)e[a+32]=o[a];if(J(d,e,r),ae(d),ne(l,p,d),re(p,n.subarray(32)),Z(l,p),te(c,l),r-=64,w(n,0,c,0)){for(a=0;a<r;a++)e[a]=0;return-1}for(a=0;a<r;a++)e[a]=n[a+64];return r}var de,le=64,pe=32,me=64;function he(e,t){if(32!==e.length)throw new Error("bad key size");if(24!==t.length)throw new Error("bad nonce size")}function fe(){for(var e=0;e<arguments.length;e++)if(!(arguments[e]instanceof Uint8Array))throw new TypeError("unexpected type, use Uint8Array")}function ge(e){for(var t=0;t<e.length;t++)e[t]=0}e.lowlevel={crypto_core_hsalsa20:A,crypto_stream_xor:v,crypto_stream:E,crypto_stream_salsa20_xor:k,crypto_stream_salsa20:P,crypto_onetimeauth:C,crypto_onetimeauth_verify:M,crypto_verify_16:y,crypto_verify_32:w,crypto_secretbox:I,crypto_secretbox_open:x,crypto_scalarmult:W,crypto_scalarmult_base:H,crypto_box_beforenm:j,crypto_box_afternm:Q,crypto_box:function(e,t,n,r,o,s){var i=new Uint8Array(32);return j(i,o,s),Q(e,t,n,r,i)},crypto_box_open:function(e,t,n,r,o,s){var i=new Uint8Array(32);return j(i,o,s),G(e,t,n,r,i)},crypto_box_keypair:q,crypto_hash:J,crypto_sign:ce,crypto_sign_keypair:oe,crypto_sign_open:ue,crypto_secretbox_KEYBYTES:32,crypto_secretbox_NONCEBYTES:24,crypto_secretbox_ZEROBYTES:32,crypto_secretbox_BOXZEROBYTES:16,crypto_scalarmult_BYTES:32,crypto_scalarmult_SCALARBYTES:32,crypto_box_PUBLICKEYBYTES:32,crypto_box_SECRETKEYBYTES:32,crypto_box_BEFORENMBYTES:32,crypto_box_NONCEBYTES:24,crypto_box_ZEROBYTES:32,crypto_box_BOXZEROBYTES:16,crypto_sign_BYTES:le,crypto_sign_PUBLICKEYBYTES:pe,crypto_sign_SECRETKEYBYTES:me,crypto_sign_SEEDBYTES:32,crypto_hash_BYTES:64,gf:t,D:u,L:se,pack25519:D,unpack25519:U,M:K,A:R,S:z,Z:F,pow2523:V,add:Z,set25519:_,modL:ie,scalarmult:ne,scalarbase:re},e.randomBytes=function(e){var t=new Uint8Array(e);return n(t,e),t},e.secretbox=function(e,t,n){fe(e,t,n),he(n,t);for(var r=new Uint8Array(32+e.length),o=new Uint8Array(r.length),s=0;s<e.length;s++)r[s+32]=e[s];return I(o,r,r.length,t,n),o.subarray(16)},e.secretbox.open=function(e,t,n){fe(e,t,n),he(n,t);for(var r=new Uint8Array(16+e.length),o=new Uint8Array(r.length),s=0;s<e.length;s++)r[s+16]=e[s];return r.length<32||0!==x(o,r,r.length,t,n)?null:o.subarray(32)},e.secretbox.keyLength=32,e.secretbox.nonceLength=24,e.secretbox.overheadLength=16,e.scalarMult=function(e,t){if(fe(e,t),32!==e.length)throw new Error("bad n size");if(32!==t.length)throw new Error("bad p size");var n=new Uint8Array(32);return W(n,e,t),n},e.scalarMult.base=function(e){if(fe(e),32!==e.length)throw new Error("bad n size");var t=new Uint8Array(32);return H(t,e),t},e.scalarMult.scalarLength=32,e.scalarMult.groupElementLength=32,e.box=function(t,n,r,o){var s=e.box.before(r,o);return e.secretbox(t,n,s)},e.box.before=function(e,t){fe(e,t),function(e,t){if(32!==e.length)throw new Error("bad public key size");if(32!==t.length)throw new Error("bad secret key size")}(e,t);var n=new Uint8Array(32);return j(n,e,t),n},e.box.after=e.secretbox,e.box.open=function(t,n,r,o){var s=e.box.before(r,o);return e.secretbox.open(t,n,s)},e.box.open.after=e.secretbox.open,e.box.keyPair=function(){var e=new Uint8Array(32),t=new Uint8Array(32);return q(e,t),{publicKey:e,secretKey:t}},e.box.keyPair.fromSecretKey=function(e){if(fe(e),32!==e.length)throw new Error("bad secret key size");var t=new Uint8Array(32);return H(t,e),{publicKey:t,secretKey:new Uint8Array(e)}},e.box.publicKeyLength=32,e.box.secretKeyLength=32,e.box.sharedKeyLength=32,e.box.nonceLength=24,e.box.overheadLength=e.secretbox.overheadLength,e.sign=function(e,t){if(fe(e,t),t.length!==me)throw new Error("bad secret key size");var n=new Uint8Array(le+e.length);return ce(n,e,e.length,t),n},e.sign.open=function(e,t){if(fe(e,t),t.length!==pe)throw new Error("bad public key size");var n=new Uint8Array(e.length),r=ue(n,e,e.length,t);if(r<0)return null;for(var o=new Uint8Array(r),s=0;s<o.length;s++)o[s]=n[s];return o},e.sign.detached=function(t,n){for(var r=e.sign(t,n),o=new Uint8Array(le),s=0;s<o.length;s++)o[s]=r[s];return o},e.sign.detached.verify=function(e,t,n){if(fe(e,t,n),t.length!==le)throw new Error("bad signature size");if(n.length!==pe)throw new Error("bad public key size");var r,o=new Uint8Array(le+e.length),s=new Uint8Array(le+e.length);for(r=0;r<le;r++)o[r]=t[r];for(r=0;r<e.length;r++)o[r+le]=e[r];return ue(s,o,o.length,n)>=0},e.sign.keyPair=function(){var e=new Uint8Array(pe),t=new Uint8Array(me);return oe(e,t),{publicKey:e,secretKey:t}},e.sign.keyPair.fromSecretKey=function(e){if(fe(e),e.length!==me)throw new Error("bad secret key size");for(var t=new Uint8Array(pe),n=0;n<t.length;n++)t[n]=e[32+n];return{publicKey:t,secretKey:new Uint8Array(e)}},e.sign.keyPair.fromSeed=function(e){if(fe(e),32!==e.length)throw new Error("bad seed size");for(var t=new Uint8Array(pe),n=new Uint8Array(me),r=0;r<32;r++)n[r]=e[r];return oe(t,n,!0),{publicKey:t,secretKey:n}},e.sign.publicKeyLength=pe,e.sign.secretKeyLength=me,e.sign.seedLength=32,e.sign.signatureLength=le,e.hash=function(e){fe(e);var t=new Uint8Array(64);return J(t,e,e.length),t},e.hash.hashLength=64,e.verify=function(e,t){return fe(e,t),0!==e.length&&0!==t.length&&e.length===t.length&&0===g(e,0,t,0,e.length)},e.setPRNG=function(e){n=e},(de="undefined"!=typeof self?self.crypto||self.msCrypto:null)&&de.getRandomValues?e.setPRNG((function(e,t){var n,r=new Uint8Array(t);for(n=0;n<t;n+=65536)de.getRandomValues(r.subarray(n,n+Math.min(t-n,65536)));for(n=0;n<t;n++)e[n]=r[n];ge(r)})):void 0!==p&&(de=a)&&de.randomBytes&&e.setPRNG((function(e,t){var n,r=de.randomBytes(t);for(n=0;n<t;n++)e[n]=r[n];ge(r)}))}((m=h).exports?m.exports:self.nacl=self.nacl||{});var f=l(h.exports);const{sign:g}=f;class y{constructor(e,t,n){this.signTransaction=async e=>(await e.sign([this._keypair]),e),this.sendTransaction=async e=>await this._connection.sendTransaction(e),this.signAllTransactions=async e=>await Promise.all(e.map((async e=>await this.signTransaction(e)))),this.signMessage=async e=>g.detached(e,this._keypair.secretKey),this.sendAndConfirmTransaction=async(e,t=[])=>await o.sendAndConfirmTransaction(this._connection,e,[this._keypair,...t],{commitment:this._commitment}),this._publicKey=e.publicKey,this._keypair=e,this._connection=new o.Connection(t),this._url=t,this._commitment=n}}const w=(e,t="http://127.0.0.1:8899",n="confirmed")=>{const r=new y(e,t="mock"!==t?t:"http://127.0.0.1:8899",n);return{publicKey:r._publicKey,sendAndConfirmTransaction:r.sendAndConfirmTransaction,signMessage:r.signMessage,signTransaction:r.signTransaction,signAllTransactions:r.signAllTransactions,sendTransaction:r.sendTransaction}},b=new s.BN("21888242871839275222246405745257275088548364400416034343698204186575808495617"),A=new s.BN("452312848583266388373324160190187140051835877600158453279131187530910662655"),S="noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV",k="SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7",P="compr6CUsB5m2jS4Y3831ztGSTnDpnKJTKS95d64XVq",E=()=>new o.PublicKey("35hkDgaAKwMCaxRz2ocSZ6NaUrtKkyNqU6c4RV3tYJRh"),v=()=>o.PublicKey.findProgramAddressSync([i.Buffer.from("cpi_authority")],new o.PublicKey(k))[0],T=()=>({registeredProgramPda:new o.PublicKey(E()),noopProgram:new o.PublicKey(S),accountCompressionProgram:new o.PublicKey(P),accountCompressionAuthority:new o.PublicKey(v()),cpiSignatureAccount:null}),C=()=>({nullifierQueue:new o.PublicKey(M),merkleTree:new o.PublicKey(I),merkleTreeHeight:O,addressTree:new o.PublicKey(x),addressQueue:new o.PublicKey(_)}),M="nfq1NvQDJ2GEgnS8zt9prAe8rjjpAW1zFkrvZoBR148",I="smt1NamzXdq4AMqS2fS2F1i5KTYPZRhoHgWx38d8WsT",x="amt1Ayt45jfbdw5YSo7iz6WZxUmnZsQTYXy82hVwyC2",_="aq1S9z4reTSQAdgWHGD2zDaS39sjGrAxbR31vxJ2F4F",O=26,N=new s.BN(Math.floor(2**O*.95)),D=new s.BN(300),B=new s.BN(392),L=new s.BN(5e3),U=new s.BN(5e3);var R;({__DEV__:!1,IS_STATIC:"",NODE_ENV:"production",TAMAGUI_TARGET:"web",DEBUG:"0",BACKPACK_ENV:"production",BACKPACK_CONFIG_LOG_LEVEL:"none",BACKPACK_CONFIG_VERSION:"0.10.190-2"}).ANCHOR_BROWSER||"undefined"!=typeof window&&(null===(R=window.process)||void 0===R||R.hasOwnProperty("type"));var F={exports:{}};!function(e,t){var n=i,r=n.Buffer;function o(e,t){for(var n in e)t[n]=e[n]}function s(e,t,n){return r(e,t,n)}r.from&&r.alloc&&r.allocUnsafe&&r.allocUnsafeSlow?e.exports=n:(o(n,t),t.Buffer=s),s.prototype=Object.create(r.prototype),o(r,s),s.from=function(e,t,n){if("number"==typeof e)throw new TypeError("Argument must not be a number");return r(e,t,n)},s.alloc=function(e,t,n){if("number"!=typeof e)throw new TypeError("Argument must be a number");var o=r(e);return void 0!==t?"string"==typeof n?o.fill(t,n):o.fill(t):o.fill(0),o},s.allocUnsafe=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return r(e)},s.allocUnsafeSlow=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return n.SlowBuffer(e)}}(F,F.exports);var K=F.exports.Buffer,z=function(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var r=0;r<e.length;r++){var o=e.charAt(r),s=o.charCodeAt(0);if(255!==t[s])throw new TypeError(o+" is ambiguous");t[s]=r}var i=e.length,a=e.charAt(0),c=Math.log(i)/Math.log(256),u=Math.log(256)/Math.log(i);function d(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return K.alloc(0);for(var n=0,r=0,o=0;e[n]===a;)r++,n++;for(var s=(e.length-n)*c+1>>>0,u=new Uint8Array(s);e[n];){var d=t[e.charCodeAt(n)];if(255===d)return;for(var l=0,p=s-1;(0!==d||l<o)&&-1!==p;p--,l++)d+=i*u[p]>>>0,u[p]=d%256>>>0,d=d/256>>>0;if(0!==d)throw new Error("Non-zero carry");o=l,n++}for(var m=s-o;m!==s&&0===u[m];)m++;var h=K.allocUnsafe(r+(s-m));h.fill(0,0,r);for(var f=r;m!==s;)h[f++]=u[m++];return h}return{encode:function(t){if((Array.isArray(t)||t instanceof Uint8Array)&&(t=K.from(t)),!K.isBuffer(t))throw new TypeError("Expected Buffer");if(0===t.length)return"";for(var n=0,r=0,o=0,s=t.length;o!==s&&0===t[o];)o++,n++;for(var c=(s-o)*u+1>>>0,d=new Uint8Array(c);o!==s;){for(var l=t[o],p=0,m=c-1;(0!==l||p<r)&&-1!==m;m--,p++)l+=256*d[m]>>>0,d[m]=l%i>>>0,l=l/i>>>0;if(0!==l)throw new Error("Non-zero carry");r=p,o++}for(var h=c-r;h!==c&&0===d[h];)h++;for(var f=a.repeat(n);h<c;++h)f+=e.charAt(d[h]);return f},decodeUnsafe:d,decode:function(e){var t=d(e);if(t)return t;throw new Error("Non-base"+i+" character")}}}("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),$=l(z);const V=(e,t,n)=>new s.BN(e,t,n),W=(e,t)=>{if("base58"===t){if("string"!=typeof e)throw new Error("Must be a base58 string");return W((n=e,$.decode(n)))}var n;return function(e){if(e.gte(b))throw new Error("Value is too large. Max <254 bits");return e}(new s.BN(e,t))};function H(e){return t=W(e).toArrayLike(i.Buffer,void 0,32),$.encode(t);var t}const q=(e,t,n,r)=>({owner:e,lamports:null!=t?t:V(0),address:null!=r?r:null,data:null!=n?n:null}),j=(e,t,n,r,o)=>Object.assign(Object.assign(Object.assign({},q(t,n,r,o)),e),{readOnly:!1}),Q=(e,t,n,r)=>({merkleTree:e,nullifierQueue:t,hash:n,leafIndex:r});function G(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function Y(e,...t){if(!function(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function X(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}const J=BigInt(2**32-1),Z=BigInt(32);function ee(e,t=!1){return t?{h:Number(e&J),l:Number(e>>Z&J)}:{h:0|Number(e>>Z&J),l:0|Number(e&J)}}function te(e,t=!1){let n=new Uint32Array(e.length),r=new Uint32Array(e.length);for(let o=0;o<e.length;o++){const{h:s,l:i}=ee(e[o],t);[n[o],r[o]]=[s,i]}return[n,r]}const ne=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0];function re(e){for(let n=0;n<e.length;n++)e[n]=(t=e[n])<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255;var t}function oe(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),Y(e),e}class se{clone(){return this._cloneInto()}}const ie=[],ae=[],ce=[],ue=BigInt(0),de=BigInt(1),le=BigInt(2),pe=BigInt(7),me=BigInt(256),he=BigInt(113);for(let e=0,t=de,n=1,r=0;e<24;e++){[n,r]=[r,(2*n+3*r)%5],ie.push(2*(5*r+n)),ae.push((e+1)*(e+2)/2%64);let o=ue;for(let e=0;e<7;e++)t=(t<<de^(t>>pe)*he)%me,t&le&&(o^=de<<(de<<BigInt(e))-de);ce.push(o)}const[fe,ge]=te(ce,!0),ye=(e,t,n)=>n>32?((e,t,n)=>t<<n-32|e>>>64-n)(e,t,n):((e,t,n)=>e<<n|t>>>32-n)(e,t,n),we=(e,t,n)=>n>32?((e,t,n)=>e<<n-32|t>>>64-n)(e,t,n):((e,t,n)=>t<<n|e>>>32-n)(e,t,n);class be extends se{constructor(e,t,n,r=!1,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=n,this.enableXOF=r,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,G(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var s;this.state=new Uint8Array(200),this.state32=(s=this.state,new Uint32Array(s.buffer,s.byteOffset,Math.floor(s.byteLength/4)))}keccak(){ne||re(this.state32),function(e,t=24){const n=new Uint32Array(10);for(let r=24-t;r<24;r++){for(let t=0;t<10;t++)n[t]=e[t]^e[t+10]^e[t+20]^e[t+30]^e[t+40];for(let t=0;t<10;t+=2){const r=(t+8)%10,o=(t+2)%10,s=n[o],i=n[o+1],a=ye(s,i,1)^n[r],c=we(s,i,1)^n[r+1];for(let n=0;n<50;n+=10)e[t+n]^=a,e[t+n+1]^=c}let t=e[2],o=e[3];for(let n=0;n<24;n++){const r=ae[n],s=ye(t,o,r),i=we(t,o,r),a=ie[n];t=e[a],o=e[a+1],e[a]=s,e[a+1]=i}for(let t=0;t<50;t+=10){for(let r=0;r<10;r++)n[r]=e[t+r];for(let r=0;r<10;r++)e[t+r]^=~n[(r+2)%10]&n[(r+4)%10]}e[0]^=fe[r],e[1]^=ge[r]}n.fill(0)}(this.state32,this.rounds),ne||re(this.state32),this.posOut=0,this.pos=0}update(e){X(this);const{blockLen:t,state:n}=this,r=(e=oe(e)).length;for(let o=0;o<r;){const s=Math.min(t-this.pos,r-o);for(let t=0;t<s;t++)n[this.pos++]^=e[o++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:n,blockLen:r}=this;e[n]^=t,0!=(128&t)&&n===r-1&&this.keccak(),e[r-1]^=128,this.keccak()}writeInto(e){X(this,!1),Y(e),this.finish();const t=this.state,{blockLen:n}=this;for(let r=0,o=e.length;r<o;){this.posOut>=n&&this.keccak();const s=Math.min(n-this.posOut,o-r);e.set(t.subarray(this.posOut,this.posOut+s),r),this.posOut+=s,r+=s}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return G(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(function(e,t){Y(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:n,outputLen:r,rounds:o,enableXOF:s}=this;return e||(e=new be(t,n,r,s,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=n,e.outputLen=r,e.enableXOF=s,e.destroyed=this.destroyed,e}}const Ae=((e,t,n)=>function(e){const t=t=>e().update(oe(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}((()=>new be(136,1,32))))();function Se(e){return"0x"+e.toString("hex")}const ke=e=>Array.isArray(e)?e:[e];function Pe(e){return V(e,void 0,"be").lt(b)}function Ee(e){let t=255;for(;t>=0;){const n=i.Buffer.concat([e,i.Buffer.from([t])]),r=Ae(n);if(32!==r.length)throw new Error("Invalid hash length");if(r[0]=0,Pe(i.Buffer.from(r)))return[i.Buffer.from(r),t];t-=1}return null}function ve(e){const t=Ae.create();for(const n of e)t.update(n);const n=t.digest();return n[0]=0,n}function Te(e){return Array.isArray(e)?e.map((e=>Te(e))):null!==e&&e.constructor===Object?Object.keys(e).reduce(((t,n)=>(t[n.replace(/([-_][a-z])/gi,(e=>e.toUpperCase().replace("-","").replace("_","")))]=Te(e[n]),t)),{}):e}function Ce(e,t){const n=e.findIndex((e=>e.equals(t)));return-1===n?(e.push(t),e.length-1):n}function Me(e,t,n){if(t<=0)return[];if(void 0===e)return 0===n.length?new Array(t).fill(C().merkleTree):new Array(t).fill(n[0].merkleTree);{const n=ke(e);return n.length>=t?n.slice(0,t):n.concat(new Array(t-n.length).fill(n[0]))}}function Ie(e){return e.map((e=>({pubkey:e,isWritable:!0,isSigner:!1})))}function xe(e,t,n,r,o=[]){const s=o.slice(),i=[],a=[];e.forEach(((e,n)=>{const r=Ce(s,e.merkleTree),o=Ce(s,e.nullifierQueue);i.push({compressedAccount:{owner:e.owner,lamports:e.lamports,address:e.address,data:e.data},merkleContext:{merkleTreePubkeyIndex:r,nullifierQueuePubkeyIndex:o,leafIndex:e.leafIndex,queueIndex:null},rootIndex:t[n],readOnly:!1})}));const c=Me(r,n.length,e);return n.forEach(((e,t)=>{const n=Ce(s,c[t]);a.push({compressedAccount:{owner:e.owner,lamports:e.lamports,address:e.address,data:e.data},merkleTreeIndex:n})})),{packedInputCompressedAccounts:i,packedOutputCompressedAccounts:a,remainingAccounts:s}}const _e=e=>{if(e.lt(V(0)))throw new Error("Not enough balance for transfer")},Oe=e=>{if(0===e.length)throw new Error("No accounts provided for validation");const t=e[0].owner;if(!e.every((e=>e.owner.equals(t))))throw new Error("All input accounts must have the same owner")};function Ne(e,t){return ve([t.toBytes(),...e])}function De(e,t=C().addressTree){if(32!=e.length)throw new Error("Seed length is not 32 bytes.");const n=t.toBytes(),s=Ee(r.from([...n,...e]));if(null===s)throw new Error("DeriveAddressError");const i=s[0];return new o.PublicKey(i)}function Be(e,t){const n=t.slice(),r=e.map((e=>({seed:Array.from(e.seed),addressMerkleTreeRootIndex:e.addressMerkleTreeRootIndex,addressMerkleTreeAccountIndex:0,addressQueueAccountIndex:0})));return e.forEach(((e,t)=>{r[t].addressMerkleTreeAccountIndex=Ce(n,e.addressMerkleTreePubkey)})),e.forEach(((e,t)=>{r[t].addressQueueAccountIndex=Ce(n,e.addressQueuePubkey)})),{newAddressParamsPacked:r,remainingAccounts:n}}async function Le(e,t,n="confirmed"){const r=await e.getLatestBlockhash(n),o={signature:t.toString(),lastValidBlockHeight:r.lastValidBlockHeight,blockhash:r.blockhash};return await e.confirmTransaction(o,n)}function Ue(e){const t=Fe(e.ar[0]),n=Fe(e.ar[1]),r=new Uint8Array([...t,...n]),o=Fe(e.bs[0][0]),s=Fe(e.bs[0][1]),i=Fe(e.bs[1][0]),a=Fe(e.bs[1][1]),c=new Uint8Array([...o,...s,...i,...a]),u=Fe(e.krs[0]),d=Fe(e.krs[1]);return{a:r,b:c,c:new Uint8Array([...u,...d])}}function Re(e){const t=e.a,n=e.b,r=e.c,o=t.slice(0,32),i=!Ke(new s.BN(t.slice(32,64),32,"be"));o[0]=ze(o[0],i);const a=n.slice(0,64),c=n.slice(64,128),u=function(e,t){const n=b.div(new s.BN(2));return!!e.lt(n)||!e.gt(n)&&t.lt(n)}(new s.BN(c.slice(0,32),32,"be"),new s.BN(c.slice(32,64),32,"be"));a[0]=ze(a[0],u);const d=r.slice(0,32),l=r.slice(32,64),p=Ke(new s.BN(l,32,"be"));return d[0]=ze(d[0],p),{a:Array.from(o),b:Array.from(a),c:Array.from(d)}}function Fe(e){const t=new s.BN(e.startsWith("0x")?e.substring(2):e,"hex");return new Uint8Array(t.toArray("be",32))}function Ke(e){return e.lte(b.sub(e))}function ze(e,t){return t?e:128|e}function $e(e,t,n,r){const s=new o.TransactionMessage({payerKey:t,recentBlockhash:n,instructions:e}).compileToV0Message(r);return new o.VersionedTransaction(s)}async function Ve(e,t,n,r){const o=await e.sendTransaction(t,n);r||(r=await e.getLatestBlockhash());const s={signature:o,blockhash:r.blockhash,lastValidBlockHeight:r.lastValidBlockHeight},i=(await e.confirmTransaction(s,(null==n?void 0:n.commitment)||e.commitment||"confirmed")).context.slot;return await e.confirmTransactionIndexed(i),o}async function We(e,t,n,r){r||(r=await e.getLatestBlockhash());const o={signature:t,blockhash:r.blockhash,lastValidBlockHeight:r.lastValidBlockHeight},s=await e.confirmTransaction(o,(null==n?void 0:n.commitment)||e.commitment||"confirmed"),i=s.context.slot;return await e.confirmTransactionIndexed(i),s}function He(e,t,n,r=[],o){if(r.includes(t))throw new Error("payer must not be in additionalSigners");const s=[t,...r],i=$e(e,t.publicKey,n,o);return i.sign(s),i}let qe=1;const je=Xe(255),Qe=Xe(254),Ge=Xe(253),Ye=Xe(252);function Xe(e=void 0){if(e||(e=qe,qe++),e>255)return o.Keypair.generate();const t=new Uint8Array(32);return t[31]=e,o.Keypair.fromSeed(t)}const Je=e=>e.reduce(((e,t)=>e.add(V(t.lamports))),V(0)),Ze=i.Buffer.from("sol_pool_pda");class et{constructor(){}static get program(){return this._program||this.initializeProgram(),this._program}static deriveCompressedSolPda(){const e=[Ze],[t,n]=o.PublicKey.findProgramAddressSync(e,this.programId);return t}static initializeProgram(){if(!this._program){const e=o.Keypair.generate(),t=new o.Connection("http://127.0.0.1:8899","confirmed"),n=new s.AnchorProvider(t,w(e),{commitment:"confirmed",preflightCommitment:"confirmed"});s.setProvider(n),this._program=new s.Program(u,this.programId,n)}}static createTransferOutputState(e,t,n){n=V(n);const r=Je(e).sub(n);return _e(r),r.eq(V(0))?[q(t,n)]:(Oe(e),[q(e[0].owner,r),q(t,n)])}static createDecompressOutputState(e,t){t=V(t);const n=Je(e).sub(t);return _e(n),n.eq(V(0))?[]:(Oe(e),[q(e[0].owner,n)])}static createNewAddressOutputState(e,t,n,r){n=V(null!=n?n:0);const o=Je(null!=r?r:[]).sub(n);return _e(o),o.eq(V(0))||!r?[q(t,n,void 0,e)]:(Oe(r),[q(r[0].owner,o),q(t,n,void 0,e)])}static async createAccount({payer:e,newAddressParams:t,newAddress:n,recentValidityProof:r,outputStateTree:s,inputCompressedAccounts:i,inputStateRootIndices:a,lamports:c}){const u=this.createNewAddressOutputState(n,e,c,i),{packedInputCompressedAccounts:d,packedOutputCompressedAccounts:l,remainingAccounts:p}=xe(null!=i?i:[],null!=a?a:[],u,s),{newAddressParamsPacked:m,remainingAccounts:h}=Be([t],p),f={proof:r,inputCompressedAccountsWithMerkleContext:d,outputCompressedAccounts:l,relayFee:null,newAddressParams:m,compressOrDecompressLamports:null,isCompress:!1},g=this.program.coder.types.encode("InstructionDataInvoke",f);return await this.program.methods.invoke(g).accounts(Object.assign(Object.assign({},T()),{feePayer:e,authority:e,solPoolPda:null,decompressionRecipient:null,systemProgram:o.SystemProgram.programId})).remainingAccounts(Ie(h)).instruction()}static async transfer({payer:e,inputCompressedAccounts:t,toAddress:n,lamports:r,recentInputStateRootIndices:s,recentValidityProof:i,outputStateTrees:a}){const c=this.createTransferOutputState(t,n,r),{packedInputCompressedAccounts:u,packedOutputCompressedAccounts:d,remainingAccounts:l}=xe(t,s,c,a),p=this.program.coder.types.encode("InstructionDataInvoke",{proof:i,inputCompressedAccountsWithMerkleContext:u,outputCompressedAccounts:d,relayFee:null,newAddressParams:[],compressOrDecompressLamports:null,isCompress:!1});return await this.program.methods.invoke(p).accounts(Object.assign(Object.assign({},T()),{feePayer:e,authority:e,solPoolPda:null,decompressionRecipient:null,systemProgram:o.SystemProgram.programId})).remainingAccounts(Ie(l)).instruction()}static async compress({payer:e,toAddress:t,lamports:n,outputStateTree:r}){n=V(n);const s=q(t,n),{packedInputCompressedAccounts:i,packedOutputCompressedAccounts:a,remainingAccounts:c}=xe([],[],[s],r),u={proof:null,inputCompressedAccountsWithMerkleContext:i,outputCompressedAccounts:a,relayFee:null,newAddressParams:[],compressOrDecompressLamports:n,isCompress:!0},d=this.program.coder.types.encode("InstructionDataInvoke",u);return await this.program.methods.invoke(d).accounts(Object.assign(Object.assign({},T()),{feePayer:e,authority:e,solPoolPda:this.deriveCompressedSolPda(),decompressionRecipient:null,systemProgram:o.SystemProgram.programId})).remainingAccounts(Ie(c)).instruction()}static async decompress({payer:e,inputCompressedAccounts:t,toAddress:n,lamports:r,recentInputStateRootIndices:s,recentValidityProof:i,outputStateTree:a}){r=V(r);const c=this.createDecompressOutputState(t,r),{packedInputCompressedAccounts:u,packedOutputCompressedAccounts:d,remainingAccounts:l}=xe(t,s,c,a),p=this.program.coder.types.encode("InstructionDataInvoke",{proof:i,inputCompressedAccountsWithMerkleContext:u,outputCompressedAccounts:d,relayFee:null,newAddressParams:[],compressOrDecompressLamports:r,isCompress:!1});return await this.program.methods.invoke(p).accounts(Object.assign(Object.assign({},T()),{feePayer:e,authority:e,solPoolPda:this.deriveCompressedSolPda(),decompressionRecipient:n,systemProgram:o.SystemProgram.programId})).remainingAccounts(Ie(l)).instruction()}}function tt(e,t){let n=V(0);t=V(t);const r=[];e.sort(((e,t)=>t.lamports.cmp(e.lamports)));for(const o of e){if(n.gte(V(t)))break;n=n.add(o.lamports),r.push(o)}if(n.lt(V(t)))throw new Error(`Not enough balance for transfer. Required: ${t.toString()}, available: ${n.toString()}`);return[r,n]}et.programId=new o.PublicKey("SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7"),et._program=null;const nt={version:"1.2.0",name:"light_compressed_token",instructions:[{name:"createTokenPool",docs:["This instruction creates a token pool for a given mint. Every spl mint","can have one token pool. When a token is compressed the tokens are","transferrred to the token pool, and their compressed equivalent is","minted into a Merkle tree."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"tokenPoolPda",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"mint",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1}],args:[]},{name:"mintTo",docs:["Mints tokens from an spl token mint to a list of compressed accounts.","Minted tokens are transferred to a pool account owned by the compressed","token program. The instruction creates one compressed output account for","every amount and pubkey input pair. A constant amount of lamports can be","transferred to each output account to enable. A use case to add lamports","to a compressed token account is to prevent spam. This is the only way","to add lamports to a compressed token account."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"mint",isMut:!0,isSigner:!1},{name:"tokenPoolPda",isMut:!0,isSigner:!1,docs:["account to a token account of a different mint will fail"]},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1,docs:["programs"]},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"merkleTree",isMut:!0,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"solPoolPda",isMut:!0,isSigner:!1,isOptional:!0}],args:[{name:"publicKeys",type:{vec:"publicKey"}},{name:"amounts",type:{vec:"u64"}},{name:"lamports",type:{option:"u64"}}]},{name:"transfer",docs:["Transfers compressed tokens from one account to another. All accounts","must be of the same mint. Additional spl tokens can be compressed or","decompressed. In one transaction only compression or decompression is","possible. Lamports can be transferred alongside tokens. If output token","accounts specify less lamports than inputs the remaining lamports are","transferred to an output compressed account. Signer must be owner or","delegate. If a delegated token account is transferred the delegate is","not preserved."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1,docs:["this program is the signer of the cpi."]},{name:"tokenPoolPda",isMut:!0,isSigner:!1,isOptional:!0},{name:"compressOrDecompressTokenAccount",isMut:!0,isSigner:!1,isOptional:!0},{name:"tokenProgram",isMut:!1,isSigner:!1,isOptional:!0},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"inputs",type:"bytes"}]},{name:"approve",docs:["Delegates an amount to a delegate. A compressed token account is either","completely delegated or not. Prior delegates are not preserved. Cannot","be called by a delegate.","The instruction creates two output accounts:","1. one account with delegated amount","2. one account with remaining(change) amount"],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1,docs:["this program is the signer of the cpi."]},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"inputs",type:"bytes"}]},{name:"revoke",docs:["Revokes a delegation. The instruction merges all inputs into one output","account. Cannot be called by a delegate. Delegates are not preserved."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1,docs:["this program is the signer of the cpi."]},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"inputs",type:"bytes"}]},{name:"freeze",docs:["Freezes compressed token accounts. Inputs must not be frozen. Creates as","many outputs as inputs. Balances and delegates are preserved."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1,docs:["that this program is the signer of the cpi."]},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1}],args:[{name:"inputs",type:"bytes"}]},{name:"thaw",docs:["Thaws frozen compressed token accounts. Inputs must be frozen. Creates","as many outputs as inputs. Balances and delegates are preserved."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1,docs:["that this program is the signer of the cpi."]},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1}],args:[{name:"inputs",type:"bytes"}]},{name:"burn",docs:["Burns compressed tokens and spl tokens from the pool account. Delegates","can burn tokens. The output compressed token account remains delegated.","Creates one output compressed token account."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"mint",isMut:!0,isSigner:!1},{name:"tokenPoolPda",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"inputs",type:"bytes"}]},{name:"stubIdlBuild",docs:["This function is a stub to allow Anchor to include the input types in","the IDL. It should not be included in production builds nor be called in","practice."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["UNCHECKED: only pays fees."]},{name:"authority",isMut:!1,isSigner:!0,docs:["Authority is verified through proof since both owner and delegate","are included in the token data hash, which is a public input to the","validity proof."]},{name:"cpiAuthorityPda",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"noopProgram",isMut:!1,isSigner:!1},{name:"accountCompressionAuthority",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1,docs:["this program is the signer of the cpi."]},{name:"tokenPoolPda",isMut:!0,isSigner:!1,isOptional:!0},{name:"compressOrDecompressTokenAccount",isMut:!0,isSigner:!1,isOptional:!0},{name:"tokenProgram",isMut:!1,isSigner:!1,isOptional:!0},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"inputs1",type:{defined:"CompressedTokenInstructionDataTransfer"}},{name:"inputs2",type:{defined:"TokenData"}}]}],types:[{name:"AccessMetadata",type:{kind:"struct",fields:[{name:"owner",docs:["Owner of the Merkle tree."],type:"publicKey"},{name:"programOwner",docs:["Program owner of the Merkle tree. This will be used for program owned Merkle trees."],type:"publicKey"},{name:"forester",docs:["Optional privileged forester pubkey, can be set for custom Merkle trees","without a network fee. Merkle trees without network fees are not","forested by light foresters. The variable is not used in the account","compression program but the registry program. The registry program","implements access control to prevent contention during forester. The","forester pubkey specified in this struct can bypass contention checks."],type:"publicKey"}]}},{name:"AccountState",type:{kind:"enum",variants:[{name:"Initialized"},{name:"Frozen"}]}},{name:"CompressedAccount",type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"lamports",type:"u64"},{name:"address",type:{option:{array:["u8",32]}}},{name:"data",type:{option:{defined:"CompressedAccountData"}}}]}},{name:"CompressedAccountData",type:{kind:"struct",fields:[{name:"discriminator",type:{array:["u8",8]}},{name:"data",type:"bytes"},{name:"dataHash",type:{array:["u8",32]}}]}},{name:"CompressedCpiContext",type:{kind:"struct",fields:[{name:"setContext",docs:["Is set by the program that is invoking the CPI to signal that is should","set the cpi context."],type:"bool"},{name:"firstSetContext",docs:["Is set to wipe the cpi context since someone could have set it before","with unrelated data."],type:"bool"},{name:"cpiContextAccountIndex",docs:["Index of cpi context account in remaining accounts."],type:"u8"}]}},{name:"CompressedProof",type:{kind:"struct",fields:[{name:"a",type:{array:["u8",32]}},{name:"b",type:{array:["u8",64]}},{name:"c",type:{array:["u8",32]}}]}},{name:"CompressedTokenInstructionDataTransfer",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"mint",type:"publicKey"},{name:"delegatedTransfer",docs:["Is required if the signer is delegate,","-> delegate is authority account,","owner = Some(owner) is the owner of the token account."],type:{option:{defined:"DelegatedTransfer"}}},{name:"inputTokenDataWithContext",type:{vec:{defined:"InputTokenDataWithContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"PackedTokenTransferOutputData"}}},{name:"isCompress",type:"bool"},{name:"compressOrDecompressAmount",type:{option:"u64"}},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}},{name:"lamportsChangeAccountMerkleTreeIndex",type:{option:"u8"}}]}},{name:"DelegatedTransfer",docs:["Struct to provide the owner when the delegate is signer of the transaction."],type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"delegateChangeAccountIndex",docs:["Index of change compressed account in output compressed accounts. In","case that the delegate didn't spend the complete delegated compressed","account balance the change compressed account will be delegated to her","as well."],type:{option:"u8"}}]}},{name:"InputTokenDataWithContext",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"delegateIndex",type:{option:"u8"}},{name:"merkleContext",type:{defined:"PackedMerkleContext"}},{name:"rootIndex",type:"u16"},{name:"lamports",type:{option:"u64"}},{name:"tlv",docs:["Placeholder for TokenExtension tlv data (unimplemented)"],type:{option:"bytes"}}]}},{name:"InstructionDataInvoke",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"inputCompressedAccountsWithMerkleContext",type:{vec:{defined:"PackedCompressedAccountWithMerkleContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"relayFee",type:{option:"u64"}},{name:"newAddressParams",type:{vec:{defined:"NewAddressParamsPacked"}}},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"isCompress",type:"bool"}]}},{name:"InstructionDataInvokeCpi",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"newAddressParams",type:{vec:{defined:"NewAddressParamsPacked"}}},{name:"inputCompressedAccountsWithMerkleContext",type:{vec:{defined:"PackedCompressedAccountWithMerkleContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"relayFee",type:{option:"u64"}},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"isCompress",type:"bool"},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}}]}},{name:"MerkleTreeMetadata",type:{kind:"struct",fields:[{name:"accessMetadata",type:{defined:"AccessMetadata"}},{name:"rolloverMetadata",type:{defined:"RolloverMetadata"}},{name:"associatedQueue",type:"publicKey"},{name:"nextMerkleTree",type:"publicKey"}]}},{name:"MerkleTreeSequenceNumber",type:{kind:"struct",fields:[{name:"pubkey",type:"publicKey"},{name:"seq",type:"u64"}]}},{name:"NewAddressParamsPacked",type:{kind:"struct",fields:[{name:"seed",type:{array:["u8",32]}},{name:"addressQueueAccountIndex",type:"u8"},{name:"addressMerkleTreeAccountIndex",type:"u8"},{name:"addressMerkleTreeRootIndex",type:"u16"}]}},{name:"OutputCompressedAccountWithPackedContext",type:{kind:"struct",fields:[{name:"compressedAccount",type:{defined:"CompressedAccount"}},{name:"merkleTreeIndex",type:"u8"}]}},{name:"PackedCompressedAccountWithMerkleContext",type:{kind:"struct",fields:[{name:"compressedAccount",type:{defined:"CompressedAccount"}},{name:"merkleContext",type:{defined:"PackedMerkleContext"}},{name:"rootIndex",docs:["Index of root used in inclusion validity proof."],type:"u16"},{name:"readOnly",docs:["Placeholder to mark accounts read-only unimplemented set to false."],type:"bool"}]}},{name:"PackedMerkleContext",type:{kind:"struct",fields:[{name:"merkleTreePubkeyIndex",type:"u8"},{name:"nullifierQueuePubkeyIndex",type:"u8"},{name:"leafIndex",type:"u32"},{name:"queueIndex",docs:["Index of leaf in queue. Placeholder of batched Merkle tree updates","currently unimplemented."],type:{option:{defined:"QueueIndex"}}}]}},{name:"PackedTokenTransferOutputData",type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"amount",type:"u64"},{name:"lamports",type:{option:"u64"}},{name:"merkleTreeIndex",type:"u8"},{name:"tlv",docs:["Placeholder for TokenExtension tlv data (unimplemented)"],type:{option:"bytes"}}]}},{name:"PublicTransactionEvent",type:{kind:"struct",fields:[{name:"inputCompressedAccountHashes",type:{vec:{array:["u8",32]}}},{name:"outputCompressedAccountHashes",type:{vec:{array:["u8",32]}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"outputLeafIndices",type:{vec:"u32"}},{name:"sequenceNumbers",type:{vec:{defined:"MerkleTreeSequenceNumber"}}},{name:"relayFee",type:{option:"u64"}},{name:"isCompress",type:"bool"},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"pubkeyArray",type:{vec:"publicKey"}},{name:"message",type:{option:"bytes"}}]}},{name:"QueueIndex",type:{kind:"struct",fields:[{name:"queueId",docs:["Id of queue in queue account."],type:"u8"},{name:"index",docs:["Index of compressed account hash in queue."],type:"u16"}]}},{name:"RolloverMetadata",type:{kind:"struct",fields:[{name:"index",docs:["Unique index."],type:"u64"},{name:"rolloverFee",docs:["This fee is used for rent for the next account.","It accumulates in the account so that once the corresponding Merkle tree account is full it can be rolled over"],type:"u64"},{name:"rolloverThreshold",docs:["The threshold in percentage points when the account should be rolled over (95 corresponds to 95% filled)."],type:"u64"},{name:"networkFee",docs:["Tip for maintaining the account."],type:"u64"},{name:"rolledoverSlot",docs:["The slot when the account was rolled over, a rolled over account should not be written to."],type:"u64"},{name:"closeThreshold",docs:["If current slot is greater than rolledover_slot + close_threshold and","the account is empty it can be closed. No 'close' functionality has been","implemented yet."],type:"u64"},{name:"additionalBytes",docs:["Placeholder for bytes of additional accounts which are tied to the","Merkle trees operation and need to be rolled over as well."],type:"u64"}]}},{name:"TokenData",type:{kind:"struct",fields:[{name:"mint",docs:["The mint associated with this account"],type:"publicKey"},{name:"owner",docs:["The owner of this account."],type:"publicKey"},{name:"amount",docs:["The amount of tokens this account holds."],type:"u64"},{name:"delegate",docs:["If `delegate` is `Some` then `delegated_amount` represents","the amount authorized by the delegate"],type:{option:"publicKey"}},{name:"state",docs:["The account's state"],type:{defined:"AccountState"}},{name:"tlv",docs:["Placeholder for TokenExtension tlv data (unimplemented)"],type:{option:"bytes"}}]}}],errors:[{code:6e3,name:"PublicKeyAmountMissmatch",msg:"public keys and amounts must be of same length"},{code:6001,name:"ComputeInputSumFailed",msg:"ComputeInputSumFailed"},{code:6002,name:"ComputeOutputSumFailed",msg:"ComputeOutputSumFailed"},{code:6003,name:"ComputeCompressSumFailed",msg:"ComputeCompressSumFailed"},{code:6004,name:"ComputeDecompressSumFailed",msg:"ComputeDecompressSumFailed"},{code:6005,name:"SumCheckFailed",msg:"SumCheckFailed"},{code:6006,name:"DecompressRecipientUndefinedForDecompress",msg:"DecompressRecipientUndefinedForDecompress"},{code:6007,name:"CompressedPdaUndefinedForDecompress",msg:"CompressedPdaUndefinedForDecompress"},{code:6008,name:"DeCompressAmountUndefinedForDecompress",msg:"DeCompressAmountUndefinedForDecompress"},{code:6009,name:"CompressedPdaUndefinedForCompress",msg:"CompressedPdaUndefinedForCompress"},{code:6010,name:"DeCompressAmountUndefinedForCompress",msg:"DeCompressAmountUndefinedForCompress"},{code:6011,name:"DelegateSignerCheckFailed",msg:"DelegateSignerCheckFailed"},{code:6012,name:"MintTooLarge",msg:"Minted amount greater than u64::MAX"},{code:6013,name:"SplTokenSupplyMismatch",msg:"SplTokenSupplyMismatch"},{code:6014,name:"HeapMemoryCheckFailed",msg:"HeapMemoryCheckFailed"},{code:6015,name:"InstructionNotCallable",msg:"The instruction is not callable"},{code:6016,name:"ArithmeticUnderflow",msg:"ArithmeticUnderflow"},{code:6017,name:"HashToFieldError",msg:"HashToFieldError"},{code:6018,name:"InvalidAuthorityMint",msg:"Expected the authority to be also a mint authority"},{code:6019,name:"InvalidFreezeAuthority",msg:"Provided authority is not the freeze authority"},{code:6020,name:"InvalidDelegateIndex"},{code:6021,name:"TokenPoolPdaUndefined"},{code:6022,name:"IsTokenPoolPda",msg:"Compress or decompress recipient is the same account as the token pool pda."},{code:6023,name:"InvalidTokenPoolPda"},{code:6024,name:"NoInputTokenAccountsProvided"},{code:6025,name:"NoInputsProvided"}]};var rt,ot,st,it,at,ct,ut,dt;t.UtxoErrorCode=void 0,(rt=t.UtxoErrorCode||(t.UtxoErrorCode={})).NEGATIVE_LAMPORTS="NEGATIVE_LAMPORTS",rt.NOT_U64="NOT_U64",rt.BLINDING_EXCEEDS_FIELD_SIZE="BLINDING_EXCEEDS_FIELD_SIZE",t.SelectInUtxosErrorCode=void 0,(ot=t.SelectInUtxosErrorCode||(t.SelectInUtxosErrorCode={})).FAILED_TO_FIND_UTXO_COMBINATION="FAILED_TO_FIND_UTXO_COMBINATION",ot.INVALID_NUMBER_OF_IN_UTXOS="INVALID_NUMBER_OF_IN_UTXOS",t.CreateUtxoErrorCode=void 0,(st=t.CreateUtxoErrorCode||(t.CreateUtxoErrorCode={})).OWNER_UNDEFINED="OWNER_UNDEFINED",st.INVALID_OUTPUT_UTXO_LENGTH="INVALID_OUTPUT_UTXO_LENGTH",st.UTXO_DATA_UNDEFINED="UTXO_DATA_UNDEFINED",t.RpcErrorCode=void 0,(it=t.RpcErrorCode||(t.RpcErrorCode={})).CONNECTION_UNDEFINED="CONNECTION_UNDEFINED",it.RPC_PUBKEY_UNDEFINED="RPC_PUBKEY_UNDEFINED",it.RPC_METHOD_NOT_IMPLEMENTED="RPC_METHOD_NOT_IMPLEMENTED",it.RPC_INVALID="RPC_INVALID",t.LookupTableErrorCode=void 0,(at=t.LookupTableErrorCode||(t.LookupTableErrorCode={})).LOOK_UP_TABLE_UNDEFINED="LOOK_UP_TABLE_UNDEFINED",at.LOOK_UP_TABLE_NOT_INITIALIZED="LOOK_UP_TABLE_NOT_INITIALIZED",t.HashErrorCode=void 0,(t.HashErrorCode||(t.HashErrorCode={})).NO_POSEIDON_HASHER_PROVIDED="NO_POSEIDON_HASHER_PROVIDED",t.ProofErrorCode=void 0,(ct=t.ProofErrorCode||(t.ProofErrorCode={})).INVALID_PROOF="INVALID_PROOF",ct.PROOF_INPUT_UNDEFINED="PROOF_INPUT_UNDEFINED",ct.PROOF_GENERATION_FAILED="PROOF_GENERATION_FAILED",t.MerkleTreeErrorCode=void 0,(ut=t.MerkleTreeErrorCode||(t.MerkleTreeErrorCode={})).MERKLE_TREE_NOT_INITIALIZED="MERKLE_TREE_NOT_INITIALIZED",ut.SOL_MERKLE_TREE_UNDEFINED="SOL_MERKLE_TREE_UNDEFINED",ut.MERKLE_TREE_UNDEFINED="MERKLE_TREE_UNDEFINED",ut.INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE="INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE",ut.MERKLE_TREE_INDEX_UNDEFINED="MERKLE_TREE_INDEX_UNDEFINED",ut.MERKLE_TREE_SET_SPACE_UNDEFINED="MERKLE_TREE_SET_SPACE_UNDEFINED",t.UtilsErrorCode=void 0,(dt=t.UtilsErrorCode||(t.UtilsErrorCode={})).ACCOUNT_NAME_UNDEFINED_IN_IDL="ACCOUNT_NAME_UNDEFINED_IN_IDL",dt.PROPERTY_UNDEFINED="PROPERTY_UNDEFINED",dt.LOOK_UP_TABLE_CREATION_FAILED="LOOK_UP_TABLE_CREATION_FAILED",dt.UNSUPPORTED_ARCHITECTURE="UNSUPPORTED_ARCHITECTURE",dt.UNSUPPORTED_PLATFORM="UNSUPPORTED_PLATFORM",dt.ACCOUNTS_UNDEFINED="ACCOUNTS_UNDEFINED",dt.INVALID_NUMBER="INVALID_NUMBER";class lt extends Error{constructor(e,t,n){super(`${e}: ${n}`),this.code=e,this.functionName=t,this.codeMessage=n}}class pt extends TypeError{constructor(e,t){let n;const{message:r,explanation:o,...s}=e,{path:i}=e,a=0===i.length?r:`At path: ${i.join(".")} -- ${r}`;super(o??a),null!=o&&(this.cause=a),Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}}function mt(e){return"object"==typeof e&&null!=e}function ht(e){return mt(e)&&!Array.isArray(e)}function ft(e){return"symbol"==typeof e?e.toString():"string"==typeof e?JSON.stringify(e):`${e}`}function gt(e,t,n,r){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:o,branch:s}=t,{type:i}=n,{refinement:a,message:c=`Expected a value of type \`${i}\`${a?` with refinement \`${a}\``:""}, but received: \`${ft(r)}\``}=e;return{value:r,type:i,refinement:a,key:o[o.length-1],path:o,branch:s,...e,message:c}}function*yt(e,t,n,r){var o;mt(o=e)&&"function"==typeof o[Symbol.iterator]||(e=[e]);for(const o of e){const e=gt(o,t,n,r);e&&(yield e)}}function*wt(e,t,n={}){const{path:r=[],branch:o=[e],coerce:s=!1,mask:i=!1}=n,a={path:r,branch:o,mask:i};s&&(e=t.coercer(e,a));let c="valid";for(const r of t.validator(e,a))r.explanation=n.message,c="not_valid",yield[r,void 0];for(let[u,d,l]of t.entries(e,a)){const t=wt(d,l,{path:void 0===u?r:[...r,u],branch:void 0===u?o:[...o,d],coerce:s,mask:i,message:n.message});for(const n of t)n[0]?(c=null!=n[0].refinement?"not_refined":"not_valid",yield[n[0],void 0]):s&&(d=n[1],void 0===u?e=d:e instanceof Map?e.set(u,d):e instanceof Set?e.add(d):mt(e)&&(void 0!==d||u in e)&&(e[u]=d))}if("not_valid"!==c)for(const r of t.refiner(e,a))r.explanation=n.message,c="not_refined",yield[r,void 0];"valid"===c&&(yield[void 0,e])}class bt{constructor(e){const{type:t,schema:n,validator:r,refiner:o,coercer:s=(e=>e),entries:i=function*(){}}=e;this.type=t,this.schema=n,this.entries=i,this.coercer=s,this.validator=r?(e,t)=>yt(r(e,t),t,this,e):()=>[],this.refiner=o?(e,t)=>yt(o(e,t),t,this,e):()=>[]}assert(e,t){return function(e,t,n){const r=kt(e,t,{message:n});if(r[0])throw r[0]}(e,this,t)}create(e,t){return At(e,this,t)}is(e){return St(e,this)}mask(e,t){return function(e,t,n){const r=kt(e,t,{coerce:!0,mask:!0,message:n});if(r[0])throw r[0];return r[1]}(e,this,t)}validate(e,t={}){return kt(e,this,t)}}function At(e,t,n){const r=kt(e,t,{coerce:!0,message:n});if(r[0])throw r[0];return r[1]}function St(e,t){return!kt(e,t)[0]}function kt(e,t,n={}){const r=wt(e,t,n),o=function(e){const{done:t,value:n}=e.next();return t?void 0:n}(r);return o[0]?[new pt(o[0],(function*(){for(const e of r)e[0]&&(yield e[0])})),void 0]:[void 0,o[1]]}function Pt(e,t){return new bt({type:e,schema:null,validator:t})}function Et(){return Pt("any",(()=>!0))}function vt(e){return new bt({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[n,r]of t.entries())yield[n,r,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||`Expected an array value, but received: ${ft(e)}`})}function Tt(e){return Pt("instance",(t=>t instanceof e||`Expected a \`${e.name}\` instance, but received: ${ft(t)}`))}function Ct(e){const t=ft(e);return new bt({type:"literal",schema:e,validator:n=>n===e||`Expected the literal \`${t}\`, but received: ${ft(n)}`})}function Mt(e){return new bt({...e,validator:(t,n)=>null===t||e.validator(t,n),refiner:(t,n)=>null===t||e.refiner(t,n)})}function It(){return Pt("number",(e=>"number"==typeof e&&!isNaN(e)||`Expected a number, but received: ${ft(e)}`))}function xt(){return Pt("string",(e=>"string"==typeof e||`Expected a string, but received: ${ft(e)}`))}function _t(e){const t=Object.keys(e);return new bt({type:"type",schema:e,*entries(n){if(mt(n))for(const r of t)yield[r,n[r],e[r]]},validator:e=>ht(e)||`Expected an object, but received: ${ft(e)}`,coercer:e=>ht(e)?{...e}:e})}function Ot(){return Pt("unknown",(()=>!0))}function Nt(e,t,n){return new bt({...e,coercer:(r,o)=>St(r,t)?e.coercer(n(r,o),o):e.coercer(r,o)})}const Dt=Nt(Tt(o.PublicKey),xt(),(e=>new o.PublicKey(e))),Bt=Nt(Tt(Array),xt(),(e=>Array.from(new o.PublicKey(e).toBytes()))),Lt=Nt(Tt(s.BN),xt(),(e=>W(e,"base58"))),Ut=Nt(Tt(s.BN),It(),(e=>Number.isSafeInteger(e)?V(e):V(e.toString(),10))),Rt=Nt(xt(),xt(),(e=>""===e?null:e));function Ft(e){return function(e){const t=e.map((e=>e.type)).join(" | ");return new bt({type:"union",schema:null,coercer(t,n){for(const r of e){const[e,o]=r.validate(t,{coerce:!0,mask:n.mask});if(!e)return o}return t},validator(n,r){const o=[];for(const t of e){const[...e]=wt(n,t,r),[s]=e;if(!s[0])return[];for(const[t]of e)t&&o.push(t)}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${ft(n)}`,...o]}})}([_t({jsonrpc:Ct("2.0"),id:xt(),result:e}),_t({jsonrpc:Ct("2.0"),id:xt(),error:_t({code:Ot(),message:xt(),data:Mt(Et())})})])}const Kt=Ft(Ot());function zt(e){return Nt(Ft(e),Kt,(t=>"error"in t?t:Object.assign(Object.assign({},t),{result:At(t.result,e)})))}function $t(e){return zt(_t({context:_t({slot:It()}),value:e}))}const Vt=_t({address:Mt(Bt),hash:Lt,data:Mt(_t({data:Rt,dataHash:Lt,discriminator:Ut})),lamports:Ut,owner:Dt,leafIndex:It(),tree:Dt,seq:Mt(Ut),slotCreated:Ut}),Wt=_t({mint:Dt,owner:Dt,amount:Ut,delegate:Mt(Dt),state:xt()}),Ht=_t({tokenData:Wt,account:Vt}),qt=_t({items:vt(Vt)}),jt=_t({items:vt(Vt),cursor:Mt(xt())}),Qt=_t({items:vt(Ht),cursor:Mt(xt())}),Gt=It(),Yt=xt(),Xt=_t({items:vt(_t({signature:xt(),slot:It(),blockTime:It(),error:Mt(xt())}))}),Jt=_t({items:vt(_t({signature:xt(),slot:It(),blockTime:It()})),cursor:Mt(xt())}),Zt=_t({hash:Lt,leafIndex:It(),merkleTree:Dt,proof:vt(Lt),rootSeq:It(),root:Lt}),en=_t({address:Lt,nextIndex:It(),merkleTree:Dt,proof:vt(Lt),rootSeq:It(),root:Lt,lowerRangeAddress:Lt,higherRangeAddress:Lt,lowElementLeafIndex:It()}),tn=_t({a:vt(It()),b:vt(It()),c:vt(It())}),nn=_t({compressedProof:tn,leafIndices:vt(It()),leaves:vt(Lt),rootIndices:vt(It()),roots:vt(Lt),merkleTrees:vt(Dt)}),rn=vt(Zt),on=_t({amount:Ut}),sn=Ut,an=_t({balance:Ut,mint:Dt}),cn=_t({tokenBalances:vt(an),cursor:Mt(xt())}),un=_t({hash:vt(It()),root:vt(It()),proof:vt(vt(It()))}),dn=_t({items:vt(_t({blockTime:It(),signature:xt(),slot:It()}))}),ln=_t({items:vt(_t({blockTime:It(),signature:xt(),slot:It()})),cursor:Mt(xt())}),pn=_t({compressionInfo:_t({closedAccounts:vt(_t({account:Vt,optionalTokenData:Mt(Wt)})),openedAccounts:vt(_t({account:Vt,optionalTokenData:Mt(Wt)}))}),transaction:Et()});function mn({discriminator:e,data:t,dataHash:n}){return{discriminator:e.toArray("le",8),data:i.Buffer.from(t,"base64"),dataHash:n.toArray("le",32)}}async function hn(e,t,n,r=!1){var s;const i=r?"getCompressedTokenAccountsByDelegate":"getCompressedTokenAccountsByOwner",a=r?"delegate":"owner",c=At(await gn(e.compressionApiEndpoint,i,{[a]:t.toBase58(),mint:null===(s=n.mint)||void 0===s?void 0:s.toBase58(),limit:n.limit,cursor:n.cursor}),$t(Qt));if("error"in c)throw new o.SolanaJSONRPCError(c.error,`failed to get info for compressed accounts by ${a} ${t.toBase58()}`);if(null===c.result.value)throw new Error("not implemented: NULL result");const u=[];return c.result.value.items.map((e=>{var n;const r=e.account,s=e.tokenData,i=j(Q(r.tree,An,r.hash.toArray("be",32),r.leafIndex),new o.PublicKey("cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m"),V(r.lamports),r.data?mn(r.data):void 0,r.address||void 0),c={mint:s.mint,owner:s.owner,amount:s.amount,delegate:s.delegate,state:["uninitialized","initialized","frozen"].indexOf(s.state),tlv:null};if((null===(n=c[a])||void 0===n?void 0:n.toBase58())!==t.toBase58())throw new Error(`RPC returned token account with ${a} different from requested ${a}`);u.push({compressedAccount:i,parsed:c})})),{items:u.sort(((e,t)=>t.compressedAccount.leafIndex-e.compressedAccount.leafIndex)),cursor:c.result.value.cursor}}function fn(e){const t=e.account,n=e.optionalTokenData,r=j(Q(t.merkleTree,An,t.hash.toArray("be",32),t.leafIndex),t.owner,V(t.lamports),t.data?mn(t.data):void 0,t.address||void 0);return null===n?{account:r,maybeTokenData:null}:{account:r,maybeTokenData:{mint:n.mint,owner:n.owner,amount:n.amount,delegate:n.delegate,state:["uninitialized","initialized","frozen"].indexOf(n.state),tlv:null}}}const gn=async(e,t,n=[],r=!0,o=!1)=>{const s=JSON.stringify({jsonrpc:"2.0",id:"test-account",method:t,params:n});if(o){const t=()=>{const t=s.replace(/"/g,'\\"');return`curl -X POST ${e} \\\n     -H "Content-Type: application/json" \\\n     -d "${t}"`};console.log("Debug: Stack trace:"),console.log((new Error).stack),console.log("\nDebug: curl:"),console.log(t()),console.log("\n")}const i=await fetch(e,{method:"POST",headers:{"Content-Type":"application/json"},body:s});if(!i.ok)throw new Error(`HTTP error! status: ${i.status}`);return r?Te(await i.json()):await i.json()},yn=async(e,t,n=[],r=!1)=>{let o,s="";r&&(s=`Proof generation for method:${t}`,console.time(s)),"inclusion"===t?o=JSON.stringify({"input-compressed-accounts":n}):"new-address"===t?o=JSON.stringify({"new-addresses":n}):"combined"===t&&(o=JSON.stringify({"input-compressed-accounts":n[0],"new-addresses":n[1]}));const i=await fetch(`${e}/prove`,{method:"POST",headers:{"Content-Type":"application/json"},body:o});if(!i.ok)throw new Error(`Error fetching proof: ${i.statusText}`);const a=Re(Ue(await i.json()));return r&&console.timeEnd(s),a};function wn(e){const t=[];for(let n=0;n<e.length;n++){const r={root:Se(e[n].root),pathIndex:e[n].leafIndex,pathElements:e[n].merkleProof.map((e=>Se(e))),leaf:Se(V(e[n].hash))};t.push(r)}return t}function bn(e){const t=[];for(let n=0;n<e.length;n++){const r={root:Se(e[n].root),value:Se(e[n].value),pathIndex:e[n].indexHashedIndexedElementLeaf.toNumber(),pathElements:e[n].merkleProofHashedIndexedElementLeaf.map((e=>Se(e))),nextIndex:e[n].nextIndex.toNumber(),leafLowerRangeValue:Se(e[n].leafLowerRangeValue),leafHigherRangeValue:Se(e[n].leafHigherRangeValue)};t.push(r)}return t}const An=C().nullifierQueue,Sn=C().addressQueue;class kn extends o.Connection{constructor(e,t,n,r){super(e,r||"confirmed"),this.compressionApiEndpoint=t,this.proverEndpoint=n}async getCompressedAccount(e,t){if(!t&&!e)throw new Error("Either hash or address must be provided");if(t&&e)throw new Error("Only one of hash or address must be provided");const n=At(await gn(this.compressionApiEndpoint,"getCompressedAccount",{hash:t?H(t):void 0,address:e?H(e):void 0}),$t(Mt(Vt)));if("error"in n)throw new o.SolanaJSONRPCError(n.error,`failed to get info for compressed account ${t?t.toString():e?e.toString():""}`);if(null===n.result.value)return null;const r=n.result.value;return j(Q(r.tree,An,r.hash.toArray("be",32),r.leafIndex),r.owner,V(r.lamports),r.data?mn(r.data):void 0,r.address||void 0)}async getCompressedBalance(e,t){if(!t&&!e)throw new Error("Either hash or address must be provided");if(t&&e)throw new Error("Only one of hash or address must be provided");const n=At(await gn(this.compressionApiEndpoint,"getCompressedBalance",{hash:t?H(t):void 0,address:e?H(e):void 0}),$t(sn));if("error"in n)throw new o.SolanaJSONRPCError(n.error,`failed to get balance for compressed account ${t?t.toString():e?e.toString():""}`);return null===n.result.value?V(0):V(n.result.value)}async getCompressedBalanceByOwner(e){const t=At(await gn(this.compressionApiEndpoint,"getCompressedBalanceByOwner",{owner:e.toBase58()}),$t(sn));if("error"in t)throw new o.SolanaJSONRPCError(t.error,`failed to get balance for compressed account ${e.toBase58()}`);return null===t.result.value?V(0):V(t.result.value)}async getCompressedAccountProof(e){const t=At(await gn(this.compressionApiEndpoint,"getCompressedAccountProof",{hash:H(e)}),$t(Zt));if("error"in t)throw new o.SolanaJSONRPCError(t.error,`failed to get proof for compressed account ${e.toString()}`);if(null===t.result.value)throw new Error(`failed to get proof for compressed account ${e.toString()}`);return{hash:t.result.value.hash.toArray("be",32),merkleTree:t.result.value.merkleTree,leafIndex:t.result.value.leafIndex,merkleProof:t.result.value.proof,nullifierQueue:An,rootIndex:t.result.value.rootSeq%2400,root:t.result.value.root}}async getMultipleCompressedAccounts(e){const t=At(await gn(this.compressionApiEndpoint,"getMultipleCompressedAccounts",{hashes:e.map((e=>H(e)))}),$t(qt));if("error"in t)throw new o.SolanaJSONRPCError(t.error,`failed to get info for compressed accounts ${e.map((e=>H(e))).join(", ")}`);if(null===t.result.value)throw new Error(`failed to get info for compressed accounts ${e.map((e=>H(e))).join(", ")}`);const n=[];return t.result.value.items.map((e=>{const t=j(Q(e.tree,An,e.hash.toArray("be",32),e.leafIndex),e.owner,V(e.lamports),e.data?mn(e.data):void 0,e.address||void 0);n.push(t)})),n.sort(((e,t)=>t.leafIndex-e.leafIndex))}async getMultipleCompressedAccountProofs(e){const t=At(await gn(this.compressionApiEndpoint,"getMultipleCompressedAccountProofs",e.map((e=>H(e)))),$t(vt(Zt)));if("error"in t)throw new o.SolanaJSONRPCError(t.error,`failed to get proofs for compressed accounts ${e.map((e=>H(e))).join(", ")}`);if(null===t.result.value)throw new Error(`failed to get proofs for compressed accounts ${e.map((e=>H(e))).join(", ")}`);const n=[];for(const e of t.result.value){const t={hash:e.hash.toArray("be",32),merkleTree:e.merkleTree,leafIndex:e.leafIndex,merkleProof:e.proof,nullifierQueue:Sn,rootIndex:e.rootSeq%2400,root:e.root};n.push(t)}return n}async getCompressedAccountsByOwner(e,t){var n;const r=At(await gn(this.compressionApiEndpoint,"getCompressedAccountsByOwner",{owner:e.toBase58(),filters:(null==t?void 0:t.filters)||[],dataSlice:null==t?void 0:t.dataSlice,cursor:null==t?void 0:t.cursor,limit:null===(n=null==t?void 0:t.limit)||void 0===n?void 0:n.toNumber()}),$t(jt));if("error"in r)throw new o.SolanaJSONRPCError(r.error,`failed to get info for compressed accounts owned by ${e.toBase58()}`);if(null===r.result.value)return{items:[],cursor:null};const s=[];return r.result.value.items.map((e=>{const t=j(Q(e.tree,An,e.hash.toArray("be",32),e.leafIndex),e.owner,V(e.lamports),e.data?mn(e.data):void 0,e.address||void 0);s.push(t)})),{items:s.sort(((e,t)=>t.leafIndex-e.leafIndex)),cursor:r.result.value.cursor}}async getCompressedTokenAccountsByOwner(e,t){return t||(t={}),await hn(this,e,t,!1)}async getCompressedTokenAccountsByDelegate(e,t){return t||(t={}),hn(this,e,t,!0)}async getCompressedTokenAccountBalance(e){const t=At(await gn(this.compressionApiEndpoint,"getCompressedTokenAccountBalance",{hash:H(e)}),$t(on));if("error"in t)throw new o.SolanaJSONRPCError(t.error,`failed to get balance for compressed token account ${e.toString()}`);if(null===t.result.value)throw new Error(`failed to get balance for compressed token account ${e.toString()}`);return{amount:V(t.result.value.amount)}}async getCompressedTokenBalancesByOwner(e,t){var n;t||(t={});const r=At(await gn(this.compressionApiEndpoint,"getCompressedTokenBalancesByOwner",{owner:e.toBase58(),mint:null===(n=t.mint)||void 0===n?void 0:n.toBase58(),limit:t.limit,cursor:t.cursor}),$t(cn));if("error"in r)throw new o.SolanaJSONRPCError(r.error,`failed to get compressed token balances for owner ${e.toBase58()}`);if(null===r.result.value)throw new Error(`failed to get compressed token balances for owner ${e.toBase58()}`);return{items:t.mint?r.result.value.tokenBalances.filter((e=>e.mint.toBase58()===t.mint.toBase58())):r.result.value.tokenBalances,cursor:r.result.value.cursor}}async getCompressionSignaturesForAccount(e){const t=At(await gn(this.compressionApiEndpoint,"getCompressionSignaturesForAccount",{hash:H(e)}),$t(dn));if("error"in t)throw new o.SolanaJSONRPCError(t.error,`failed to get signatures for compressed account ${e.toString()}`);return t.result.value.items}async getTransactionWithCompressionInfo(e){const t=At(await gn(this.compressionApiEndpoint,"getTransactionWithCompressionInfo",{signature:e}),zt(pn));if("error"in t)throw new o.SolanaJSONRPCError(t.error,"failed to get slot");if(null===t.result.transaction)return null;const n=[],r=[];t.result.compressionInfo.closedAccounts.map((e=>{n.push(fn(e))})),t.result.compressionInfo.openedAccounts.map((e=>{r.push(fn(e))}));const s=e=>{const t=Object.values(e.reduce(((e,{maybeTokenData:t})=>{if(t){const{owner:n,mint:r,amount:o}=t,s=`${n.toBase58()}_${r.toBase58()}`;s in e?e[s].amount=e[s].amount.add(o):e[s]={owner:n,mint:r,amount:o}}return e}),{}));return t.length>0?t:void 0},i=s(n),a=s(r);return{compressionInfo:{closedAccounts:n,openedAccounts:r,preTokenBalances:i,postTokenBalances:a},transaction:t.result.transaction}}async getCompressionSignaturesForAddress(e){const t=At(await gn(this.compressionApiEndpoint,"getCompressionSignaturesForAddress",{address:e.toBase58()}),$t(ln));if("error"in t)throw new o.SolanaJSONRPCError(t.error,`failed to get signatures for address ${e.toBase58()}`);if(null===t.result.value)throw new Error(`failed to get signatures for address ${e.toBase58()}`);return t.result.value}async getCompressionSignaturesForOwner(e){const t=At(await gn(this.compressionApiEndpoint,"getCompressionSignaturesForOwner",{owner:e.toBase58()}),$t(ln));if("error"in t)throw new o.SolanaJSONRPCError(t.error,`failed to get signatures for owner ${e.toBase58()}`);if(null===t.result.value)throw new Error(`failed to get signatures for owner ${e.toBase58()}`);return t.result.value}async getCompressionSignaturesForTokenOwner(e){const t=At(await gn(this.compressionApiEndpoint,"getCompressionSignaturesForTokenOwner",{owner:e.toBase58()}),$t(ln));if("error"in t)throw new o.SolanaJSONRPCError(t.error,`failed to get signatures for owner ${e.toBase58()}`);if(null===t.result.value)throw new Error(`failed to get signatures for owner ${e.toBase58()}`);return t.result.value}async getIndexerHealth(){const e=At(await gn(this.compressionApiEndpoint,"getIndexerHealth"),zt(Yt));if("error"in e)throw new o.SolanaJSONRPCError(e.error,"failed to get health");return e.result}async confirmTransactionIndexed(e){const t=Date.now();for(;;){if(await this.getIndexerSlot()>=e)return!0;if(Date.now()-t>2e4)throw new Error("Timeout: Indexer slot did not reach the required slot within 20 seconds");await new Promise((e=>setTimeout(e,200)))}}async getIndexerSlot(){const e=At(await gn(this.compressionApiEndpoint,"getIndexerSlot"),zt(Gt));if("error"in e)throw new o.SolanaJSONRPCError(e.error,"failed to get slot");return e.result}async getLatestCompressionSignatures(e,t){const n=At(await gn(this.compressionApiEndpoint,"getLatestCompressionSignatures",{limit:t,cursor:e}),$t(Jt));if("error"in n)throw new o.SolanaJSONRPCError(n.error,"failed to get latest non-voting signatures");return n.result}async getLatestNonVotingSignatures(e){const t=At(await gn(this.compressionApiEndpoint,"getLatestNonVotingSignatures",{limit:e}),$t(Xt));if("error"in t)throw new o.SolanaJSONRPCError(t.error,"failed to get latest non-voting signatures");return t.result}async getMultipleNewAddressProofs(e){const t=At(await gn(this.compressionApiEndpoint,"getMultipleNewAddressProofs",e.map((e=>H(e)))),$t(vt(en)));if("error"in t)throw new o.SolanaJSONRPCError(t.error,`failed to get proofs for new addresses ${e.map((e=>H(e))).join(", ")}`);if(null===t.result.value)throw new Error(`failed to get proofs for new addresses ${e.map((e=>H(e))).join(", ")}`);const n=[];for(const e of t.result.value){const t={root:e.root,rootIndex:e.rootSeq%2400,value:e.address,leafLowerRangeValue:e.lowerRangeAddress,leafHigherRangeValue:e.higherRangeAddress,nextIndex:V(e.nextIndex),merkleProofHashedIndexedElementLeaf:e.proof,indexHashedIndexedElementLeaf:V(e.lowElementLeafIndex),merkleTree:e.merkleTree,nullifierQueue:Sn};n.push(t)}return n}async getValidityProofDirect(e=[],t=[]){let n;if(0===e.length&&0===t.length)throw new Error("Empty input. Provide hashes and/or new addresses.");if(e.length>0&&0===t.length){const t=await this.getMultipleCompressedAccountProofs(e),r=wn(t);n={compressedProof:await yn(this.proverEndpoint,"inclusion",r,!1),roots:t.map((e=>e.root)),rootIndices:t.map((e=>e.rootIndex)),leafIndices:t.map((e=>e.leafIndex)),leaves:t.map((e=>V(e.hash))),merkleTrees:t.map((e=>e.merkleTree)),nullifierQueues:t.map((e=>e.nullifierQueue))}}else if(0===e.length&&t.length>0){const e=await this.getMultipleNewAddressProofs(t),r=bn(e);n={compressedProof:await yn(this.proverEndpoint,"new-address",r,!1),roots:e.map((e=>e.root)),rootIndices:e.map((e=>e.rootIndex)),leafIndices:e.map((e=>e.nextIndex.toNumber())),leaves:e.map((e=>V(e.value))),merkleTrees:e.map((e=>e.merkleTree)),nullifierQueues:e.map((e=>e.nullifierQueue))}}else{if(!(e.length>0&&t.length>0))throw new Error("Invalid input");{const r=await this.getMultipleCompressedAccountProofs(e),o=wn(r),s=await this.getMultipleNewAddressProofs(t),i=bn(s);n={compressedProof:await yn(this.proverEndpoint,"combined",[o,i],!1),roots:r.map((e=>e.root)).concat(s.map((e=>e.root))),rootIndices:r.map((e=>e.rootIndex)).concat(s.map((e=>e.rootIndex))),leafIndices:r.map((e=>e.leafIndex)).concat(s.map((e=>e.nextIndex.toNumber()))),leaves:r.map((e=>V(e.hash))).concat(s.map((e=>V(e.value)))),merkleTrees:r.map((e=>e.merkleTree)).concat(s.map((e=>e.merkleTree))),nullifierQueues:r.map((e=>e.nullifierQueue)).concat(s.map((e=>e.nullifierQueue)))}}}return n}async getValidityProof(e=[],t=[]){const n=C().addressTree,r=C().addressQueue,o=C().merkleTree,i=C().nullifierQueue,a=e.map((e=>e instanceof s.BN?{hash:e,tree:o,queue:i}:e)),c=t.map((e=>e instanceof s.BN?{address:e,tree:n,queue:r}:e));return this.getValidityProofV0(a,c)}async getValidityProofV0(e=[],t=[]){const{value:n}=await this.getValidityProofAndRpcContext(e,t);return n}async getValidityProofAndRpcContext(e=[],t=[]){const n=At(await gn(this.compressionApiEndpoint,"getValidityProof",{hashes:e.map((({hash:e})=>H(e))),newAddressesWithTrees:t.map((({address:e,tree:t})=>({address:H(e),tree:t.toBase58()})))}),$t(nn));if("error"in n)throw new o.SolanaJSONRPCError(n.error,`failed to get ValidityProof for compressed accounts ${e.map((e=>e.toString()))}`);const r=n.result.value;if(null===r)throw new Error(`failed to get ValidityProof for compressed accounts ${e.map((e=>e.toString()))}`);return{value:{compressedProof:r.compressedProof,merkleTrees:r.merkleTrees,leafIndices:r.leafIndices,nullifierQueues:[...e.map((({queue:e})=>e)),...t.map((({queue:e})=>e))],rootIndices:r.rootIndices,roots:r.roots,leaves:r.leaves},context:n.result.context}}}class Pn{constructor(e,t,n=[],{zeroElement:r="0"}={}){if(this.levels=e,this.capacity=2**e,this.zeroElement=r,this._lightWasm=t,n.length>this.capacity)throw new Error("Tree is full");this._zeros=[],this._layers=[],this._layers[0]=n,this._zeros[0]=this.zeroElement;for(let t=1;t<=e;t++)this._zeros[t]=this._lightWasm.poseidonHashString([this._zeros[t-1],this._zeros[t-1]]);this._rebuild()}_rebuild(){for(let e=1;e<=this.levels;e++){this._layers[e]=[];for(let t=0;t<Math.ceil(this._layers[e-1].length/2);t++)this._layers[e][t]=this._lightWasm.poseidonHashString([this._layers[e-1][2*t],2*t+1<this._layers[e-1].length?this._layers[e-1][2*t+1]:this._zeros[e-1]])}}root(){return this._layers[this.levels].length>0?this._layers[this.levels][0]:this._zeros[this.levels]}insert(e){if(this._layers[0].length>=this.capacity)throw new Error("Tree is full");this.update(this._layers[0].length,e)}bulkInsert(e){if(this._layers[0].length+e.length>this.capacity)throw new Error("Tree is full");this._layers[0].push(...e),this._rebuild()}update(e,t){if(isNaN(Number(e))||e<0||e>this._layers[0].length||e>=this.capacity)throw new Error("Insert index out of bounds: "+e);this._layers[0][e]=t;for(let t=1;t<=this.levels;t++)e>>=1,this._layers[t][e]=this._lightWasm.poseidonHashString([this._layers[t-1][2*e],2*e+1<this._layers[t-1].length?this._layers[t-1][2*e+1]:this._zeros[t-1]])}path(e){if(isNaN(Number(e))||e<0||e>=this._layers[0].length)throw new Error("Index out of bounds: "+e);const t=[],n=[];for(let r=0;r<this.levels;r++)n[r]=e%2,t[r]=(1^e)<this._layers[r].length?this._layers[r][1^e]:this._zeros[r],e>>=1;return{pathElements:t,pathIndices:n}}indexOf(e,t=null){return t?this._layers[0].findIndex((n=>t(e,n))):this._layers[0].indexOf(e)}elements(){return this._layers[0].slice()}serialize(){return{levels:this.levels,_zeros:this._zeros,_layers:this._layers}}static deserialize(e,t){const n=Object.assign(Object.create(this.prototype),e);return n._hash=t,n.capacity=2**n.levels,n.zeroElement=n._zeros[0],n}}function En(e){return null!=e&&"object"==typeof e&&!Array.isArray(e)}function vn(){let e=null,t=null;const n=new Promise(((n,r)=>{e=n,t=r}));return n.resolve=e,n.reject=t,n}const Tn={bold:["1","22"],dim:["2","22"],italic:["3","23"],underline:["4","24"],inverse:["7","27"],hidden:["8","28"],strike:["9","29"],black:["30","39"],red:["31","39"],green:["32","39"],yellow:["33","39"],blue:["34","39"],magenta:["35","39"],cyan:["36","39"],white:["37","39"],brightblack:["30;1","39"],brightred:["31;1","39"],brightgreen:["32;1","39"],brightyellow:["33;1","39"],brightblue:["34;1","39"],brightmagenta:["35;1","39"],brightcyan:["36;1","39"],brightwhite:["37;1","39"],grey:["90","39"]},Cn={special:"cyan",number:"yellow",bigint:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",symbol:"green",date:"magenta",regexp:"red"},Mn="";function In(e,t){const n=Tn[Cn[t]]||Tn[t]||"";return n?`[${n[0]}m${String(e)}[${n[1]}m`:String(e)}function xn(e,t,n=Mn){e=String(e);const r=n.length,o=e.length;if(r>t&&o>r)return n;if(o>t&&o>r){let o=t-r;return o>0&&(s=e[o-1])>="\ud800"&&s<="\udbff"&&(o-=1),`${e.slice(0,o)}${n}`}var s;return e}function _n(e,t,n,r=", "){n=n||t.inspect;const o=e.length;if(0===o)return"";const s=t.truncate;let i="",a="",c="";for(let u=0;u<o;u+=1){const o=u+1===e.length,d=u+2===e.length;c=`${Mn}(${e.length-u})`;const l=e[u];t.truncate=s-i.length-(o?0:r.length);const p=a||n(l,t)+(o?"":r),m=i.length+p.length,h=m+c.length;if(o&&m>s&&i.length+c.length<=s)break;if(!o&&!d&&h>s)break;if(a=o?"":n(e[u+1],t)+(d?"":r),!o&&d&&h>s&&m+a.length>s)break;if(i+=p,!o&&!d&&m+a.length>=s){c=`${Mn}(${e.length-u-1})`;break}c=""}return`${i}${c}`}function On([e,t],n){return n.truncate-=2,"string"==typeof e?e=function(e){return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)?e:JSON.stringify(e).replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'")}(e):"number"!=typeof e&&(e=`[${n.inspect(e,n)}]`),n.truncate-=e.length,`${e}: ${t=n.inspect(t,n)}`}function Nn(e,t){const n=(e=>"function"==typeof r&&e instanceof r?"Buffer":e[Symbol.toStringTag]?e[Symbol.toStringTag]:e.constructor.name)(e);t.truncate-=n.length+4;const o=Object.keys(e).slice(e.length);if(!e.length&&!o.length)return`${n}[]`;let s="";for(let n=0;n<e.length;n++){const r=`${t.stylize(xn(e[n],t.truncate),"number")}${n===e.length-1?"":", "}`;if(t.truncate-=r.length,e[n]!==e.length&&t.truncate<=3){s+=`${Mn}(${e.length-e[n]+1})`;break}s+=r}let i="";return o.length&&(i=_n(o.map((t=>[t,e[t]])),t,On)),`${n}[ ${s}${i?`, ${i}`:""} ]`}function Dn(e,t){const n=e[Symbol.toStringTag]||"Function",r=e.name;return r?t.stylize(`[${n} ${xn(r,t.truncate-11)}]`,"special"):t.stylize(`[${n}]`,"special")}function Bn([e,t],n){return n.truncate-=4,e=n.inspect(e,n),n.truncate-=e.length,`${e} => ${t=n.inspect(t,n)}`}const Ln=Number.isNaN||(e=>e!=e);function Un(e,t){return Ln(e)?t.stylize("NaN","number"):e===1/0?t.stylize("Infinity","number"):e===-1/0?t.stylize("-Infinity","number"):0===e?t.stylize(1/e==1/0?"+0":"-0","number"):t.stylize(xn(String(e),t.truncate),"number")}function Rn(e,t){let n=xn(e.toString(),t.truncate-1);return n!==Mn&&(n+="n"),t.stylize(n,"bigint")}const Fn=new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]","g"),Kn={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r","'":"\\'","\\":"\\\\"},zn=16,$n=4;function Vn(e){return Kn[e]||`\\u${`0000${e.charCodeAt(0).toString(zn)}`.slice(-$n)}`}function Wn(e,t){return Fn.test(e)&&(e=e.replace(Fn,Vn)),t.stylize(`'${xn(e,t.truncate-2)}'`,"string")}function Hn(e){return"description"in Symbol.prototype?e.description?`Symbol(${e.description})`:"Symbol()":e.toString()}let qn=()=>"Promise{}";try{const{getPromiseDetails:e,kPending:t,kRejected:n}={env:{__DEV__:!1,IS_STATIC:"",NODE_ENV:"production",TAMAGUI_TARGET:"web",DEBUG:"0",BACKPACK_ENV:"production",BACKPACK_CONFIG_LOG_LEVEL:"none",BACKPACK_CONFIG_VERSION:"0.10.190-2"}}.binding("util");Array.isArray(e(Promise.resolve()))&&(qn=(r,o)=>{const[s,i]=e(r);return s===t?"Promise{<pending>}":`Promise${s===n?"!":""}{${o.inspect(i,o)}}`})}catch(e){}var jn=qn;function Qn(e,t){const n=Object.getOwnPropertyNames(e),r=Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(e):[];if(0===n.length&&0===r.length)return"{}";if(t.truncate-=4,t.seen=t.seen||[],t.seen.indexOf(e)>=0)return"[Circular]";t.seen.push(e);const o=_n(n.map((t=>[t,e[t]])),t,On),s=_n(r.map((t=>[t,e[t]])),t,On);t.seen.pop();let i="";return o&&s&&(i=", "),`{ ${o}${i}${s} }`}const Gn=!("undefined"==typeof Symbol||!Symbol.toStringTag)&&Symbol.toStringTag,Yn=["stack","line","column","name","message","fileName","lineNumber","columnNumber","number","description"];function Xn([e,t],n){return n.truncate-=3,t?`${n.stylize(String(e),"yellow")}=${n.stylize(`"${t}"`,"string")}`:`${n.stylize(String(e),"yellow")}`}function Jn(e,t){return _n(e,t,Zn,"\n")}function Zn(e,t){const n=e.getAttributeNames(),r=e.tagName.toLowerCase(),o=t.stylize(`<${r}`,"special"),s=t.stylize(">","special"),i=t.stylize(`</${r}>`,"special");t.truncate-=2*r.length+5;let a="";n.length>0&&(a+=" ",a+=_n(n.map((t=>[t,e.getAttribute(t)])),t,Xn," ")),t.truncate-=a.length;const c=t.truncate;let u=Jn(e.children,t);return u&&u.length>c&&(u=`${Mn}(${e.children.length})`),`${o}${a}${s}${u}${i}`}const er="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("chai/inspect"):"@@chai/inspect";let tr=!1;try{const e=n(443335);tr=!!e.inspect&&e.inspect.custom}catch(e){tr=!1}const nr=new WeakMap,rr={},or={undefined:(e,t)=>t.stylize("undefined","undefined"),null:(e,t)=>t.stylize("null","null"),boolean:(e,t)=>t.stylize(String(e),"boolean"),Boolean:(e,t)=>t.stylize(String(e),"boolean"),number:Un,Number:Un,bigint:Rn,BigInt:Rn,string:Wn,String:Wn,function:Dn,Function:Dn,symbol:Hn,Symbol:Hn,Array:function(e,t){const n=Object.keys(e).slice(e.length);if(!e.length&&!n.length)return"[]";t.truncate-=4;const r=_n(e,t);t.truncate-=r.length;let o="";return n.length&&(o=_n(n.map((t=>[t,e[t]])),t,On)),`[ ${r}${o?`, ${o}`:""} ]`},Date:function(e,t){const n=e.toJSON();if(null===n)return"Invalid Date";const r=n.split("T"),o=r[0];return t.stylize(`${o}T${xn(r[1],t.truncate-o.length-1)}`,"date")},Map:function(e,t){return e.size-1<=0?"Map{}":(t.truncate-=7,`Map{ ${_n(function(e){const t=[];return e.forEach(((e,n)=>{t.push([n,e])})),t}(e),t,Bn)} }`)},Set:function(e,t){return 0===e.size?"Set{}":(t.truncate-=7,`Set{ ${_n(function(e){const t=[];return e.forEach((e=>{t.push(e)})),t}(e),t)} }`)},RegExp:function(e,t){const n=e.toString().split("/")[2],r=t.truncate-(2+n.length),o=e.source;return t.stylize(`/${xn(o,r)}/${n}`,"regexp")},Promise:jn,WeakSet:(e,t)=>t.stylize("WeakSet{}","special"),WeakMap:(e,t)=>t.stylize("WeakMap{}","special"),Arguments:function(e,t){return 0===e.length?"Arguments[]":(t.truncate-=13,`Arguments[ ${_n(e,t)} ]`)},Int8Array:Nn,Uint8Array:Nn,Uint8ClampedArray:Nn,Int16Array:Nn,Uint16Array:Nn,Int32Array:Nn,Uint32Array:Nn,Float32Array:Nn,Float64Array:Nn,Generator:()=>"",DataView:()=>"",ArrayBuffer:()=>"",Error:function(e,t){const n=Object.getOwnPropertyNames(e).filter((e=>-1===Yn.indexOf(e))),r=e.name;t.truncate-=r.length;let o="";"string"==typeof e.message?o=xn(e.message,t.truncate):n.unshift("message"),o=o?`: ${o}`:"",t.truncate-=o.length+5;const s=_n(n.map((t=>[t,e[t]])),t,On);return`${r}${o}${s?` { ${s} }`:""}`},HTMLCollection:Jn,NodeList:Jn},sr=(e,t,n)=>er in e&&"function"==typeof e[er]?e[er](t):tr&&tr in e&&"function"==typeof e[tr]?e[tr](t.depth,t):"inspect"in e&&"function"==typeof e.inspect?e.inspect(t.depth,t):"constructor"in e&&nr.has(e.constructor)?nr.get(e.constructor)(e,t):rr[n]?rr[n](e,t):"",ir=Object.prototype.toString;function ar(e,t={}){const n=function({showHidden:e=!1,depth:t=2,colors:n=!1,customInspect:r=!0,showProxy:o=!1,maxArrayLength:s=1/0,breakLength:i=1/0,seen:a=[],truncate:c=1/0,stylize:u=String}={},d){const l={showHidden:Boolean(e),depth:Number(t),colors:Boolean(n),customInspect:Boolean(r),showProxy:Boolean(o),maxArrayLength:Number(s),breakLength:Number(i),truncate:Number(c),seen:a,inspect:d,stylize:u};return l.colors&&(l.stylize=In),l}(t,ar),{customInspect:r}=n;let o=null===e?"null":typeof e;if("object"===o&&(o=ir.call(e).slice(8,-1)),o in or)return or[o](e,n);if(r&&e){const t=sr(e,n,o);if(t)return"string"==typeof t?t:ar(t,n)}const s=!!e&&Object.getPrototypeOf(e);return s===Object.prototype||null===s?Qn(e,n):e&&"function"==typeof HTMLElement&&e instanceof HTMLElement?Zn(e,n):"constructor"in e?e.constructor!==Object?function(e,t){let n="";return Gn&&Gn in e&&(n=e[Gn]),n=n||e.constructor.name,n&&"_class"!==n||(n="<Anonymous Class>"),t.truncate-=n.length,`${n}${Qn(e,t)}`}(e,n):Qn(e,n):e===Object(e)?Qn(e,n):n.stylize(String(e),o)}var cr=Object.entries({reset:[0,0],bold:[1,22,"[22m[1m"],dim:[2,22,"[22m[2m"],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29],black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],gray:[90,39],bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],blackBright:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39],bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]});function ur(e){return String(e)}ur.open="",ur.close="",function(e=!1){let t=function(e=!1){let t={env:{__DEV__:!1,IS_STATIC:"",NODE_ENV:"production",TAMAGUI_TARGET:"web",DEBUG:"0",BACKPACK_ENV:"production",BACKPACK_CONFIG_LOG_LEVEL:"none",BACKPACK_CONFIG_VERSION:"0.10.190-2"}},n=(null==t?void 0:t.env)||{},r=(null==t?void 0:t.argv)||[];return!("NO_COLOR"in n||r.includes("--no-color"))&&("FORCE_COLOR"in n||r.includes("--color")||"win32"===(null==t?void 0:t.platform)||e&&"dumb"!==n.TERM||"CI"in n)||"undefined"!=typeof window&&!!window.chrome}(e),n=(e,t,n=e)=>{let r=r=>{let o=String(r),s=o.indexOf(t,e.length);return~s?e+((e,t,n,r)=>{let o="",s=0;do{o+=e.substring(s,r)+n,s=r+t.length,r=e.indexOf(t,s)}while(~r);return o+e.substring(s)})(o,t,n,s)+t:e+o+t};return r.open=e,r.close=t,r},r={isColorSupported:t},o=e=>`[${e}m`;for(let[e,s]of cr)r[e]=t?n(o(s[0]),o(s[1]),s[2]):ur}(!1);const dr=/%[sdjifoOc%]/g;function lr(e,t={}){return 0===t.truncate&&(t.truncate=Number.POSITIVE_INFINITY),ar(e,t)}const pr=Symbol("vitest:SAFE_TIMERS");RegExp(/\r?\n|[\r\u2028\u2029]/y.source);function mr(e,t){const n=function n(r){const o=function(...e){return t.apply(r,e)};Object.assign(o,t),o.withContext=()=>o.bind(r),o.setContext=(e,t)=>{r[e]=t},o.mergeContext=e=>{Object.assign(r,e)};for(const t of e)Object.defineProperty(o,t,{get:()=>n({...r,[t]:!0})});return o}({});return n.fn=t,n}new Set(["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete"]),new Set(["implements","interface","let","package","private","protected","public","static","yield"]);const hr=new WeakMap,fr=new WeakMap,gr=new WeakMap;class yr extends Error{constructor(e,t){super(e),this.message=e,this.taskId=t.id}code="VITEST_PENDING";taskId}const wr={tasks:[],currentSuite:null};const br=new Map,Ar=new Map;function Sr(e,t){return n=>{const r=n||t;if(!r)return e({});const o=(s=r,fr.get(s));var s;if(!(null==o?void 0:o.length))return e(r);const i=Er(e),a=o.some((({auto:e})=>e));if(!i.length&&!a)return e(r);br.get(r)||br.set(r,new Map);const c=br.get(r);Ar.has(r)||Ar.set(r,[]);const u=Ar.get(r),d=Pr(o.filter((({prop:e,auto:t})=>t||i.includes(e))));return d.length?async function(){for(const e of d){if(c.has(e))continue;const t=e.isFn?await kr(e.value,r,u):e.value;r[e.prop]=t,c.set(e,t),u.unshift((()=>{c.delete(e)}))}}().then((()=>e(r))):e(r)}}async function kr(e,t,n){const r=vn();let o=!1;const s=e(t,(async e=>{o=!0,r.resolve(e);const t=vn();n.push((async()=>{t.resolve(),await s})),await t})).catch((e=>{if(o)throw e;r.reject(e)}));return r}function Pr(e,t=new Set,n=[]){return e.forEach((e=>{if(!n.includes(e))if(e.isFn&&e.deps){if(t.has(e))throw new Error(`Circular fixture dependency detected: ${e.prop} <- ${[...t].reverse().map((e=>e.prop)).join(" <- ")}`);t.add(e),Pr(e.deps,t,n),n.push(e),t.clear()}else n.push(e)})),n}function Er(e){const t=e.toString().match(/[^(]*\(([^)]*)/);if(!t)return[];const n=vr(t[1]);if(!n.length)return[];let r=n[0];if("__VITEST_FIXTURE_INDEX__"in e&&(r=n[e.__VITEST_FIXTURE_INDEX__],!r))return[];if(!r.startsWith("{")||!r.endsWith("}"))throw new Error(`The first argument inside a fixture must use object destructuring pattern, e.g. ({ test } => {}). Instead, received "${r}".`);const o=vr(r.slice(1,-1).replace(/\s/g,"")).map((e=>e.replace(/:.*|=.*/g,""))),s=o.at(-1);if(s&&s.startsWith("..."))throw new Error(`Rest parameters are not supported in fixtures, received "${s}".`);return o}function vr(e){const t=[],n=[];let r=0;for(let o=0;o<e.length;o++)if("{"===e[o]||"["===e[o])n.push("{"===e[o]?"}":"]");else if(e[o]===n[n.length-1])n.pop();else if(!n.length&&","===e[o]){const n=e.substring(r,o).trim();n&&t.push(n),r=o+1}const o=e.substring(r).trim();return o&&t.push(o),t}const Tr=function(){function e(e,t,n={}){const r=this.only?"only":this.skip?"skip":this.todo?"todo":"run",o=wr.currentSuite||Mr;let{options:s,handler:i}=xr(t,n);(null==o?void 0:o.options)&&(s={...o.options,...s});const a=s.concurrent||this.concurrent&&!this.sequential,c=s.sequential||this.sequential&&!this.concurrent;return s.concurrent=a&&!c,s.sequential=c&&!a,function(e,t=(()=>{}),n,r,o,s){const i=[],a=[];let c;p();const u=function(e="",t={}){const n={id:"",name:e,suite:void 0,each:t.each,fails:t.fails,context:void 0,type:"custom",file:void 0,retry:t.retry??Cr.config.retry,repeats:t.repeats,mode:t.only?"only":t.skip?"skip":t.todo?"todo":"run",meta:t.meta??Object.create(null)},o=t.handler;(t.concurrent||!t.sequential&&Cr.config.sequence.concurrent)&&(n.concurrent=!0),r&&(n.shuffle=!0);const s=function(e,t){var n;const r=function(){throw new Error("done() callback is deprecated, use promise instead")};return r.task=e,r.skip=()=>{throw e.pending=!0,new yr("test is skipped; abort execution",e)},r.onTestFailed=t=>{e.onFailed||(e.onFailed=[]),e.onFailed.push(t)},r.onTestFinished=t=>{e.onFinished||(e.onFinished=[]),e.onFinished.push(t)},(null==(n=t.extendTaskContext)?void 0:n.call(t,r))||r}(n,Cr);var a,c;return Object.defineProperty(n,"context",{value:s,enumerable:!1}),a=s,c=t.fixtures,fr.set(a,c),o&&function(e,t){hr.set(e,t)}(n,function(e,t,n=!1){if(t<=0||t===Number.POSITIVE_INFINITY)return e;const{setTimeout:r,clearTimeout:o}=function(){const{setTimeout:e,setInterval:t,clearInterval:n,clearTimeout:r,setImmediate:o,clearImmediate:s}=globalThis[pr]||globalThis,{nextTick:i}=globalThis[pr]||globalThis.process||{nextTick:e=>e()};return{nextTick:i,setTimeout:e,setInterval:t,clearInterval:n,clearTimeout:r,setImmediate:o,clearImmediate:s}}();return function(...s){return Promise.race([e(...s),new Promise(((e,s)=>{var i;const a=r((()=>{o(a),s(new Error(function(e,t){return`${e?"Hook":"Test"} timed out in ${t}ms.\nIf this is a long-running ${e?"hook":"test"}, pass a timeout value as the last argument or configure it globally with "${e?"hookTimeout":"testTimeout"}".`}(n,t)))}),t);null==(i=a.unref)||i.call(a)}))])}}(function(e,t){return async(...n)=>{if(await e(...n),t.promises){const e=(await Promise.allSettled(t.promises)).map((e=>"rejected"===e.status?e.reason:void 0)).filter(Boolean);if(e.length)throw e}}}(Sr(o,s),n),(null==t?void 0:t.timeout)??Cr.config.testTimeout)),Cr.config.includeTaskLocation,i.push(n),n},d=_r((function(e,t,n){let{options:r,handler:o}=xr(t,n);"object"==typeof s&&(r=Object.assign({},s,r)),r.concurrent=this.concurrent||!this.sequential&&(null==r?void 0:r.concurrent),r.sequential=this.sequential||!this.concurrent&&(null==r?void 0:r.sequential),u(Or(e),{...this,...r,handler:o}).type="test"})),l={type:"collector",name:e,mode:n,options:s,test:d,tasks:i,collect:async function(e){if(!e)throw new TypeError("File is required to collect tasks.");a.length=0,t&&await async function(e,n){const r=wr.currentSuite;wr.currentSuite=e,await t(d),wr.currentSuite=r}(l);const n=[];for(const t of[...a,...i])n.push("collector"===t.type?await t.collect(e):t);return c.file=e,c.tasks=n,n.forEach((t=>{t.suite=c,t.file=e})),c},task:u,clear:function(){i.length=0,a.length=0,p()},on:function(e,...t){var n;(n=c,gr.get(n))[e].push(...t)}};function p(t){var i,a;"number"==typeof s&&(s={timeout:s}),c={id:"",type:"suite",name:e,mode:n,each:o,file:void 0,shuffle:r,tasks:[],meta:Object.create(null),concurrent:null==s?void 0:s.concurrent},i=c,a={beforeAll:[],afterAll:[],beforeEach:[],afterEach:[]},gr.set(i,a)}return function(e){var t;null==(t=wr.currentSuite)||t.tasks.push(e)}(l),l}(Or(e),i,r,this.shuffle,this.each,s)}return e.each=function(e,...t){const n=this.withContext();return this.setContext("each",!0),Array.isArray(e)&&t.length&&(e=Dr(e,t)),(t,r,o)=>{const s=Or(t),i=e.every(Array.isArray),{options:a,handler:c}=xr(r,o),u="function"==typeof r;e.forEach(((e,t)=>{const r=Array.isArray(e)?e:[e];u?n(Nr(s,r,t),i?()=>c(...r):()=>c(e),a):n(Nr(s,r,t),a,i?()=>c(...r):()=>c(e))})),this.setContext("each",void 0)}},e.skipIf=e=>e?Tr.skip:Tr,e.runIf=e=>e?Tr:Tr.skip,mr(["concurrent","sequential","shuffle","skip","only","todo"],e)}();let Cr,Mr;function Ir(){const e=wr.currentSuite||Mr;return function(e,t){if(!e)throw new Error(`Vitest failed to find ${t}. This is a bug in Vitest. Please, open an issue with reproduction.`)}(e,"the current suite"),e}function xr(e,t){let n={},r=()=>{};if("object"==typeof t){if("object"==typeof e)throw new TypeError("Cannot use two objects as arguments. Please provide options and a function callback in that order.");n=t}else"number"==typeof t?n={timeout:t}:"object"==typeof e&&(n=e);if("function"==typeof e){if("function"==typeof t)throw new TypeError("Cannot use two functions as arguments. Please use the second argument for options.");r=e}else"function"==typeof t&&(r=t);return{options:n,handler:r}}function _r(e,t){return function(e,t){const n=e;n.each=function(e,...t){const n=this.withContext();return this.setContext("each",!0),Array.isArray(e)&&t.length&&(e=Dr(e,t)),(t,r,o)=>{const s=Or(t),i=e.every(Array.isArray),{options:a,handler:c}=xr(r,o),u="function"==typeof r;e.forEach(((e,t)=>{const r=Array.isArray(e)?e:[e];u?n(Nr(s,r,t),i?()=>c(...r):()=>c(e),a):n(Nr(s,r,t),a,i?()=>c(...r):()=>c(e))})),this.setContext("each",void 0)}},n.for=function(e,...t){const n=this.withContext();return Array.isArray(e)&&t.length&&(e=Dr(e,t)),(t,r,o)=>{const s=Or(t),{options:i,handler:a}=xr(r,o);e.forEach(((e,t)=>{const r=t=>a(e,t);r.__VITEST_FIXTURE_INDEX__=1,r.toString=()=>a.toString(),n(Nr(s,function(e){return null==e&&(e=[]),Array.isArray(e)?e:[e]}(e),t),i,r)}))}},n.skipIf=function(e){return e?this.skip:this},n.runIf=function(e){return e?this:this.skip},n.extend=function(e){const n=function(e,t={}){const n=["auto"],r=Object.entries(e).map((([e,t])=>{const r={value:t};return Array.isArray(t)&&t.length>=2&&En(t[1])&&Object.keys(t[1]).some((e=>n.includes(e)))&&(Object.assign(r,t[1]),r.value=t[0]),r.prop=e,r.isFn="function"==typeof r.value,r}));return Array.isArray(t.fixtures)?t.fixtures=t.fixtures.concat(r):t.fixtures=r,r.forEach((e=>{if(e.isFn){const n=Er(e.value);n.length&&(e.deps=t.fixtures.filter((({prop:t})=>t!==e.prop&&n.includes(t))))}})),t}(e,t);return _r((function(e,t,n){Ir().test.fn.call(this,Or(e),t,n)}),n)};const r=mr(["concurrent","sequential","skip","only","todo","fails"],n);return t&&r.mergeContext(t),r}(e,t)}function Or(e){return"string"==typeof e?e:e instanceof Function?e.name||"<anonymous>":String(e)}function Nr(e,t,n){e.includes("%#")&&(e=e.replace(/%%/g,"__vitest_escaped_%__").replace(/%#/g,`${n}`).replace(/__vitest_escaped_%__/g,"%%"));const r=e.split("%").length-1;e.includes("%f")&&(e.match(/%f/g)||[]).forEach(((n,r)=>{if(function(e){if(!Number.isNaN(e))return!1;const t=new Float64Array(1);return t[0]=e,new Uint32Array(t.buffer)[1]>>>31==1}(t[r])||Object.is(t[r],-0)){let t=0;e=e.replace(/%f/g,(e=>(t++,t===r+1?"-%f":e)))}}));let o=function(...e){if("string"!=typeof e[0]){const t=[];for(let n=0;n<e.length;n++)t.push(lr(e[n],{depth:0,colors:!1}));return t.join(" ")}const t=e.length;let n=1;const r=e[0];let o=String(r).replace(dr,(r=>{if("%%"===r)return"%";if(n>=t)return r;switch(r){case"%s":{const t=e[n++];return"bigint"==typeof t?`${t.toString()}n`:"number"==typeof t&&0===t&&1/t<0?"-0":"object"==typeof t&&null!==t?lr(t,{depth:0,colors:!1}):String(t)}case"%d":{const t=e[n++];return"bigint"==typeof t?`${t.toString()}n`:Number(t).toString()}case"%i":{const t=e[n++];return"bigint"==typeof t?`${t.toString()}n`:Number.parseInt(String(t)).toString()}case"%f":return Number.parseFloat(String(e[n++])).toString();case"%o":return lr(e[n++],{showHidden:!0,showProxy:!0});case"%O":return lr(e[n++]);case"%c":return n++,"";case"%j":try{return JSON.stringify(e[n++])}catch(e){const t=e.message;if(t.includes("circular structure")||t.includes("cyclic structures")||t.includes("cyclic object"))return"[Circular]";throw e}default:return r}}));for(let r=e[n];n<t;r=e[++n])o+=null===r||"object"!=typeof r?` ${r}`:` ${lr(r)}`;return o}(e,...t.slice(0,r));return En(t[0])&&(o=o.replace(/\$([$\w.]+)/g,((e,n)=>function(e,t={}){void 0===t.truncate&&(t.truncate=40);const n=lr(e,t),r=Object.prototype.toString.call(e);if(t.truncate&&n.length>=t.truncate){if("[object Function]"===r){const t=e;return t.name?`[Function: ${t.name}]`:"[Function]"}if("[object Array]"===r)return`[ Array(${e.length}) ]`;if("[object Object]"===r){const t=Object.keys(e);return`{ Object (${t.length>2?`${t.splice(0,2).join(", ")}, ...`:t.join(", ")}) }`}return n}return n}(function(e,t,n){const r=t.replace(/\[(\d+)\]/g,".$1").split(".");let o=e;for(const e of r)if(o=new Object(o)[e],void 0===o)return;return o}(t[0],n),{truncate:null==void 0?void 0:undefined.truncateThreshold})))),o}function Dr(e,t){const n=e.join("").trim().replace(/ /g,"").split("\n").map((e=>e.split("|")))[0],r=[];for(let e=0;e<Math.floor(t.length/n.length);e++){const o={};for(let r=0;r<n.length;r++)o[n[r]]=t[e*n.length+r];r.push(o)}return r}_r((function(e,t,n){Ir().test.fn.call(this,Or(e),t,n)})),globalThis.performance?globalThis.performance.now.bind(globalThis.performance):Date.now,globalThis.performance?globalThis.performance.now.bind(globalThis.performance):Date.now;class Br{constructor(e,t,n){this.index=e,this.value=t,this.nextIndex=n}equals(e){return this.value.eq(e.value)}compareTo(e){return this.value.cmp(e.value)}hash(e,t){try{return e.poseidonHash([V(this.value.toArray("be",32)).toString(),V(this.nextIndex).toString(),V(t.toArray("be",32)).toString()])}catch(e){throw new Error("Hashing failed")}}}class Lr{constructor(e,t,n){this.newLowElement=e,this.newElement=t,this.newElementNextValue=n}}class Ur{constructor(e,t,n){this.elements=e,this.currentNodeIndex=t,this.highestElementIndex=n}static default(){return new Ur([new Br(0,V(0),0)],0,0)}get(e){return this.elements[e]}length(){return Number(this.currentNodeIndex)}isEmpty(){return 0===this.currentNodeIndex}findElement(e){return this.elements.slice(0,this.length()+1).find((t=>t.value===e))}init(){try{const e=A;return this.append(e)}catch(e){throw new Error(`Failed to initialize IndexedArray: ${e}`)}}findLowElementIndex(e){for(let t=0;t<=this.length();t++){const n=this.elements[t];if(this.elements[n.nextIndex].value.gt(e)&&n.value.lt(e))return t;if(n.value.eq(e))throw new Error("Element already exists in the array")}return this.highestElementIndex}findLowElement(e){const t=this.findLowElementIndex(e);if(void 0===t)return[void 0,void 0];const n=this.elements[t];return[n,this.elements[n.nextIndex].value]}hashElement(e,t){const n=this.elements[t];if(!n)return;const r=this.elements[n.nextIndex];return r?e.poseidonHash([V(n.value.toArray("be",32)).toString(),V(n.nextIndex).toString(),V(r.value.toArray("be",32)).toString()]):void 0}append(e){const t=this.findLowElementIndex(e);if(void 0===t)throw new Error("Low element index not found.");return this.appendWithLowElementIndex(t,e)}appendWithLowElementIndex(e,t){const n=this.elements[e];if(0===n.nextIndex){if(t.lte(n.value))throw new Error("New element value must be greater than the low element value.")}else{const e=this.elements[n.nextIndex];if(t.lte(n.value))throw new Error("New element value must be greater than the low element value.");if(t.gte(e.value))throw new Error("New element value must be less than the next element value.")}const r=this.newElementWithLowElementIndex(e,t);return 0===n.nextIndex&&(this.highestElementIndex=r.newElement.index),this.currentNodeIndex=r.newElement.index,this.elements[this.length()]=r.newElement,this.elements[e]=r.newLowElement,r}lowest(){return this.elements.length>0?this.elements[0]:void 0}newElementWithLowElementIndex(e,t){const n=this.elements[e],r=this.currentNodeIndex+1,o=new Br(r,t,n.nextIndex);n.nextIndex=r;const s=this.elements[o.nextIndex].value;return new Lr(n,o,s)}newElement(e){const t=this.findLowElementIndex(e);if(void 0===t)throw new Error("Low element index not found.");return this.newElementWithLowElementIndex(t,e)}}var Rr={},Fr={};Object.defineProperty(Fr,"__esModule",{value:!0}),Fr.decode=Fr.encode=void 0;const Kr=i;Fr.encode=function(e){return e.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),"0x")},Fr.decode=function(e){0===e.indexOf("0x")&&(e=e.substr(2)),e.length%2==1&&(e="0"+e);let t=e.match(/.{2}/g);return null===t?Kr.Buffer.from([]):Kr.Buffer.from(t.map((e=>parseInt(e,16))))};var zr,$r={},Vr={};Object.defineProperty(Vr,"__esModule",{value:!0}),Vr.isVersionedTransaction=Vr.chunks=Vr.isBrowser=void 0,Vr.isBrowser={__DEV__:!1,IS_STATIC:"",NODE_ENV:"production",TAMAGUI_TARGET:"web",DEBUG:"0",BACKPACK_ENV:"production",BACKPACK_CONFIG_LOG_LEVEL:"none",BACKPACK_CONFIG_VERSION:"0.10.190-2"}.ANCHOR_BROWSER||"undefined"!=typeof window&&!(null===(zr=window.process)||void 0===zr?void 0:zr.hasOwnProperty("type")),Vr.chunks=function(e,t){return Array.apply(0,new Array(Math.ceil(e.length/t))).map(((n,r)=>e.slice(r*t,(r+1)*t)))},Vr.isVersionedTransaction=e=>"version"in e,Object.defineProperty($r,"__esModule",{value:!0}),$r.encode=$r.decode=void 0;const Wr=Vr;$r.decode=function(e){return(Wr.isBrowser?new TextDecoder("utf-8"):new c.TextDecoder("utf-8")).decode(e)},$r.encode=function(e){return(Wr.isBrowser?new TextEncoder:new c.TextEncoder("utf-8")).encode(e)};var Hr={},qr=d&&d.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(Hr,"__esModule",{value:!0}),Hr.decode=Hr.encode=void 0;const jr=qr(z);Hr.encode=function(e){return jr.default.encode(e)},Hr.decode=function(e){return jr.default.decode(e)};var Qr={};Object.defineProperty(Qr,"__esModule",{value:!0}),Qr.decode=Qr.encode=void 0;const Gr=i;Qr.encode=function(e){return e.toString("base64")},Qr.decode=function(e){return Gr.Buffer.from(e,"base64")};var Yr=d&&d.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var o=Object.getOwnPropertyDescriptor(t,n);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,o)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),Xr=d&&d.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),Jr=d&&d.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&Yr(t,e,n);return Xr(t,e),t};Object.defineProperty(Rr,"__esModule",{value:!0}),Rr.base64=Zr=Rr.bs58=Rr.utf8=Rr.hex=void 0,Rr.hex=Jr(Fr),Rr.utf8=Jr($r);var Zr=Rr.bs58=Jr(Hr);async function eo(e){const{noopProgram:t,accountCompressionProgram:n}=T(),r=(await e.getConfirmedSignaturesForAddress2(n,void 0,"confirmed")).map((e=>e.signature)),o=(await e.getParsedTransactions(r,{maxSupportedTransactionVersion:0,commitment:"confirmed"})).filter((e=>!!e&&e.transaction.message.accountKeys.some((e=>("string"==typeof e?e:e.pubkey.toBase58())===t.toBase58()))));return to(o,no)}Rr.base64=Jr(Qr);const to=(e,t)=>{const{noopProgram:n}=T(),o=[];return e.forEach((e=>{!e||!e.meta||e.meta.err||!e.meta.innerInstructions||e.meta.innerInstructions.length<=0||e.meta.innerInstructions.forEach((s=>{if(s.instructions.length>0){const i=s.instructions[s.instructions.length-1];if("data"in i&&i.data&&i.programId.toBase58()===n.toBase58()){const n=Zr.decode(i.data),s=t(r.from(n),e);null!=s&&o.push(s)}}}))})),o},no=e=>{const t=r.from(e.map((e=>e)));try{return et.program.coder.types.decode("PublicTransactionEvent",t)}catch(e){return console.error("Error deserializing event:",e),null}};async function ro(e,t){return(await oo(e)).find((e=>V(e.hash).eq(t)))}async function oo(e){var t,n;const r=(await eo(e)).reverse(),o=[],s=[];for(const e of r){for(let r=0;r<e.outputCompressedAccounts.length;r++){const s=e.outputCompressedAccounts[r],i={merkleTree:C().merkleTree,nullifierQueue:C().nullifierQueue,hash:e.outputCompressedAccountHashes[r],leafIndex:e.outputLeafIndices[r]},a=j(i,s.compressedAccount.owner,s.compressedAccount.lamports,null!==(t=s.compressedAccount.data)&&void 0!==t?t:void 0,null!==(n=s.compressedAccount.address)&&void 0!==n?n:void 0);o.push(a)}for(let t=0;t<e.inputCompressedAccountHashes.length;t++){const n=e.inputCompressedAccountHashes[t];s.push(V(n))}}const i=o.filter((e=>!s.some((t=>t.eq(V(e.hash))))));return i.sort(((e,t)=>t.leafIndex-e.leafIndex)),i}const so=new o.PublicKey("cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m");async function io(e){const t=await Promise.all(e.map((e=>async function(e){const t=e.pubkeyArray,n=e.outputCompressedAccountHashes,o=e.outputCompressedAccounts.map(((o,i)=>{var a;const c={merkleTree:t[e.outputCompressedAccounts[i].merkleTreeIndex],nullifierQueue:C().nullifierQueue,hash:n[i],leafIndex:e.outputLeafIndices[i]};if(!o.compressedAccount.data)throw new Error("No data");const u=function(e){if(null===e.data)return null;const{data:t}=e.data;if(0===t.length)return null;if(e.owner.toBase58()!==so.toBase58())throw new Error(`Invalid owner ${e.owner.toBase58()} for token layout`);return new s.BorshCoder(nt).types.decode("TokenData",r.from(t))}(o.compressedAccount);if(!u)throw new Error("Invalid token data");return{compressedAccount:j(c,o.compressedAccount.owner,o.compressedAccount.lamports,o.compressedAccount.data,null!==(a=o.compressedAccount.address)&&void 0!==a?a:void 0),parsed:u}}));return{inputCompressedAccountHashes:e.inputCompressedAccountHashes,outputCompressedAccounts:o}}(e)))),n=t.flatMap((e=>e.outputCompressedAccounts)),o=t.flatMap((e=>e.inputCompressedAccountHashes));return n.filter((e=>!o.some((t=>JSON.stringify(t)===JSON.stringify(e.compressedAccount.hash)))))}async function ao(e,t,n){const r=await eo(e);return{items:(await io(r)).filter((e=>e.parsed.owner.equals(t)&&e.parsed.mint.equals(n))).sort(((e,t)=>t.compressedAccount.leafIndex-e.compressedAccount.leafIndex)),cursor:null}}class co extends o.Connection{constructor(e,t,n,r,o,s){super(e,o||"confirmed"),this.log=!1,this.compressionApiEndpoint=n,this.proverEndpoint=r;const{merkleTreeAddress:i,nullifierQueueAddress:a,depth:c,log:u,addressTreeAddress:d,addressQueueAddress:l}=null!=s?s:{},{merkleTree:p,nullifierQueue:m,merkleTreeHeight:h,addressQueue:f,addressTree:g}=C();this.lightWasm=t,this.merkleTreeAddress=null!=i?i:p,this.nullifierQueueAddress=null!=a?a:m,this.addressTreeAddress=null!=d?d:g,this.addressQueueAddress=null!=l?l:f,this.depth=null!=c?c:h,this.log=null!=u&&u}async getCompressedAccount(e,t){if(e)throw new Error("address is not supported in test-rpc");if(!t)throw new Error("hash is required");const n=await ro(this,t);return null!=n?n:null}async getCompressedBalance(e,t){if(e)throw new Error("address is not supported in test-rpc");if(!t)throw new Error("hash is required");const n=await ro(this,t);if(!n)throw new Error("Account not found");return V(n.lamports)}async getCompressedBalanceByOwner(e){return(await this.getCompressedAccountsByOwner(e)).items.reduce(((e,t)=>e.add(t.lamports)),V(0))}async getCompressedAccountProof(e){return(await this.getMultipleCompressedAccountProofs([e]))[0]}async getMultipleCompressedAccounts(e){return await async function(e,t){return(await oo(e)).filter((e=>t.some((t=>V(e.hash).eq(t))))).sort(((e,t)=>t.leafIndex-e.leafIndex))}(this,e)}async confirmTransactionIndexed(e){return!0}async getMultipleCompressedAccountProofs(e){const t=await eo(this).then((e=>e.reverse())),n=[],r=[];for(const e of t)for(let t=0;t<e.outputCompressedAccounts.length;t++){const o=e.outputCompressedAccountHashes[t];n.push(o),r.push(e.outputLeafIndices[t])}const o=new Pn(this.depth,this.lightWasm,n.map((e=>V(e).toString()))),s=[];for(let t=0;t<e.length;t++){const r=o.indexOf(e[t].toString()),i=o.path(r).pathElements.map((e=>V(e))),a=V(o.root()),c={hash:e[t].toArray("be",32),merkleTree:this.merkleTreeAddress,leafIndex:r,merkleProof:i,nullifierQueue:this.nullifierQueueAddress,rootIndex:n.length,root:a};s.push(c)}return s.forEach(((e,t)=>{const n=e.leafIndex,r=o.elements()[n],s=V(r).toArray("be",32);if(!s.every(((t,n)=>t===e.hash[n])))throw new Error(`Mismatch at index ${t}: expected ${e.hash.toString()}, got ${s.toString()}`)})),s}async getCompressedAccountsByOwner(e,t){const n=await async function(e,t){return(await oo(e)).filter((e=>e.owner.equals(t)))}(this,e);return{items:n,cursor:null}}async getLatestCompressionSignatures(e,t){throw new Error("getLatestNonVotingSignaturesWithContext not supported in test-rpc")}async getLatestNonVotingSignatures(e){throw new Error("getLatestNonVotingSignaturesWithContext not supported in test-rpc")}async getCompressedTokenAccountsByOwner(e,t){return await ao(this,e,t.mint)}async getCompressedTokenAccountsByDelegate(e,t){return await async function(e,t,n){const r=await eo(e);return{items:(await io(r)).filter((e=>{var r;return(null===(r=e.parsed.delegate)||void 0===r?void 0:r.equals(t))&&e.parsed.mint.equals(n)})),cursor:null}}(this,e,t.mint)}async getCompressedTokenAccountBalance(e){const t=await async function(e,t){const n=await eo(e),r=(await io(n)).filter((e=>V(e.compressedAccount.hash).eq(t)));if(0===r.length)throw new Error("No compressed account found");return r[0]}(this,e);return{amount:V(t.parsed.amount)}}async getCompressedTokenBalancesByOwner(e,t){return{items:(await ao(this,e,t.mint)).items.map((e=>({balance:V(e.parsed.amount),mint:e.parsed.mint}))),cursor:null}}async getCompressionSignaturesForAccount(e){throw new Error("getCompressionSignaturesForAccount not implemented in test-rpc")}async getTransactionWithCompressionInfo(e){throw new Error("getCompressedTransaction not implemented in test-rpc")}async getCompressionSignaturesForAddress(e){throw new Error("getSignaturesForAddress3 not implemented")}async getCompressionSignaturesForOwner(e){throw new Error("getSignaturesForOwner not implemented")}async getCompressionSignaturesForTokenOwner(e){throw new Error("getSignaturesForTokenOwner not implemented")}async getIndexerHealth(){return"ok"}async getIndexerSlot(){return 1}async getMultipleNewAddressProofs(e){const t=Ur.default(),n=[];t.init();const r=[];for(let e=0;e<n.length;e++)t.append(V(n[e]));for(let e=0;e<t.elements.length;e++){const n=t.hashElement(this.lightWasm,e);r.push(V(n))}const o=new Pn(this.depth,this.lightWasm,r.map((e=>V(e).toString()))),s=[];for(let n=0;n<e.length;n++){const[r]=t.findLowElement(e[n]);if(!r)throw new Error("Address not found");const i=r.index,a=o.path(i).pathElements.map((e=>V(e))),c=t.get(r.nextIndex).value,u={root:V(o.root()),rootIndex:3,value:e[n],leafLowerRangeValue:r.value,leafHigherRangeValue:c,nextIndex:V(r.nextIndex),merkleProofHashedIndexedElementLeaf:a,indexHashedIndexedElementLeaf:V(r.index),merkleTree:this.addressTreeAddress,nullifierQueue:this.addressQueueAddress};s.push(u)}return s}async getValidityProofDirect(e=[],t=[]){return this.getValidityProof(e,t)}async getValidityProofAndRpcContext(e=[],t=[]){if(t.some((e=>!(e instanceof s.BN))))throw new Error("AddressWithTree is not supported in test-rpc");return{value:await this.getValidityProofV0(e,t),context:{slot:1}}}async getValidityProof(e=[],t=[]){if(t.some((e=>!(e instanceof s.BN))))throw new Error("AddressWithTree is not supported in test-rpc");let n;if(0===e.length&&0===t.length)throw new Error("Empty input. Provide hashes and/or new addresses.");if(e.length>0&&0===t.length){const t=await this.getMultipleCompressedAccountProofs(e),r=wn(t);n={compressedProof:await yn(this.proverEndpoint,"inclusion",r,this.log),roots:t.map((e=>e.root)),rootIndices:t.map((e=>e.rootIndex)),leafIndices:t.map((e=>e.leafIndex)),leaves:t.map((e=>V(e.hash))),merkleTrees:t.map((e=>e.merkleTree)),nullifierQueues:t.map((e=>e.nullifierQueue))}}else if(0===e.length&&t.length>0){const e=await this.getMultipleNewAddressProofs(t),r=bn(e);n={compressedProof:await yn(this.proverEndpoint,"new-address",r,this.log),roots:e.map((e=>e.root)),rootIndices:e.map((e=>3)),leafIndices:e.map((e=>e.indexHashedIndexedElementLeaf.toNumber())),leaves:e.map((e=>V(e.value))),merkleTrees:e.map((e=>e.merkleTree)),nullifierQueues:e.map((e=>e.nullifierQueue))}}else{if(!(e.length>0&&t.length>0))throw new Error("Invalid input");{const r=await this.getMultipleCompressedAccountProofs(e),o=wn(r),s=await this.getMultipleNewAddressProofs(t),i=bn(s);n={compressedProof:await yn(this.proverEndpoint,"combined",[o,i],this.log),roots:r.map((e=>e.root)).concat(s.map((e=>e.root))),rootIndices:r.map((e=>e.rootIndex)).concat(s.map((e=>3))),leafIndices:r.map((e=>e.leafIndex)).concat(s.map((e=>e.indexHashedIndexedElementLeaf.toNumber()))),leaves:r.map((e=>V(e.hash))).concat(s.map((e=>V(e.value)))),merkleTrees:r.map((e=>e.merkleTree)).concat(s.map((e=>e.merkleTree))),nullifierQueues:r.map((e=>e.nullifierQueue)).concat(s.map((e=>e.nullifierQueue)))}}}return n}async getValidityProofV0(e=[],t=[]){return this.getValidityProof(e.map((e=>e.hash)),t.map((e=>e.address)))}}t.ADDRESS_QUEUE_ROLLOVER_FEE=B,t.ADDRESS_TREE_NETWORK_FEE=U,t.ALICE=je,t.AccountCompressionIDL={version:"1.2.0",name:"account_compression",constants:[{name:"CPI_AUTHORITY_PDA_SEED",type:"bytes",value:"[99, 112, 105, 95, 97, 117, 116, 104, 111, 114, 105, 116, 121]"},{name:"GROUP_AUTHORITY_SEED",type:"bytes",value:"[103, 114, 111, 117, 112, 95, 97, 117, 116, 104, 111, 114, 105, 116, 121]"},{name:"STATE_MERKLE_TREE_HEIGHT",type:"u64",value:"26"},{name:"STATE_MERKLE_TREE_CHANGELOG",type:"u64",value:"1400"},{name:"STATE_MERKLE_TREE_ROOTS",type:"u64",value:"2400"},{name:"STATE_MERKLE_TREE_CANOPY_DEPTH",type:"u64",value:"10"},{name:"STATE_NULLIFIER_QUEUE_VALUES",type:"u16",value:"28_807"},{name:"STATE_NULLIFIER_QUEUE_SEQUENCE_THRESHOLD",type:"u64",value:"2400"},{name:"ADDRESS_MERKLE_TREE_HEIGHT",type:"u64",value:"26"},{name:"ADDRESS_MERKLE_TREE_CHANGELOG",type:"u64",value:"1400"},{name:"ADDRESS_MERKLE_TREE_ROOTS",type:"u64",value:"2400"},{name:"ADDRESS_MERKLE_TREE_CANOPY_DEPTH",type:"u64",value:"10"},{name:"ADDRESS_MERKLE_TREE_INDEXED_CHANGELOG",type:"u64",value:"1400"},{name:"ADDRESS_QUEUE_VALUES",type:"u16",value:"28_807"},{name:"ADDRESS_QUEUE_SEQUENCE_THRESHOLD",type:"u64",value:"2400"},{name:"NOOP_PUBKEY",type:{array:["u8",32]},value:"[11 , 188 , 15 , 192 , 187 , 71 , 202 , 47 , 116 , 196 , 17 , 46 , 148 , 171 , 19 , 207 , 163 , 198 , 52 , 229 , 220 , 23 , 234 , 203 , 3 , 205 , 26 , 35 , 205 , 126 , 120 , 124 ,]"}],instructions:[{name:"initializeAddressMerkleTreeAndQueue",accounts:[{name:"authority",isMut:!0,isSigner:!0},{name:"merkleTree",isMut:!0,isSigner:!1},{name:"queue",isMut:!0,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1,isOptional:!0}],args:[{name:"index",type:"u64"},{name:"programOwner",type:{option:"publicKey"}},{name:"forester",type:{option:"publicKey"}},{name:"addressMerkleTreeConfig",type:{defined:"AddressMerkleTreeConfig"}},{name:"addressQueueConfig",type:{defined:"AddressQueueConfig"}}]},{name:"insertAddresses",accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["Fee payer pays rollover fee."]},{name:"authority",isMut:!1,isSigner:!0},{name:"registeredProgramPda",isMut:!1,isSigner:!1,isOptional:!0},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"addresses",type:{vec:{array:["u8",32]}}}]},{name:"updateAddressMerkleTree",docs:["Updates the address Merkle tree with a new address."],accounts:[{name:"authority",isMut:!1,isSigner:!0},{name:"registeredProgramPda",isMut:!1,isSigner:!1,isOptional:!0},{name:"queue",isMut:!0,isSigner:!1},{name:"merkleTree",isMut:!0,isSigner:!1},{name:"logWrapper",isMut:!1,isSigner:!1}],args:[{name:"changelogIndex",type:"u16"},{name:"indexedChangelogIndex",type:"u16"},{name:"value",type:"u16"},{name:"lowAddressIndex",type:"u64"},{name:"lowAddressValue",type:{array:["u8",32]}},{name:"lowAddressNextIndex",type:"u64"},{name:"lowAddressNextValue",type:{array:["u8",32]}},{name:"lowAddressProof",type:{array:[{array:["u8",32]},16]}}]},{name:"rolloverAddressMerkleTreeAndQueue",accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["Signer used to receive rollover accounts rentexemption reimbursement."]},{name:"authority",isMut:!1,isSigner:!0},{name:"registeredProgramPda",isMut:!1,isSigner:!1,isOptional:!0},{name:"newAddressMerkleTree",isMut:!0,isSigner:!1},{name:"newQueue",isMut:!0,isSigner:!1},{name:"oldAddressMerkleTree",isMut:!0,isSigner:!1},{name:"oldQueue",isMut:!0,isSigner:!1}],args:[]},{name:"initializeGroupAuthority",docs:["initialize group (a group can be used to give multiple programs access","to the same Merkle trees by registering the programs to the group)"],accounts:[{name:"authority",isMut:!0,isSigner:!0},{name:"seed",isMut:!1,isSigner:!0,docs:["Seed public key used to derive the group authority."]},{name:"groupAuthority",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"authority",type:"publicKey"}]},{name:"updateGroupAuthority",accounts:[{name:"authority",isMut:!1,isSigner:!0},{name:"groupAuthority",isMut:!0,isSigner:!1}],args:[{name:"authority",type:"publicKey"}]},{name:"registerProgramToGroup",accounts:[{name:"authority",isMut:!0,isSigner:!0},{name:"programToBeRegistered",isMut:!1,isSigner:!0},{name:"registeredProgramPda",isMut:!0,isSigner:!1},{name:"groupAuthorityPda",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"deregisterProgram",accounts:[{name:"authority",isMut:!0,isSigner:!0},{name:"registeredProgramPda",isMut:!0,isSigner:!1},{name:"groupAuthorityPda",isMut:!1,isSigner:!1},{name:"closeRecipient",isMut:!0,isSigner:!1}],args:[]},{name:"initializeStateMerkleTreeAndNullifierQueue",docs:["Initializes a new Merkle tree from config bytes.","Index is an optional identifier and not checked by the program."],accounts:[{name:"authority",isMut:!0,isSigner:!0},{name:"merkleTree",isMut:!0,isSigner:!1},{name:"nullifierQueue",isMut:!0,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1,isOptional:!0}],args:[{name:"index",type:"u64"},{name:"programOwner",type:{option:"publicKey"}},{name:"forester",type:{option:"publicKey"}},{name:"stateMerkleTreeConfig",type:{defined:"StateMerkleTreeConfig"}},{name:"nullifierQueueConfig",type:{defined:"NullifierQueueConfig"}},{name:"additionalBytes",type:"u64"}]},{name:"appendLeavesToMerkleTrees",accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["Fee payer pays rollover fee."]},{name:"authority",isMut:!1,isSigner:!0,docs:["Checked whether instruction is accessed by a registered program or owner = authority."]},{name:"registeredProgramPda",isMut:!1,isSigner:!1,isOptional:!0,docs:["Some assumes that the Merkle trees are accessed by a registered program.","None assumes that the Merkle trees are accessed by its owner."]},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"leaves",type:{vec:{defined:"(u8,[u8;32])"}}}]},{name:"nullifyLeaves",accounts:[{name:"authority",isMut:!1,isSigner:!0},{name:"registeredProgramPda",isMut:!1,isSigner:!1,isOptional:!0},{name:"logWrapper",isMut:!1,isSigner:!1},{name:"merkleTree",isMut:!0,isSigner:!1},{name:"nullifierQueue",isMut:!0,isSigner:!1}],args:[{name:"changeLogIndices",type:{vec:"u64"}},{name:"leavesQueueIndices",type:{vec:"u16"}},{name:"leafIndices",type:{vec:"u64"}},{name:"proofs",type:{vec:{vec:{array:["u8",32]}}}}]},{name:"insertIntoNullifierQueues",accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["Fee payer pays rollover fee."]},{name:"authority",isMut:!1,isSigner:!0},{name:"registeredProgramPda",isMut:!1,isSigner:!1,isOptional:!0},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"nullifiers",type:{vec:{array:["u8",32]}}}]},{name:"rolloverStateMerkleTreeAndNullifierQueue",accounts:[{name:"feePayer",isMut:!0,isSigner:!0,docs:["Signer used to receive rollover accounts rentexemption reimbursement."]},{name:"authority",isMut:!1,isSigner:!0},{name:"registeredProgramPda",isMut:!1,isSigner:!1,isOptional:!0},{name:"newStateMerkleTree",isMut:!0,isSigner:!1},{name:"newNullifierQueue",isMut:!0,isSigner:!1},{name:"oldStateMerkleTree",isMut:!0,isSigner:!1},{name:"oldNullifierQueue",isMut:!0,isSigner:!1}],args:[]}],accounts:[{name:"registeredProgram",type:{kind:"struct",fields:[{name:"registeredProgramId",type:"publicKey"},{name:"groupAuthorityPda",type:"publicKey"}]}},{name:"accessMetadata",type:{kind:"struct",fields:[{name:"owner",docs:["Owner of the Merkle tree."],type:"publicKey"},{name:"programOwner",docs:["Program owner of the Merkle tree. This will be used for program owned Merkle trees."],type:"publicKey"},{name:"forester",docs:["Optional privileged forester pubkey, can be set for custom Merkle trees","without a network fee. Merkle trees without network fees are not","forested by light foresters. The variable is not used in the account","compression program but the registry program. The registry program","implements access control to prevent contention during forester. The","forester pubkey specified in this struct can bypass contention checks."],type:"publicKey"}]}},{name:"addressMerkleTreeAccount",type:{kind:"struct",fields:[{name:"metadata",type:{defined:"MerkleTreeMetadata"}}]}},{name:"groupAuthority",type:{kind:"struct",fields:[{name:"authority",type:"publicKey"},{name:"seed",type:"publicKey"}]}},{name:"merkleTreeMetadata",type:{kind:"struct",fields:[{name:"accessMetadata",type:{defined:"AccessMetadata"}},{name:"rolloverMetadata",type:{defined:"RolloverMetadata"}},{name:"associatedQueue",type:"publicKey"},{name:"nextMerkleTree",type:"publicKey"}]}},{name:"stateMerkleTreeAccount",docs:["Concurrent state Merkle tree used for public compressed transactions."],type:{kind:"struct",fields:[{name:"metadata",type:{defined:"MerkleTreeMetadata"}}]}},{name:"queueMetadata",type:{kind:"struct",fields:[{name:"accessMetadata",type:{defined:"AccessMetadata"}},{name:"rolloverMetadata",type:{defined:"RolloverMetadata"}},{name:"associatedMerkleTree",type:"publicKey"},{name:"nextQueue",type:"publicKey"},{name:"queueType",type:"u64"}]}},{name:"queueAccount",type:{kind:"struct",fields:[{name:"metadata",type:{defined:"QueueMetadata"}}]}},{name:"rolloverMetadata",type:{kind:"struct",fields:[{name:"index",docs:["Unique index."],type:"u64"},{name:"rolloverFee",docs:["This fee is used for rent for the next account.","It accumulates in the account so that once the corresponding Merkle tree account is full it can be rolled over"],type:"u64"},{name:"rolloverThreshold",docs:["The threshold in percentage points when the account should be rolled over (95 corresponds to 95% filled)."],type:"u64"},{name:"networkFee",docs:["Tip for maintaining the account."],type:"u64"},{name:"rolledoverSlot",docs:["The slot when the account was rolled over, a rolled over account should not be written to."],type:"u64"},{name:"closeThreshold",docs:["If current slot is greater than rolledover_slot + close_threshold and","the account is empty it can be closed. No 'close' functionality has been","implemented yet."],type:"u64"},{name:"additionalBytes",docs:["Placeholder for bytes of additional accounts which are tied to the","Merkle trees operation and need to be rolled over as well."],type:"u64"}]}}],types:[{name:"AddressMerkleTreeConfig",type:{kind:"struct",fields:[{name:"height",type:"u32"},{name:"changelogSize",type:"u64"},{name:"rootsSize",type:"u64"},{name:"canopyDepth",type:"u64"},{name:"addressChangelogSize",type:"u64"},{name:"networkFee",type:{option:"u64"}},{name:"rolloverThreshold",type:{option:"u64"}},{name:"closeThreshold",type:{option:"u64"}}]}},{name:"StateMerkleTreeConfig",type:{kind:"struct",fields:[{name:"height",type:"u32"},{name:"changelogSize",type:"u64"},{name:"rootsSize",type:"u64"},{name:"canopyDepth",type:"u64"},{name:"networkFee",type:{option:"u64"}},{name:"rolloverThreshold",type:{option:"u64"}},{name:"closeThreshold",type:{option:"u64"}}]}},{name:"NullifierQueueConfig",type:{kind:"struct",fields:[{name:"capacity",type:"u16"},{name:"sequenceThreshold",type:"u64"},{name:"networkFee",type:{option:"u64"}}]}},{name:"QueueType",type:{kind:"enum",variants:[{name:"NullifierQueue"},{name:"AddressQueue"}]}},{name:"AddressQueueConfig",type:{kind:"alias",value:{defined:"NullifierQueueConfig"}}}],errors:[{code:6e3,name:"IntegerOverflow",msg:"Integer overflow"},{code:6001,name:"InvalidAuthority",msg:"InvalidAuthority"},{code:6002,name:"NumberOfLeavesMismatch",msg:"Leaves <> remaining accounts mismatch. The number of remaining accounts must match the number of leaves."},{code:6003,name:"InvalidNoopPubkey",msg:"Provided noop program public key is invalid"},{code:6004,name:"NumberOfChangeLogIndicesMismatch",msg:"Number of change log indices mismatch"},{code:6005,name:"NumberOfIndicesMismatch",msg:"Number of indices mismatch"},{code:6006,name:"NumberOfProofsMismatch",msg:"NumberOfProofsMismatch"},{code:6007,name:"InvalidMerkleProof",msg:"InvalidMerkleProof"},{code:6008,name:"LeafNotFound",msg:"Could not find the leaf in the queue"},{code:6009,name:"MerkleTreeAndQueueNotAssociated",msg:"MerkleTreeAndQueueNotAssociated"},{code:6010,name:"MerkleTreeAlreadyRolledOver",msg:"MerkleTreeAlreadyRolledOver"},{code:6011,name:"NotReadyForRollover",msg:"NotReadyForRollover"},{code:6012,name:"RolloverNotConfigured",msg:"RolloverNotConfigured"},{code:6013,name:"NotAllLeavesProcessed",msg:"NotAllLeavesProcessed"},{code:6014,name:"InvalidQueueType",msg:"InvalidQueueType"},{code:6015,name:"InputElementsEmpty",msg:"InputElementsEmpty"},{code:6016,name:"NoLeavesForMerkleTree",msg:"NoLeavesForMerkleTree"},{code:6017,name:"InvalidAccountSize",msg:"InvalidAccountSize"},{code:6018,name:"InsufficientRolloverFee",msg:"InsufficientRolloverFee"},{code:6019,name:"UnsupportedHeight",msg:"Unsupported Merkle tree height"},{code:6020,name:"UnsupportedCanopyDepth",msg:"Unsupported canopy depth"},{code:6021,name:"InvalidSequenceThreshold",msg:"Invalid sequence threshold"},{code:6022,name:"UnsupportedCloseThreshold",msg:"Unsupported close threshold"},{code:6023,name:"InvalidAccountBalance",msg:"InvalidAccountBalance"},{code:6024,name:"UnsupportedAdditionalBytes"},{code:6025,name:"InvalidGroup"},{code:6026,name:"ProofLengthMismatch"}]},t.AccountProofResult=un,t.BOB=Qe,t.BalanceResult=on,t.CHARLIE=Ge,t.CompressedAccountResult=Vt,t.CompressedAccountsByOwnerResult=jt,t.CompressedTokenAccountResult=Ht,t.CompressedTokenAccountsByOwnerOrDelegateResult=Qt,t.CompressedTransactionResult=pn,t.CreateUtxoError=class extends lt{},t.DAVE=Ye,t.DEFAULT_MERKLE_TREE_HEIGHT=O,t.DEFAULT_MERKLE_TREE_ROOTS=2800,t.DEFAULT_ZERO="0",t.FIELD_SIZE=b,t.HIGHEST_ADDRESS_PLUS_ONE=A,t.HashError=class extends lt{},t.HealthResult=Yt,t.IndexedArray=Ur,t.IndexedElement=Br,t.IndexedElementBundle=Lr,t.LatestNonVotingSignaturesResult=Xt,t.LatestNonVotingSignaturesResultPaginated=Jt,t.LightCompressedTokenIDL=nt,t.LightRegistryIDL={version:"1.2.0",name:"light_registry",constants:[{name:"FORESTER_SEED",type:"bytes",value:"[102, 111, 114, 101, 115, 116, 101, 114]"},{name:"FORESTER_EPOCH_SEED",type:"bytes",value:"[102, 111, 114, 101, 115, 116, 101, 114, 95, 101, 112, 111, 99, 104]"},{name:"PROTOCOL_CONFIG_PDA_SEED",type:"bytes",value:"[97, 117, 116, 104, 111, 114, 105, 116, 121]"}],instructions:[{name:"initializeProtocolConfig",docs:["Initializes the protocol config pda. Can only be called once by the","program account keypair."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0},{name:"authority",isMut:!1,isSigner:!0},{name:"protocolConfigPda",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"selfProgram",isMut:!1,isSigner:!1}],args:[{name:"bump",type:"u8"},{name:"protocolConfig",type:{defined:"ProtocolConfig"}}]},{name:"updateProtocolConfig",accounts:[{name:"feePayer",isMut:!1,isSigner:!0},{name:"authority",isMut:!1,isSigner:!0},{name:"protocolConfigPda",isMut:!0,isSigner:!1},{name:"newAuthority",isMut:!1,isSigner:!0,isOptional:!0}],args:[{name:"protocolConfig",type:{option:{defined:"ProtocolConfig"}}}]},{name:"registerSystemProgram",accounts:[{name:"authority",isMut:!0,isSigner:!0},{name:"protocolConfigPda",isMut:!0,isSigner:!1},{name:"cpiAuthority",isMut:!0,isSigner:!1},{name:"groupPda",isMut:!0,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!0,isSigner:!1},{name:"programToBeRegistered",isMut:!1,isSigner:!0,docs:["- is signer so that only the program deployer can register a program."]}],args:[{name:"bump",type:"u8"}]},{name:"deregisterSystemProgram",accounts:[{name:"authority",isMut:!0,isSigner:!0},{name:"protocolConfigPda",isMut:!0,isSigner:!1},{name:"cpiAuthority",isMut:!0,isSigner:!1},{name:"groupPda",isMut:!0,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!0,isSigner:!1}],args:[{name:"bump",type:"u8"}]},{name:"registerForester",accounts:[{name:"feePayer",isMut:!0,isSigner:!0},{name:"authority",isMut:!1,isSigner:!0},{name:"protocolConfigPda",isMut:!1,isSigner:!1},{name:"foresterPda",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"bump",type:"u8"},{name:"authority",type:"publicKey"},{name:"config",type:{defined:"ForesterConfig"}},{name:"weight",type:{option:"u64"}}]},{name:"updateForesterPda",accounts:[{name:"authority",isMut:!1,isSigner:!0},{name:"foresterPda",isMut:!0,isSigner:!1},{name:"newAuthority",isMut:!1,isSigner:!0,isOptional:!0}],args:[{name:"config",type:{option:{defined:"ForesterConfig"}}}]},{name:"updateForesterPdaWeight",accounts:[{name:"authority",isMut:!1,isSigner:!0},{name:"protocolConfigPda",isMut:!1,isSigner:!1},{name:"foresterPda",isMut:!0,isSigner:!1}],args:[{name:"newWeight",type:"u64"}]},{name:"registerForesterEpoch",docs:["Registers the forester for the epoch.","1. Only the forester can register herself for the epoch.","2. Protocol config is copied.","3. Epoch account is created if needed."],accounts:[{name:"feePayer",isMut:!0,isSigner:!0},{name:"authority",isMut:!1,isSigner:!0},{name:"foresterPda",isMut:!1,isSigner:!1},{name:"foresterEpochPda",isMut:!0,isSigner:!1,docs:["Instruction checks that current_epoch is the the current epoch and that","the epoch is in registration phase."]},{name:"protocolConfig",isMut:!1,isSigner:!1},{name:"epochPda",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"epoch",type:"u64"}]},{name:"finalizeRegistration",docs:["This transaction can be included as additional instruction in the first","work instructions during the active phase.","Registration Period must be over."],accounts:[{name:"authority",isMut:!1,isSigner:!0},{name:"foresterEpochPda",isMut:!0,isSigner:!1},{name:"epochPda",isMut:!1,isSigner:!1}],args:[]},{name:"reportWork",accounts:[{name:"authority",isMut:!1,isSigner:!0},{name:"foresterEpochPda",isMut:!0,isSigner:!1},{name:"epochPda",isMut:!0,isSigner:!1}],args:[]},{name:"initializeAddressMerkleTree",accounts:[{name:"authority",isMut:!0,isSigner:!0,docs:["Anyone can create new trees just the fees cannot be set arbitrarily."]},{name:"merkleTree",isMut:!0,isSigner:!1},{name:"queue",isMut:!0,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"cpiAuthority",isMut:!0,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"protocolConfigPda",isMut:!1,isSigner:!1},{name:"cpiContextAccount",isMut:!1,isSigner:!1,isOptional:!0},{name:"lightSystemProgram",isMut:!1,isSigner:!1,isOptional:!0}],args:[{name:"bump",type:"u8"},{name:"programOwner",type:{option:"publicKey"}},{name:"forester",type:{option:"publicKey"}},{name:"merkleTreeConfig",type:{defined:"AddressMerkleTreeConfig"}},{name:"queueConfig",type:{defined:"AddressQueueConfig"}}]},{name:"initializeStateMerkleTree",accounts:[{name:"authority",isMut:!0,isSigner:!0,docs:["Anyone can create new trees just the fees cannot be set arbitrarily."]},{name:"merkleTree",isMut:!0,isSigner:!1},{name:"queue",isMut:!0,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"cpiAuthority",isMut:!0,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"protocolConfigPda",isMut:!1,isSigner:!1},{name:"cpiContextAccount",isMut:!1,isSigner:!1,isOptional:!0},{name:"lightSystemProgram",isMut:!1,isSigner:!1,isOptional:!0}],args:[{name:"bump",type:"u8"},{name:"programOwner",type:{option:"publicKey"}},{name:"forester",type:{option:"publicKey"}},{name:"merkleTreeConfig",type:{defined:"StateMerkleTreeConfig"}},{name:"queueConfig",type:{defined:"NullifierQueueConfig"}}]},{name:"nullify",accounts:[{name:"registeredForesterPda",isMut:!0,isSigner:!1,isOptional:!0},{name:"authority",isMut:!1,isSigner:!0},{name:"cpiAuthority",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"logWrapper",isMut:!1,isSigner:!1},{name:"merkleTree",isMut:!0,isSigner:!1},{name:"nullifierQueue",isMut:!0,isSigner:!1}],args:[{name:"bump",type:"u8"},{name:"changeLogIndices",type:{vec:"u64"}},{name:"leavesQueueIndices",type:{vec:"u16"}},{name:"indices",type:{vec:"u64"}},{name:"proofs",type:{vec:{vec:{array:["u8",32]}}}}]},{name:"updateAddressMerkleTree",accounts:[{name:"registeredForesterPda",isMut:!0,isSigner:!1,isOptional:!0},{name:"authority",isMut:!1,isSigner:!0},{name:"cpiAuthority",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"queue",isMut:!0,isSigner:!1},{name:"merkleTree",isMut:!0,isSigner:!1},{name:"logWrapper",isMut:!1,isSigner:!1}],args:[{name:"bump",type:"u8"},{name:"changelogIndex",type:"u16"},{name:"indexedChangelogIndex",type:"u16"},{name:"value",type:"u16"},{name:"lowAddressIndex",type:"u64"},{name:"lowAddressValue",type:{array:["u8",32]}},{name:"lowAddressNextIndex",type:"u64"},{name:"lowAddressNextValue",type:{array:["u8",32]}},{name:"lowAddressProof",type:{array:[{array:["u8",32]},16]}}]},{name:"rolloverAddressMerkleTreeAndQueue",accounts:[{name:"registeredForesterPda",isMut:!0,isSigner:!1,isOptional:!0},{name:"authority",isMut:!0,isSigner:!0},{name:"cpiAuthority",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"newMerkleTree",isMut:!0,isSigner:!1},{name:"newQueue",isMut:!0,isSigner:!1},{name:"oldMerkleTree",isMut:!0,isSigner:!1},{name:"oldQueue",isMut:!0,isSigner:!1}],args:[{name:"bump",type:"u8"}]},{name:"rolloverStateMerkleTreeAndQueue",accounts:[{name:"registeredForesterPda",isMut:!0,isSigner:!1,isOptional:!0},{name:"authority",isMut:!0,isSigner:!0},{name:"cpiAuthority",isMut:!1,isSigner:!1},{name:"registeredProgramPda",isMut:!1,isSigner:!1},{name:"accountCompressionProgram",isMut:!1,isSigner:!1},{name:"newMerkleTree",isMut:!0,isSigner:!1},{name:"newQueue",isMut:!0,isSigner:!1},{name:"oldMerkleTree",isMut:!0,isSigner:!1},{name:"oldQueue",isMut:!0,isSigner:!1},{name:"cpiContextAccount",isMut:!1,isSigner:!1},{name:"lightSystemProgram",isMut:!1,isSigner:!1},{name:"protocolConfigPda",isMut:!1,isSigner:!1}],args:[{name:"bump",type:"u8"}]}],accounts:[{name:"epochPda",docs:["Is used for tallying and rewards calculation"],type:{kind:"struct",fields:[{name:"epoch",type:"u64"},{name:"protocolConfig",type:{defined:"ProtocolConfig"}},{name:"totalWork",type:"u64"},{name:"registeredWeight",type:"u64"}]}},{name:"foresterEpochPda",type:{kind:"struct",fields:[{name:"authority",type:"publicKey"},{name:"config",type:{defined:"ForesterConfig"}},{name:"epoch",type:"u64"},{name:"weight",type:"u64"},{name:"workCounter",type:"u64"},{name:"hasReportedWork",docs:["Work can be reported in an extra round to earn extra performance based","rewards."],type:"bool"},{name:"foresterIndex",docs:["Start index of the range that determines when the forester is eligible to perform work.","End index is forester_start_index + weight"],type:"u64"},{name:"epochActivePhaseStartSlot",type:"u64"},{name:"totalEpochWeight",docs:["Total epoch weight is registered weight of the epoch account after","registration is concluded and active epoch period starts."],type:{option:"u64"}},{name:"protocolConfig",type:{defined:"ProtocolConfig"}},{name:"finalizeCounter",docs:["Incremented every time finalize registration is called."],type:"u64"}]}},{name:"protocolConfigPda",type:{kind:"struct",fields:[{name:"authority",type:"publicKey"},{name:"bump",type:"u8"},{name:"config",type:{defined:"ProtocolConfig"}}]}},{name:"foresterPda",type:{kind:"struct",fields:[{name:"authority",type:"publicKey"},{name:"config",type:{defined:"ForesterConfig"}},{name:"activeWeight",type:"u64"},{name:"pendingWeight",docs:["Pending weight which will get active once the next epoch starts."],type:"u64"},{name:"currentEpoch",type:"u64"},{name:"lastCompressedForesterEpochPdaHash",docs:["Link to previous compressed forester epoch account hash."],type:{array:["u8",32]}},{name:"lastRegisteredEpoch",type:"u64"}]}}],types:[{name:"ProtocolConfig",docs:["Epoch Phases:","1. Registration","2. Active","3. Report Work","4. Post (Epoch has ended, and rewards can be claimed.)","- There is always an active phase in progress, registration and report work","phases run in parallel to a currently active phase."],type:{kind:"struct",fields:[{name:"genesisSlot",docs:["Solana slot when the protocol starts operating."],type:"u64"},{name:"minWeight",docs:["Minimum weight required for a forester to register to an epoch."],type:"u64"},{name:"slotLength",docs:["Light protocol slot length."],type:"u64"},{name:"registrationPhaseLength",docs:["Foresters can register for this phase."],type:"u64"},{name:"activePhaseLength",docs:["Foresters can perform work in this phase."],type:"u64"},{name:"reportWorkPhaseLength",docs:["Foresters can report work to receive performance based rewards in this","phase."],type:"u64"},{name:"networkFee",type:"u64"},{name:"cpiContextSize",type:"u64"},{name:"finalizeCounterLimit",type:"u64"},{name:"placeHolder",docs:["Placeholder for future protocol updates."],type:"publicKey"},{name:"placeHolderA",type:"u64"},{name:"placeHolderB",type:"u64"},{name:"placeHolderC",type:"u64"},{name:"placeHolderD",type:"u64"},{name:"placeHolderE",type:"u64"},{name:"placeHolderF",type:"u64"}]}},{name:"ForesterConfig",type:{kind:"struct",fields:[{name:"fee",docs:["Fee in percentage points."],type:"u64"}]}},{name:"EpochState",type:{kind:"enum",variants:[{name:"Registration"},{name:"Active"},{name:"ReportWork"},{name:"Post"},{name:"Pre"}]}}],errors:[{code:6e3,name:"InvalidForester",msg:"InvalidForester"},{code:6001,name:"NotInReportWorkPhase"},{code:6002,name:"StakeAccountAlreadySynced"},{code:6003,name:"EpochEnded"},{code:6004,name:"ForesterNotEligible"},{code:6005,name:"NotInRegistrationPeriod"},{code:6006,name:"WeightInsuffient"},{code:6007,name:"ForesterAlreadyRegistered"},{code:6008,name:"InvalidEpochAccount"},{code:6009,name:"InvalidEpoch"},{code:6010,name:"EpochStillInProgress"},{code:6011,name:"NotInActivePhase"},{code:6012,name:"ForesterAlreadyReportedWork"},{code:6013,name:"InvalidNetworkFee"},{code:6014,name:"FinalizeCounterExceeded"},{code:6015,name:"CpiContextAccountMissing"},{code:6016,name:"ArithmeticUnderflow"},{code:6017,name:"RegistrationNotFinalized"},{code:6018,name:"CpiContextAccountInvalidDataLen"},{code:6019,name:"InvalidConfigUpdate"},{code:6020,name:"InvalidSigner"},{code:6021,name:"GetLatestRegisterEpochFailed"},{code:6022,name:"GetCurrentActiveEpochFailed"},{code:6023,name:"ForesterUndefined"},{code:6024,name:"ForesterDefined"}]},t.LightSystemIDL=u,t.LightSystemProgram=et,t.LookupTableError=class extends lt{},t.MerkeProofResult=Zt,t.MerkleTree=Pn,t.MerkleTreeError=class extends lt{},t.MultipleCompressedAccountsResult=qt,t.MultipleMerkleProofsResult=rn,t.NativeBalanceResult=sn,t.NewAddressProofResult=en,t.ProofError=class extends lt{},t.Rpc=kn,t.RpcError=class extends lt{},t.STATE_MERKLE_TREE_NETWORK_FEE=L,t.STATE_MERKLE_TREE_ROLLOVER_FEE=D,t.SelectInUtxosError=class extends lt{},t.SignatureListResult=dn,t.SignatureListWithCursorResult=ln,t.SlotResult=Gt,t.TRANSACTION_MERKLE_TREE_ROLLOVER_THRESHOLD=N,t.TestRpc=co,t.TokenBalanceListResult=cn,t.TokenBalanceResult=an,t.TokenDataResult=Wt,t.UTXO_MERGE_MAXIMUM=10,t.UTXO_MERGE_THRESHOLD=20,t.UtilsError=class extends lt{},t.UtxoError=class extends lt{},t.ValidityProofResult=nn,t.accountCompressionProgram=P,t.addressQueue=_,t.addressTree=x,t.airdropSol=async function({connection:e,lamports:t,recipientPublicKey:n}){const r=await e.requestAirdrop(n,t);return await Le(e,r),r},t.bn=V,t.bufToDecStr=e=>W(e).toString(),t.buildAndSignTx=He,t.buildTx=$e,t.byteArrayToKeypair=function(e){return o.Keypair.fromSecretKey(Uint8Array.from(e))},t.checkValidityProofShape=e=>{if(32!==e.a.length||64!==e.b.length||32!==e.c.length)throw new Error("ValidityProof has invalid shape")},t.compress=async function(e,t,n,r,s,i){const{blockhash:a}=await e.getLatestBlockhash(),c=await et.compress({payer:t.publicKey,toAddress:r,lamports:n,outputStateTree:s}),u=He([o.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),c],t,a,[]);return await Ve(e,u,i)},t.confirmConfig={commitment:"confirmed",preflightCommitment:"confirmed"},t.confirmTransaction=Le,t.confirmTx=We,t.convertMerkleProofsWithContextToHex=wn,t.convertNonInclusionMerkleProofInputsToHex=bn,t.createAccount=async function(e,t,n,r,s,i,a,c){const{blockhash:u}=await e.getLatestBlockhash();s=null!=s?s:C().addressTree,i=null!=i?i:C().addressQueue;const d=Ne(n,r),l=De(d,s),p=await e.getValidityProofV0(void 0,[{address:V(l.toBytes()),tree:s,queue:i}]),m={seed:d,addressMerkleTreeRootIndex:p.rootIndices[0],addressMerkleTreePubkey:p.merkleTrees[0],addressQueuePubkey:p.nullifierQueues[0]},h=await et.createAccount({payer:t.publicKey,newAddressParams:m,newAddress:Array.from(l.toBytes()),recentValidityProof:p.compressedProof,programId:r,outputStateTree:a}),f=He([o.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),h],t,u,[]);return await Ve(e,f,c)},t.createAccountWithLamports=async function(e,t,n,r,s,i,a,c,u){r=V(r);const d=await e.getCompressedAccountsByOwner(t.publicKey),[l]=tt(d.items,r),{blockhash:p}=await e.getLatestBlockhash();i=null!=i?i:C().addressTree,a=null!=a?a:C().addressQueue;const m=Ne(n,s),h=De(m,i),f=await e.getValidityProof(l.map((e=>V(e.hash))),[V(h.toBytes())]),g={seed:m,addressMerkleTreeRootIndex:f.rootIndices[f.rootIndices.length-1],addressMerkleTreePubkey:f.merkleTrees[f.merkleTrees.length-1],addressQueuePubkey:f.nullifierQueues[f.nullifierQueues.length-1]},y=await et.createAccount({payer:t.publicKey,newAddressParams:g,newAddress:Array.from(h.toBytes()),recentValidityProof:f.compressedProof,inputCompressedAccounts:l,inputStateRootIndices:f.rootIndices,programId:s,outputStateTree:c}),w=He([o.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),y],t,p,[]);return await Ve(e,w,u)},t.createBN254=W,t.createCompressedAccount=q,t.createCompressedAccountWithMerkleContext=j,t.createMerkleContext=Q,t.createRpc=function(e="http://127.0.0.1:8899",t="http://127.0.0.1:8784",n="http://127.0.0.1:3001",r){const o="string"==typeof e?e:e.rpcEndpoint;return new kn(o,t,n,r)},t.createRpcResult=Ft,t.decompress=async function(e,t,n,r,s,i){const a=(await e.getCompressedAccountsByOwner(t.publicKey)).items;n=V(n);const c=Je(a);if(n.gt(c))throw new Error(`Not enough compressed lamports. Expected ${n}, got ${c}`);const u=await e.getValidityProof(a.map((e=>V(e.hash)))),{blockhash:d}=await e.getLatestBlockhash(),l=await et.decompress({payer:t.publicKey,toAddress:r,outputStateTree:s,inputCompressedAccounts:a,recentValidityProof:u.compressedProof,recentInputStateRootIndices:u.rootIndices,lamports:n}),p=He([o.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),l],t,d,[]);return await Ve(e,p,i)},t.dedupeSigner=function(e,t){return t.includes(e)?t.filter((t=>t.publicKey.toString()!==e.publicKey.toString())):t},t.defaultStaticAccounts=()=>[new o.PublicKey(E()),new o.PublicKey(S),new o.PublicKey(P),new o.PublicKey(v())],t.defaultStaticAccountsStruct=T,t.defaultTestStateTreeAccounts=C,t.deriveAddress=De,t.deriveAddressSeed=Ne,t.encodeBN254toBase58=H,t.getAccountCompressionAuthority=v,t.getConnection=function(){return new o.Connection("http://127.0.0.1:8899","confirmed")},t.getIndexOrAdd=Ce,t.getParsedEvents=eo,t.getRegisteredProgramPda=E,t.getTestKeypair=Xe,t.getTestRpc=async function(e,t="http://127.0.0.1:8899",n="http://127.0.0.1:8784",r="http://127.0.0.1:3001",o,s,i,a=!1){const c=C();return new co(t,e,n,r,void 0,{merkleTreeAddress:o||c.merkleTree,nullifierQueueAddress:s||c.nullifierQueue,depth:i||c.merkleTreeHeight,log:a})},t.hashToBn254FieldSizeBe=Ee,t.hashvToBn254FieldSizeBe=ve,t.jsonRpcResult=zt,t.jsonRpcResultAndContext=$t,t.lightProgram=k,t.merkletreePubkey=I,t.negateAndCompressProof=Re,t.newAccountWithLamports=async function(e,t=1e9,n=void 0){(void 0===n||n>255)&&(n=256);const r=Xe(n),o=await e.requestAirdrop(r.publicKey,t);return await We(e,o),r},t.noopProgram=S,t.nullifierQueuePubkey=M,t.packCompressedAccounts=xe,t.packNewAddressParams=Be,t.padOutputStateMerkleTrees=Me,t.parseAccountData=mn,t.parseEvents=to,t.parsePublicTransactionEventWithIdl=no,t.pipe=function(e,...t){return n=>t.reduce(((e,t)=>t(e)),e(n))},t.placeholderValidityProof=()=>({a:Array.from({length:32},((e,t)=>t+1)),b:Array.from({length:64},((e,t)=>t+1)),c:Array.from({length:32},((e,t)=>t+1))}),t.proofFromJsonStruct=Ue,t.proverRequest=yn,t.pushUniqueItems=function(e,t){e.forEach((e=>{t.includes(e)||t.push(e)}))},t.rpcRequest=gn,t.selectMinCompressedSolAccountsForTransfer=tt,t.sendAndConfirmTx=Ve,t.sleep=function(e){return new Promise((t=>setTimeout(t,e)))},t.sumUpLamports=Je,t.toAccountMetas=Ie,t.toArray=ke,t.toCamelCase=Te,t.toHex=Se,t.toUnixTimestamp=e=>new Date(e).getTime(),t.transfer=async function(e,t,n,r,i,a,c){var u;let d=V(0);const l=[];let p;for(n=V(n);d.lt(n);){const t={filters:void 0,dataSlice:void 0,cursor:p,limit:new s.BN(1e3)},o=await e.getCompressedAccountsByOwner(r.publicKey,t);for(const e of o.items)e.lamports.gt(new s.BN(0))&&(l.push(e),d=d.add(e.lamports));if(p=null!==(u=o.cursor)&&void 0!==u?u:void 0,o.items.length<1e3||d.gte(n))break}if(d.lt(n))throw new Error(`Not enough balance for transfer. Required: ${n.toString()}, available: ${d.toString()}`);const[m]=tt(l,n),h=await e.getValidityProof(m.map((e=>V(e.hash)))),f=await et.transfer({payer:t.publicKey,inputCompressedAccounts:m,toAddress:i,lamports:n,recentInputStateRootIndices:h.rootIndices,recentValidityProof:h.compressedProof,outputStateTrees:a}),{blockhash:g}=await e.getLatestBlockhash(),y=He([o.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),f],t,g);return await Ve(e,y,c)},t.useWallet=w,t.validateSameOwner=Oe,t.validateSufficientBalance=_e}}]);