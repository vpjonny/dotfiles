"use strict";(globalThis.webpackChunk_coral_xyz_app_extension=globalThis.webpackChunk_coral_xyz_app_extension||[]).push([[9653],{369653:(t,e,n)=>{n.d(e,{WormholeClient:()=>G});var o=n(817967),r=n(883739),i=n(235489),a=n(102177),s=n(890819),c=n(750793),l=n(363746),h=n(930476),u=n(213839),d=n(674588),f=n(963096),w=n(667188),g=n(329039),p=n(351384),m=n(525360),k=n(193952),b=n(956286),C=n(404452),E=n(624482),T=n(639460),y=n(801384),A=n(341478),S=n(861326),v=n(938694),x=n(834348),I=n(477851),M=n(127942),N=n(461763),O=n(348834).Buffer;const P="0x540f174088E1B023705B3e762810B007124530f4",D={Aptos:y.EfF,Ethereum:I.aY,HyperEVM:I.aY,Solana:M.VU,Polygon:I.Ai,Sui:A.uq};function B(t){const e=(0,r.qZ)(t)?.wormholeChainId;if(!e)throw new Error(`Wormhole not enabled for blockchainId ${t}.`);return e}function $(t){return(0,d.tY)(t.address)?D[t.chain]:t.address.toString()}function W(t,e){return Object.keys(t).reduce(((n,o)=>(n[o]=e(t[o],o,t),n)),{})}function U(t,e){return Object.values(D).includes(t)?e===o.Ek.SUI_MAINNET||e===o.Ek.APTOS_MAINNET?t:"native":t}function _(t,e,n){const i=(0,r.qZ)(e),a=B(e),s=t.wh.config.chains[a];if(!s)throw new Error(`${e} not found in chain configuration.`);if(e===o.Ek.HYPEREVM_MAINNET){const t=o.zp[e];if(t&&n.toLowerCase()===t.toLowerCase())return 6}const c=s.tokenMap;if(!c)throw new Error(`Undefined token map for ${e}.`);if(n===i?.gasCurrencyAddress||e===o.Ek.SUI_MAINNET&&n===A.uq){const t=e===o.Ek.SUI_MAINNET?A.uq:e===o.Ek.APTOS_MAINNET?y.EfF:"native",n=Object.values(c).find((e=>e.address.toLowerCase()===t.toLowerCase()));if(!n)throw new Error(`Native Token not found on ${e}.`);return n.decimals}const l=Object.values(c).find((t=>t.address.toLowerCase()===n.toLowerCase()));if(!l){if(e===o.Ek.SUI_MAINNET&&n.toLowerCase()===o.zp[o.Ek.SUI_MAINNET]?.toLowerCase())return 6;if(e===o.Ek.APTOS_MAINNET&&n.toLowerCase()===o.zp[o.Ek.APTOS_MAINNET]?.toLowerCase())return 6;throw new Error(`Source Token not found on ${e}.`)}return l.decimals}class R{client;publicKey;constructor(t,e){this.client=t,this.publicKey=e}address(){return this.publicKey}}class F extends R{async signAndSend(t){const e=this.client.getSigner(this.address()),n=[];this.cleanupOldTransactions();for(const o of t){const{description:t,transaction:r}=o;console.log(`Signing ${t}`);const i=this.getTransactionKey(o),a=F.recentTransactions.get(i);if(a)n.push(a.txid);else{"value"in r&&"bigint"==typeof r.value&&(r.value=v.Al.encode(r.value,!0)),"chainId"in r&&"bigint"==typeof r.chainId&&(r.chainId=v.Al.encode(r.chainId,!0));try{r.gas=await e.estimateGas(r);const o=await e.sendTransaction(r);t.includes("Approve")&&await this.client.confirmTransaction(o.hash),F.recentTransactions.set(i,{timestamp:Date.now(),txid:o.hash}),n.push(o.hash)}catch(t){throw console.error(t),t}}}return n}static recentTransactions=new Map;getTransactionKey(t){const{transaction:e}=t;return`${e.to}_${e.data}_${e.chainId}`}cleanupOldTransactions(){const t=Date.now();for(const[e,n]of F.recentTransactions.entries())t-n.timestamp>3e5&&F.recentTransactions.delete(e)}unwrap(){return this.client.getSigner(this.address())}chain(){return B(this.client.blockchainId)}}class j extends R{async signAndSend(t){const e=[];for(const n of t){const{description:t,transaction:o}=n;console.log(`Preparing to sign ${t}`);const r=await this.client.getBlockhash();o.signers&&((0,x.W)(o.transaction)?(o.transaction.message.recentBlockhash=r,o.transaction.sign(o.signers)):(o.transaction.recentBlockhash=r,o.transaction.partialSign(...o.signers))),e.push(o.transaction)}const n=(0,S.u)(this.address());return this.client.wallet.signAndSendAllTransactions({publicKey:n,txs:e,customConnection:this.client.solanaRpc,skipConfirmationDialog:!0})}chain(){return B((0,o.b9)(o.$O.SOLANA))}}class H extends R{async signAndSend(t){const e=this.address(),n=[];for(const r of t){const{transaction:t}=r;t.setSender(e),t.setGasBudget(N.fC);try{const r=await t.build({client:this.client.provider}),i=await this.client.simTransaction({tx:O.from(r).toString("base64"),senderAddress:e});if("failure"===i.simulationStatus.status)throw console.error("Error simulating the transaction: ",i.simulationStatus.error),new Error("Error simulating the transaction");const a=await this.client.signTransaction({tx:i.preparedTx,publicKey:e,blockchainId:o.Ek.SUI_MAINNET});if(!a.response?.signature)throw new Error("Signature Missing");const s=await this.client.executeTransaction({transactionBlock:a.response.tx,signature:a.response.signature,options:{showEffects:!0,showEvents:!0}});n.push(s.digest)}catch(t){throw console.error("Error signing or executing the transaction:",t),t}}return n}chain(){return B((0,o.b9)(o.$O.SUI))}}class K extends R{async signAndSend(t){const e=this.address(),n=[];for(const r of t){const{transaction:t}=r,i=await this.client.executeWormholeTransaction({tx:t,publicKey:e,blockchainId:o.Ek.APTOS_MAINNET});if(!i)throw new Error("Transaction hash missing from response");n.push(i)}return n}chain(){return B((0,o.b9)(o.$O.APTOS))}}var q=n(348834).Buffer;class L{blockChainClientMap;getWormholeSigner;constructor(t,e){this.blockChainClientMap=t,this.getWormholeSigner=e}async completeCCTPTransfer(t,e,o,r,i){const{CircleBridge:a,CONFIG:s}=await n.e(4409).then(n.bind(n,706145)),c=B(r),l=this.blockChainClientMap[r];if(!l)throw new Error(`Blockchain client not available for ${r}`);const h=await this.getMessageBytes(e,o),[u]=a.deserialize(q.from(h.replace("0x",""),"hex"));let d;if("Solana"===c){const{SolanaCircleBridge:t}=await Promise.resolve().then(n.bind(n,997135));d=new t("Mainnet","Solana",l.connection,s.Mainnet.chains.Solana.contracts)}else if("Sui"===c){const{SuiCircleBridge:t}=await Promise.resolve().then(n.bind(n,271659)),e=l.provider;if(!e)throw new Error(`Provider not available for ${r}`);d=new t("Mainnet","Sui",e,s.Mainnet.chains.Sui.contracts)}else if("Aptos"===c){const{AptosCircleBridge:t}=await Promise.resolve().then(n.bind(n,706230)),e=l.provider;if(!e)throw new Error(`Provider not available for ${r}`);d=new t("Mainnet","Aptos",e,s.Mainnet.chains.Aptos.contracts)}else{const{EvmCircleBridge:t}=await Promise.resolve().then(n.bind(n,640004)),e=l.provider;if(!e)throw new Error(`Provider not available for ${r}`);d=new t("Mainnet",c,e,s.Mainnet.chains[c].contracts)}const f=d.redeem(i,u,t),w=this.getWormholeSigner({blockchainId:r,publicKey:i}),g=[];for await(const t of f){const e=await w.signAndSend([t]);g.push(...e.map((t=>t.txid)))}return g[g.length-1]}async fetchCircleMessage(t,e){const n=`https://iris-api.circle.com/v2/messages/${e}?transactionHash=${t}`,o=await fetch(n);if(!o.ok)throw new Error(`Failed to fetch Circle message: ${o.statusText}`);const r=await o.json(),i=r?.messages;if(!i||0===i.length)throw new Error("No messages found");return i[0]}async getCircleAttestation(t,e){try{const n=await this.fetchCircleMessage(t,e),o=n?.attestation;return"pending_confirmations"===o?null:o&&"pending_confirmations"!==o?o:null}catch(t){return null}}async getMessageBytes(t,e){const n=await this.fetchCircleMessage(t,e),o=n?.message;if(!o)throw new Error("Message bytes not found");return o}}n(706230),n(114485),n(777524),n(640004),n(405490),n(761296),n(103637),n(138866),n(997135),n(766581),n(215058),n(119832),n(271659),n(995982),n(734238);var z=n(733748);const V={tokens:{W:[{chain:"Solana",manager:"NTtAaoDJhkeHeaVUHnyhwbPNAN6WgBpHkHBTc6d7vLK",token:"85VBFQZC9TZkfaptBWjvUw7YbZjy52A6mjtPGjstQAmQ",transceiver:[{address:"NTtAaoDJhkeHeaVUHnyhwbPNAN6WgBpHkHBTc6d7vLK",type:"wormhole"}],quoter:"Nqd6XqA8LbsCuG8MLWWuP865NV6jR1MbXeKxD4HLKDJ"},{chain:"Ethereum",manager:"0xc072B1AEf336eDde59A049699Ef4e8Fa9D594A48",token:"0xB0fFa8000886e57F86dd5264b9582b2Ad87b2b91",transceiver:[{address:"0xDb55492d7190D1baE8ACbE03911C4E3E7426870c",type:"wormhole"}]}]}},Z={};class G{blockChainClientMap;wh;chainMap;resolver;activeWormholeBlockchainIds;cctpHandler;constructor(t,e,n){const u=(0,r.AF)(n),d=Object.fromEntries(Object.entries(u).filter((([t,e])=>Object.prototype.hasOwnProperty.call(e,"wormholeChainId"))));this.activeWormholeBlockchainIds=Object.keys(d),this.blockChainClientMap=W(d,(t=>(0,z.G)(e,t))),this.wh=new s.D(t,[a.O,m.W,b.d,C.$],{chains:{Solana:{rpc:this.blockChainClientMap.solana?.networkConfig.rpcUrl}}});const f={getReferrerBps:()=>0,referrers:{Solana:"EcxjN4mea6Ah9WSqZhLtSJJCZcxY73Vaz6UVHFZZ5Ttz",Ethereum:P,Bsc:P,Polygon:P,Avalanche:P,Arbitrum:P,Optimism:P,Base:P,Sui:"0x9353bf9a52a1b500584e43b711d6f9a2c71849b00497eeccdc8fb5849f5f5c86"}},w=(0,i.yI)(i.nm,f),g=(0,i.yI)(i.cI,f),p=(0,i.yI)(i.IM,f),T=(0,i.yI)(i.Xj,f),y=[(0,k.S8)(V),c.f,l.U,h.R,(0,E.NO)(),w,g,p,T];this.resolver=this.wh.resolver(y),this.cctpHandler=new L(this.blockChainClientMap,this.getWormholeSigner.bind(this)),this.chainMap=W(d,((t,e)=>{let n;if(t.blockchain===o.$O.APTOS)n="Aptos";else if(t.blockchain===o.$O.SOLANA)n="Solana";else if(t.blockchain===o.$O.SUI)n="Sui";else{if(t.blockchain!==o.$O.ETHEREUM)return null;n="Evm"}if(!t.wormholeChainId)return null;try{return this.wh.getPlatform(n).getChain(t.wormholeChainId,this.getRpc(e))}catch(t){return console.error(`[WormholeClient] Failed to create chain context for ${e}:`,t),null}}))}async getRecentTransfers(t,e,n){const o=await this.wh.getTransactionsForAddress(t.publicKey,e,n);if(!o)return[];const r=(0,u.Vn)(B(t.blockchainId));return o.filter((t=>t.emitterChain===r)).map((t=>t.txHash))}async confirmTransaction(t,e,n=6e4){const o=await s.D.parseMessageFromTx(this.getWormholeContext(t),e,n),r=await this.wh.getTransactionStatus(o[0],n);return"confirmed"===r?.globalTx?.destinationTx?.status}isChainSupported(t){return null!=this.chainMap[t]}async getOutputTokens(t,e,n){if(!this.isChainSupported(t)||!this.isChainSupported(n))return[];try{return(await this.resolver.supportedDestinationTokens(s.D.tokenId(B(t),U(e,t)),this.getWormholeContext(t),this.getWormholeContext(n))).map((t=>(0,d.QC)(t)))}catch{return[]}}async getQuote(t){const e=await this.findBestRoute(t);if(!e)throw new Error("Couldn't get a quote for this request");const[n,o]=e,r=(0,T.Z)();return Z[r]={route:n},{quoteId:r,quote:o}}async executeSwap(t){const{srcChain:e,srcToken:n,dstChain:o,dstToken:r,srcAddress:i,dstAddress:a}=t,l=Z[t.quoteId];if(!l)throw new Error("Couldn't find a route for this request");const{route:u}=l,d=_(u,e,n),m={amount:t.amount,decimals:d},k={amount:f.jf(m),options:u.getDefaultOptions()},b=s.D.tokenId(B(e),U(n,e)),C=s.D.tokenId(B(o),U(r,o)),E=await w.f.create(u.wh,{source:b,destination:C}),T=await u.validate(E,k);if(!T.valid)throw T.error;const y=this.getWormholeSigner({blockchainId:e,publicKey:i}),A=await u.quote(E,T.params);if(!A.success)throw A.error;let S;for(let t=0;t<=3;t++)try{S=await u.initiate(E,y,A,(v=o,x=a,s.D.chainAddress(B(v),x)));break}catch(e){if(e?.message.includes("Approval Denied"))throw new Error("Transaction rejected");if(3===t)throw new Error("Failed to initiate route after 3 attempts");await new Promise((t=>setTimeout(t,2e3)))}var v,x;if(!S)throw new Error("Receipt is undefined");if(l.receipt=S,!g.x7(u)){if(!(0,p.vk)(S))throw new Error("Source not initiated, something went wrong");return{txid:S.originTxs[S.originTxs.length-1].txid}}if(u instanceof h.R||u instanceof c.f||this.isCCTPv2ExecutorRoute(u)){if(!(0,p.E6)(S)&&!(0,p.vk)(S))throw new Error(`Expected SourceFinalized or SourceInitiated state, got: ${S.state}`);const t=S.originTxs[S.originTxs.length-1].txid,e=S.attestation,n=e?.id?.hash??e?.id,o=e?.attestation?.message;return n&&o?{txid:t,messageHash:n,sourceDomain:o.sourceDomain,destinationDomain:o.destinationDomain,nonce:o.nonce?.toString()}:{txid:t}}try{let e=null;for await(const n of this.track(t.quoteId,a,o))if(e=n,(0,p.PN)(n))break;if(e&&(e.state===p.ki.Attested||e.state===p.ki.DestinationFinalized)&&e.originTxs?.length>0)return{txid:e.originTxs[e.originTxs.length-1].txid};throw new Error("No origin transactions found in finalized receipt.")}catch(t){throw console.error("Error in manual route:",t),t}}transferUrl(t,e){const n=Z[t];if(!n)throw new Error("Unable to get transfer url: metadata not found");const{route:o}=n;if(!o)throw new Error("Unable to get transfer url: route not found");return o.transferUrl(e)}async*track(t,e,n){const o=Z[t];if(!o)throw new Error("Unable to track: route not found");const{route:r,receipt:i}=o;if(!i)throw new Error("Quote receipt not found");let a=!1;try{for await(const o of r.track(i,12e4)){if(Z[t].receipt=o,o.state===p.ki.Attested&&g.x7(r)&&!a){const t=this.getWormholeSigner({blockchainId:n,publicKey:e});await r.complete(t,o),a=!0}if(yield o,(0,p.PN)(o))return}}catch(t){console.error("Error tracking: ",t)}return i}clearQuote(t){delete Z[t]}async manualClaim(t,e,n,o,r,i,a){if(a){const t=Z[a];if(t?.route&&t?.receipt){const{route:e,receipt:n}=t;if(g.x7(e)&&n.state===p.ki.Attested){const t=this.getWormholeSigner({blockchainId:r,publicKey:i});try{await e.complete(t,n);for await(const t of e.track(n,3e4))if((0,p.PN)(t)){const e=t.destinationTxs?.[0]?.txid;if(e)return e}}catch(t){}}}}const s=await this.cctpHandler.getCircleAttestation(t,e);if(!s)throw new Error("Attestation not yet available from Circle. Please try again later.");return await this.cctpHandler.completeCCTPTransfer(s,t,e,r,i)}async findBestRoute(t){const e=await this.findRoutes(t);let n=null,o=null;const r=[],i=(await Promise.all(e.map((async e=>{try{return await this.getQuoteForRoute(e,t)}catch(t){console.warn("error getting quote for route",t);let e=!1,i="";if(i=t.response?.data?.msg||t.message||"",e=i.includes("Minimum transfer amount")||i.includes("Amount too small"),e){const e=t?.response?.data?.data?.minAmountIn;e&&r.push({error:new Error(i),minAmount:e}),n||(n=new Error(i))}else o=t;return null}})))).filter((t=>null!=t));if(0===i.length){if(r.length>0)throw r.reduce(((t,e)=>e.minAmount<t.minAmount?e:t)).error;if(n)throw n;if(o)throw o;return null}return i.sort((([t,e],[n,o])=>Number(e.destinationToken.amount)-Number(o.destinationToken.amount))),i[i.length-1]}async findRoutes(t){const{srcChain:e,srcToken:n,dstChain:o,dstToken:r}=t,i=await w.f.create(this.wh,{source:s.D.tokenId(B(e),U(n,e)),destination:s.D.tokenId(B(o),U(r,o))},this.getWormholeContext(e),this.getWormholeContext(o));return await this.resolver.findRoutes(i)}async getQuoteForRoute(t,e){const{srcChain:n,srcToken:o,dstChain:r,dstToken:i}=e,a=_(t,n,o),c={amount:e.amount,decimals:a},l={amount:f.jf(c),options:t.getDefaultOptions()},h=s.D.tokenId(B(n),U(o,n)),u=s.D.tokenId(B(r),U(i,r)),d=await w.f.create(t.wh,{source:h,destination:u}),g=await t.validate(d,l);if(!g.valid)throw g.error;const p=await t.quote(d,g.params);if(!p.success)throw p.error;const m=p.destinationNativeGas?f.Dl(p.destinationNativeGas).toString():void 0,k=p.relayFee?{token:$(p.relayFee.token),amount:f.Dl(p.relayFee.amount).toString()}:void 0;return[t,{outAmount:f.jf(p.destinationToken.amount),sourceToken:{token:$(p.sourceToken.token),amount:f.Dl(p.sourceToken.amount).toString()},destinationToken:{token:$(p.destinationToken.token),amount:f.Dl(p.destinationToken.amount).toString()},isMayan:this.isMayanRoute(t),relayFee:k,eta:p.eta,destinationNativeGas:m}]}getWormholeSigner(t){const e=this.blockChainClientMap[t.blockchainId];if(void 0===e)throw new Error("Unrecognized chain: "+t.blockchainId);if(e?.networkConfig.blockchain===o.$O.APTOS)return new K(e,t.publicKey);if(e?.networkConfig.blockchain===o.$O.SOLANA)return new j(e,t.publicKey);if(e?.networkConfig.blockchain===o.$O.ETHEREUM)return new F(e,t.publicKey);if(e?.networkConfig.blockchain===o.$O.SUI)return new H(e,t.publicKey);throw new Error("Unsupported blockchain network: "+t.blockchainId)}getWormholeContext(t){const e=this.chainMap[t];if(null==e)throw new Error(`Unrecognized chain: ${t}`);return e}getRpc(t){const e=this.blockChainClientMap[t];if(void 0===e)throw new Error(`Unrecognized chain: ${t}`);return e.provider||e.provider||e.provider||e.connection}isMayanRoute(t){return t instanceof i.nm||t instanceof i.cI||t instanceof i.IM||t instanceof i.Xj}isCCTPv2ExecutorRoute(t){const e=t.constructor;return e.meta?.name?.includes("CCTPv2")??!1}}}}]);