import{a as w}from"./chunk-4L5AI6MG.js";import{a as v}from"./chunk-NZJHDIFC.js";import{c as d,f as y}from"./chunk-K6YGPUNZ.js";import"./chunk-K6262WF4.js";import{d as A,e as f}from"./chunk-LHUS6JBK.js";import"./chunk-R6TSAW7C.js";import"./chunk-2W2QYRRT.js";import{a as l,b as i,c as C}from"./chunk-Q7AZQDRY.js";import"./chunk-HDMZQINQ.js";import"./chunk-OAMYZMR4.js";import{o as T,q as g}from"./chunk-LHDKEQAM.js";T();g();var M=class extends v{constructor({supportChain:t}){super(),this.chainType=i.EVM,this.chainMap={},this.supportChain=t&&t.length>0?t:[i.EVM,i.SOLANA,i.APTOS,i.TRON,i.SUI,i.BTC,i.FRACTAL,i.BTCSIGNET,i.STACKS,i.STARKNET,i.NOSTR,i.COSMOS,i.TON,i.SONIC_DEV],this.initPromise=this.init(),this.aptos={},this.btc={},this.fractal={},this.cosmos={}}async getWeb3(){let t=await this.getOkxWalletProvider();return this.chainType===i.EVM?t:window?.okexchain[C[this.chainType]]}async init(){let t=this.supportChain.includes(i.SOLANA)?(await import("./Solana-GNAOBVWV.js")).default:{},e=this.supportChain.includes(i.APTOS)?(await import("./Aptos-5K5XJADM.js")).default:{},n=this.supportChain.includes(i.TRON)?(await import("./Tron-ZYVCC2HQ.js")).default:{},a=this.supportChain.includes(i.SUI)?(await import("./Sui-YZ7237KP.js")).default:{},c=this.supportChain.includes(i.BTC)?(await import("./Btc-TC3MB3NA.js")).default:{},s=this.supportChain.includes(i.FRACTAL)?(await import("./Fractal-R44WH2TK.js")).default:{},r=this.supportChain.includes(i.BTCSIGNET)?(await import("./BtcSignet-6A5E2CKD.js")).default:{},h=this.supportChain.includes(i.STACKS)?(await import("./Stacks-37MKD6A4.js")).default:{},o=this.supportChain.includes(i.STARKNET)?(await import("./Starknet-6FFEMBRZ.js")).default:{},p=this.supportChain.includes(i.NOSTR)?(await import("./Nostr-IDRUJ6NJ.js")).default:{},u=this.supportChain.includes(i.COSMOS)?(await import("./Cosmos-OYYMN36J.js")).default:{},S=this.supportChain.includes(i.TON)?(await import("./Ton-CZRTY7SM.js")).default:{},m=this.supportChain.includes(i.SONIC_DEV)?(await import("./SonicDev-NEGFYQMP.js")).default:{};this.chainMap={[i.SOLANA]:{...t},[i.APTOS]:{...e},[i.TRON]:{...n},[i.SUI]:{...a},[i.BTC]:{...c},[i.FRACTAL]:{...s},[i.BTCSIGNET]:{...r},[i.STACKS]:{...h},[i.STARKNET]:{...o},[i.NOSTR]:{...p},[i.TON]:{...S},[i.SONIC_DEV]:{...m},[i.COSMOS]:u},this.aptos=e,this.btc=c,this.fractal=s,this.cosmos=u}chainMethodMap(t){return this.chainMap[t]||{...w}}async getOkxWalletProvider(){let t=await d({chainType:this.chainType});if(this.chainType===i.EVM){let{web3Provider:e}=t;return e}return t}async getAccount({isNeedAll:t}={}){let e=await d();try{let n=await e?.getAccounts();if(t){let r=[];return n.forEach(h=>{let{address:o}=h;r.push(o)}),[...new Set(r)].join(",")}let a=this.chainMethodMap(this.chainType).getAccount,c=await this.getOkxWalletProvider(),s=await a({provider:c});if(!s)try{if(n&&n.length>0)return n[0].address}catch(r){throw console.log("get address err:",r),r}return s}catch(n){console.log("get address err:",n);try{let a=[];if(e?.getAccounts&&(a=await e?.getAccounts()),a&&a.length>0)return a[0].address}catch(a){throw console.log("get address err:",a),a}}}async getAccountByChainId({chainId:t,chainType:e}){let n=e||e===0?e:y(t),a=this.chainMethodMap(n).getAccount,c=await d({chainType:n});n===i.EVM&&(c=c?.web3Provider);try{return await a({provider:c,chainId:t})}catch(s){return console.log("getAccountByChainId err:",s),""}}async signMessage({nonce:t,message:e}){let n=await this.getOkxWalletProvider(),a=await this.getAccount(),c=this.chainMethodMap(this.chainType).signMessage;try{return await c({provider:n,message:e,nonce:t,address:a})}catch(s){throw console.log("signMessage err:",s),s}}async signTypedData({message:t,...e}){let n=await this.getAccount();return await window?.okexchain?.request({method:"eth_signTypedData_v4",params:[n,JSON.stringify(t)],...e})}async getChainId(){if(this.chainType===i.EVM){let t=await this.getOkxWalletProvider(),e=await w.getChainId({provider:t});return await f(e)}else if(this.chainType===i.COSMOS)return this.cosmos.getChainId();return this.chainType}async onChainChange(t){window?.okxwallet?.on?.("chainChanged",t)}async switchNetwork({chain:t,chainType:e,addNetworkConfig:n}){let a=await this.getChainId(),c=await this.getAccountByChainId({chainId:t,chainType:e}),s=e||e==0?e:y(t);if(c){if(s!==i.EVM)return!0}else return!1;let r=await A(t);if(a===r||isNaN(r))return!0;try{return await window?.okexchain?.switchChain({chainId:`0x${Number(r).toString(16)}`}),!0}catch(h){if(h.code===4902)try{return await window?.okexchain?.request({method:"wallet_addEthereumChain",params:n}),!0}catch{return!1}return!1}}async watchAsset({tokenOptions:t}){let e=window.okexchain;return await w.watchAsset({provider:e,tokenOptions:t})}async sendTransaction({payload:t,cb:e,extraParams:n}){let a=await this.getOkxWalletProvider(),c=this.chainMethodMap(this.chainType).sendTransaction,s=await this.getAccount();return c({provider:a,payload:t,cb:e,extraParams:n,address:s})}async setChainType({chainType:t,chainId:e}){let n=t||t==0?t:y(e);if(!!await this.getAccountByChainId({chainId:e,chainType:n}))this.chainType=n,n===i.COSMOS&&this.cosmos.setChainId(e);else{let s=await d();s?.getAccounts?s.getAccounts().then(r=>{if(r){let{coinType:h}=r[0];this.chainType=h}}).catch(()=>{this.chainType=n}):this.chainType=n}}async signAllTransactions({transactions:t}){let e=await this.getOkxWalletProvider(),n=this.chainMethodMap(this.chainType).signAllTransactions;if(!n)throw new Error("current chain have no signAllTransactions, please check it");return await n({provider:e,transactions:t})}async depositWToken({wTokenAddr:t,wTokenAbi:e,amount:n,cb:a}){let c=await this.getAccount(),s=await this.getWeb3(),r=w.depositWToken({wTokenAddr:t,wTokenAbi:e,amount:n,account:c,web3:s});return this.sendTransaction({payload:r,cb:a})}async withdrawWToken({wTokenAddr:t,wTokenAbi:e,amount:n,cb:a}){let c=await this.getAccount(),s=await this.getWeb3(),r=w.withdrawWToken({wTokenAddr:t,wTokenAbi:e,amount:n,account:c,web3:s});return this.sendTransaction({payload:r,cb:a})}async getAllChainTypeInfoList(){let t=[],n=await(await d())?.getAccounts();if(n&&n.length>0){let a="";n.some(o=>{let{chainId:p}=o;return Number(p)==l.ETH?(a={...o,chainType:i.EVM},!0):!1});let c="";n.some(o=>{let{chainId:p}=o;return Number(p)==l.FRACTAL?(c={...o,chainType:i.FRACTAL},!0):!1});let s="";n.some(o=>{let{chainId:p}=o;return Number(p)==l.SONIC_DEV?(s={...o,chainType:i.SONIC_DEV},!0):!1});let r=n.filter(o=>{let{coinType:p,chainId:u}=o;return p!==i.EVM&&![l.FRACTAL,l.SONIC_DEV].includes(Number(u))}),h=new Map;t=r.filter(o=>!h.has(o.coinType)&&h.set(o.coinType,1)),t=t.map(o=>({...o,chainType:o.coinType})),a&&t.push(a),c&&t.push(c),s&&t.push(s)}return t}async registerAptosCoin({contractAddress:t}){return this.aptos.registerAptosCoin({contractAddress:t,provider:window.okexchain})}async checkAndRegAptosCoin({address:t,contractAddress:e}){return this.aptos.checkAndRegAptosCoin({provider:window.okexchain,address:t,contractAddress:e})}async getAptosBalance({address:t,currency:e}){return this.aptos.getAptosBalance({address:t,currency:e})}async getAptosTransaction(t){return this.aptos.getAptosTransaction(t)}getSolanaConnection(){let t=this.chainMethodMap(this.chainType).getSolanaConnection;if(!t)throw new Error("current chain have no getSolanaConnection, please check it");return t()}async getPublicKey(){let t=await this.getOkxWalletProvider(),e=this.chainMethodMap(this.chainType).getPublicKey;if(!e)throw new Error("current chain have no getPublicKey, please check it");return e({provider:t})}async getCompressedPublicKey(){let t=await this.getOkxWalletProvider(),e=this.chainMethodMap(this.chainType).getCompressedPublicKey;if(!e)throw new Error("current chain have no getCompressedPublicKey, please check it");return e({provider:t})}async sendInscription({from:t,to:e,data:n,type:a}){let c=await d({chainType:this.chainType}),s=this.chainMethodMap(this.chainType).sendInscription;if(!s)throw new Error("current chain have no sendInscription, please check it");return await s({provider:c,from:t,to:e,data:n,type:a})}async signPsbt({psbtHex:t,type:e,...n}){let a=await d({chainType:this.chainType}),c=await this.getAccount(),s=this.chainMethodMap(this.chainType).signPsbt;if(!s)throw new Error("current chain have no signPsbt, please check it");return s({provider:a,psbtHex:t,type:e,account:c,...n})}async sendPsbt({txList:t}){let e=await d({chainType:this.chainType}),n=await this.getAccount(),a=this.chainMethodMap(this.chainType).sendPsbt;if(!a)throw new Error("current chain have no sendPsbt, please check it");return await a({provider:e,txList:t,account:n})}async signPsbts({psbtHexs:t,options:e}){let n=await d({chainType:this.chainType}),a=this.chainMethodMap(this.chainType).signPsbts;if(!a)throw new Error("current chain have no signPsbts, please check it");return await a({psbtHexs:t,options:e,provider:n})}async validateAddress({account:t}){let e=await d({chainType:this.chainType}),n=this.chainMethodMap(this.chainType).validateAddress;if(!n)throw new Error("current chain have no validateAddress, please check it");return await n({provider:e,account:t})}async sendBitcoin({to:t,value:e,satBytes:n,extraParams:a,...c}){let s=await d({chainType:this.chainType}),r=await this.getAccount(),h=this.chainMethodMap(this.chainType).sendBitcoin;if(!h)throw new Error("current chain have no sendBitcoin, please check it");return await h({provider:s,from:r,to:t,value:e,satBytes:n,extraParams:a,...c})}async getLatestBlockhash(){let t=await this.getAccount(),e=this.chainMethodMap(this.chainType).getLatestBlockhash;if(!e)throw new Error("current chain have no getLatestBlockhash, please check it");return await e({from:t})}async getBtcAddressType({address:t}){let e=this.chainMethodMap(this.chainType).getBtcAddressType;if(!e)throw new Error("current chain have no sendInscription, please check it");return e({address:t})}async inscribe({from:t,to:e,txSource:n,type:a,inscriptions:c,tick:s,amount:r,mintType:h,...o}){let p=await d({chainType:this.chainType}),u=this.chainMethodMap(this.chainType).inscribe;if(!u)throw new Error("current chain have no sendInscription, please check it");return u({provider:p,from:t,to:e,txSource:n,type:a,inscriptions:c,tick:s,amount:r,mintType:h,...o})}};export{M as OkxWalletAdapter};
//# sourceMappingURL=OkxWalletAdapter-EJCUFGIO.js.map
