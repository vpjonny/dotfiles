import{a as c}from"./chunk-MEXOKPLI.js";import{c as o,f as p}from"./chunk-W6ZDZJCJ.js";import{a as f}from"./chunk-JKOG5MDP.js";import{d as m,e as C}from"./chunk-PGGBOJAH.js";import{a as y}from"./chunk-JDCCMYBK.js";import"./chunk-554VFFSY.js";import"./chunk-4ADHM5NM.js";import{b as i,c as w}from"./chunk-JBOOQ7HO.js";import"./chunk-TGW66MRK.js";import"./chunk-EI7BJC6V.js";import{o as g,q as l}from"./chunk-UWURTNRY.js";g();l();var v=class extends f{constructor({supportChain:t}){super(),this.chainType=i.EVM,this.chainMap={},this.supportChain=t&&t.length>0?t:[i.EVM,i.SOLANA],this.initPromise=this.init()}async init(){let t=this.supportChain.includes(i.SOLANA)?(await import("./Solana-GD7ODRRV.js")).default:{};this.chainMap={[i.SOLANA]:{...t}}}chainMethodMap(t){return this.chainMap[t]||{...c}}async getOkxConnectProvider(t){let n=t||t===i.BTC?t:this.chainType,e=await o();return n===i.EVM?new Web3(e?.ethereum):e}async getWeb3(){let t=await this.getOkxConnectProvider();return this.chainType===i.EVM?t:t[w[this.chainType]]}async getAccount(){let t=this.chainMethodMap(this.chainType).getAccount,n=await this.getOkxConnectProvider();return await t({provider:n})}async getAccountByChainId({chainId:t,chainType:n}){let e=n||n===i.BTC?n:p(t),s=this.chainMethodMap(e).getAccount,r=await this.getOkxConnectProvider(e);try{return await s({provider:r,chainId:t})}catch(a){return console.log("getAccountByChainId err:",a),""}}async signMessage({nonce:t,message:n}){let e=await this.getOkxConnectProvider(),s=await this.getAccount(),r=this.chainMethodMap(this.chainType).signMessage;try{return await r({provider:e,message:n,nonce:t,address:s})}catch(a){throw console.log("signMessage err:",a),a}}async signTypedData({message:t,...n}){let e=await this.getAccount();return await(await o())?.ethereum?.request({method:"eth_signTypedData_v4",params:[e,JSON.stringify(t)],...n})}async getChainId(){if(this.chainType===i.EVM){let t=await this.getOkxConnectProvider(),n=await c.getChainId({provider:t});return await C(n)}return this.chainType}async switchNetwork({chain:t,externalProvider:n}){let e=await m(t),s=await o(),r=n||s?.ethereum;try{let a=await this.getChainId();return String(a)===String(e)||await r.request({method:"wallet_switchEthereumChain",params:[{chainId:`0x${parseInt(e).toString(16)}`}]}),!0}catch(a){console.log("metamask switch error",a);let{code:h,data:M}=a||{};if(h!==-32002)if([4902,-32602].includes(h)||M?.originalError?.code===4902)try{if(!e&&e!==0)throw new Error("chain parameter is not legal");let d=await y(e),{data:u}=d||{};if(u&&u.length>0){await r.request({method:"wallet_addEthereumChain",params:u});let T=await this.getChainId();return String(T)===String(e)}throw new Error("chain info is not exist")}catch(d){return console.log(d),!1}else return h===4001,!1}return!1}async sendTransaction({payload:t,cb:n,extraParams:e}){let s=await this.getOkxConnectProvider(),r=this.chainMethodMap(this.chainType).sendTransaction,a=await this.getAccount();return r({provider:s,payload:t,cb:n,extraParams:e,address:a})}async setChainType({chainType:t,chainId:n}){let e=t||t==0?t:p(n);!!await this.getAccountByChainId({chainId:n,chainType:e})&&(this.chainType=e)}async signAllTransactions({transactions:t}){let n=await this.getOkxConnectProvider(),e=this.chainMethodMap(this.chainType).signAllTransactions;if(!e)throw new Error("current chain have no signAllTransactions, please check it");return await e({provider:n,transactions:t})}getSolanaConnection(){let t=this.chainMethodMap(this.chainType).getSolanaConnection;if(!t)throw new Error("current chain have no getSolanaConnection, please check it");return t()}async getLatestBlockhash(){let t=await this.getAccount(),n=this.chainMethodMap(this.chainType).getLatestBlockhash;if(!n)throw new Error("current chain have no getLatestBlockhash, please check it");return await n({from:t})}async getAllChainTypeInfoList(){let t=await this.getAccount(),n=await this.getChainId();return[{address:t,chainType:this.chainType,chainId:n}]}async watchAsset({tokenOptions:t}){let e=(await o())?.ethereum;return await c.watchAsset({provider:e,tokenOptions:t})}async addNetwork({params:t}){let e=(await o())?.ethereum;return await c.addNetwork({provider:e,params:t})}};export{v as OkxConnectAdapter};
//# sourceMappingURL=OkxConnectAdapter-CS6B3G5R.js.map
