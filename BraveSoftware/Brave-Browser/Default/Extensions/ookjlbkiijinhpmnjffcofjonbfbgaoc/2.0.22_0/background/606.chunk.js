"use strict";(self.webpackChunktemple_wallet=self.webpackChunktemple_wallet||[]).push([[606],{48606:(e,s,t)=>{t.r(s),t.d(s,{createLedgerSignerProxy:()=>l});var r=t(96815),a=t.n(r),i=t(10495),n=t(36539);class c{creatorArgs;id;signer;constructor(e){this.creatorArgs=e,this.id=Date.now()}publicKey=()=>this.requestMethodCall({name:"publicKey"},(e=>e.publicKey()));publicKeyHash=()=>this.requestMethodCall({name:"publicKeyHash"},(e=>e.publicKeyHash()));sign=(e,s)=>this.requestMethodCall({name:"sign",args:{op:e,magicByte:s&&(0,n.Yh)(s)}},(t=>t.sign(e,s)));async secretKey(){throw new Error("Secret key cannot be exposed")}async requestMethodCall({name:e,args:s},r){if(this.signer)return r(this.signer);const n={type:"LEDGER_PROXY_REQUEST",instanceId:this.id,creatorArgs:this.creatorArgs,method:e,args:s},c=await a().runtime.sendMessage(n);if("success"===c.type)return c.value;if("refusal"===c.type){const e=(await Promise.all([t.e(450),t.e(449)]).then(t.bind(t,14449))).createLedgerSigner,{derivationPath:s,derivationType:a,publicKey:i,publicKeyHash:n}=this.creatorArgs,{signer:l}=await e(c.transportType,s,a,i,n);return this.signer=l,r(l)}throw new i.I(c.message)}}const l=async(...[e,s,t,r])=>({signer:new c({derivationPath:e,derivationType:s,publicKey:t,publicKeyHash:r}),cleanup:()=>{}})}}]);