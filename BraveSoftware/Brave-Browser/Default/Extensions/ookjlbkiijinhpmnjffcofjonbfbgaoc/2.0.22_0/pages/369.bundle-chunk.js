(self.webpackChunktemple_wallet=self.webpackChunktemple_wallet||[]).push([[369],{77709:(e,r,t)=>{"use strict";t.r(r),t.d(r,{createLedgerSigner:()=>E});var i=t(15127),s=t(38608),c=t(48110),n=t(86729),a=t(48402),u=t(64527),h=t.n(u),o=t(52781);class y extends s.su{accPublicKey;accPublicKeyHash;constructor(e,r=o.m7,t=!0,i=s.Mz.ED25519,c,n){super(e,r,t,i),this.accPublicKey=c,this.accPublicKeyHash=n}async publicKey(){return this.accPublicKey??this.withErrorCauseThrow((()=>super.publicKey()),i.Ay)}async publicKeyHash(){return this.accPublicKeyHash??this.withErrorCauseThrow((()=>super.publicKeyHash()),i.K5)}async withErrorCauseThrow(e,r){return e().catch((e=>{if(r(e)&&e.cause instanceof Error)throw e.cause;throw e}))}async sign(e,r){const t=await super.sign(e,r).catch((e=>{throw(0,i.hM)(e)}));let s=(0,c.$$)(e);"undefined"!==typeof r&&(s=(0,c.m6)(r,s));const n=(0,c.hi)(h()(s));if(!await this.verify(n,t.prefixSig))throw(0,i.hM)(new Error("Signature failed verification against public key. Maybe the account on your device does not match the account from which you are trying to perform the action."));return t}async verify(e,r){await a.ready;const t=await this.publicKey(),i=await this.publicKeyHash();return g(e,r,t,i)}}const p={ed:{pk:c.Rk.Ed25519PublicKey,sk:c.Rk.Ed25519SecretKey,pkh:c.Rk.Ed25519PublicKeyHash,sig:c.Rk.Ed25519Signature},p2:{pk:c.Rk.P256PublicKey,sk:c.Rk.P256SecretKey,pkh:c.Rk.P256PublicKeyHash,sig:c.Rk.P256Signature},sp:{pk:c.Rk.Secp256k1PublicKey,sk:c.Rk.Secp256k1SecretKey,pkh:c.Rk.Secp256k1PublicKeyHash,sig:c.Rk.Secp256k1Signature}},l=["sig","edsig","spsig","p2sig"],g=(e,r,t,i)=>{const s=t.substring(0,2),n=new Uint8Array(h()((0,c.$9)(t,[p[s].pk],!0))),u=r.startsWith("sig")?r.substring(0,3):r.substring(0,5);if(!l.includes(u))throw new Error(`Unsupported signature given by remote signer: ${r}`);if((0,c.aP)((0,a.crypto_generichash)(20,n),p[s].pkh)!==i)throw new Error(`Requested public key does not match the initialized public key hash: {\n          publicKey: ${t},\n          publicKeyHash: ${i}\n        }`);const o=new Uint8Array(b(r,s,p)),y=(0,a.crypto_generichash)(32,(0,c.$$)(e));if("ed"===s)return d(o,y,n);if("sp"===s)return w(o,y,n);if("p2"===s)return k(o,y,n);throw new Error(`Curve '${s}' not supported`)},b=(e,r,t)=>{let i;if("sig"===e.substring(0,3))i=(0,c.$9)(e,[c.Rk.GenericSignature],!0);else{if(e.substring(0,5)!==`${r}sig`)throw new Error(`Invalid signature provided: ${e}`);i=(0,c.$9)(e,[t[r].sig],!0)}return i},d=(e,r,t)=>{try{return(0,a.crypto_sign_verify_detached)(e,r,t)}catch(e){return!1}},w=(e,r,t)=>{const i=new n.ec("secp256k1").keyFromPublic(t),s=(0,c.hi)(h()(e)).match(/([a-f\d]{64})/gi);if(s)try{const[e,t]=s;return i.verify(r,{r:e,s:t})}catch(e){return!1}return!1},k=(e,r,t)=>{const i=new n.ec("p256").keyFromPublic(t),s=(0,c.hi)(h()(e)).match(/([a-f\d]{64})/gi);if(s)try{const[e,t]=s;return i.verify(r,{r:e,s:t})}catch(e){return!1}return!1};var f=t(24450),K=t(13983),m=t(37287),P=t(48287).Buffer;class S extends K.Ay{static async isSupported(){return!0}static async list(){return[]}static listen(){return{unsubscribe:()=>{}}}scrambleKey;transportType;bridge;constructor(e=m.Y.U2F){super(),this.transportType=e}async exchange(e){const r=await this.getBridge(),t={apdu:e.toString("hex"),scrambleKey:this.scrambleKey?.toString("ascii"),exchangeTimeout:this.exchangeTimeout,transportType:this.transportType};let i;try{i=await r.requestExchange(t)}catch(e){throw new f.wX(e.message,"id")}return P.from(i,"hex")}updateTransportType(e){this.transportType=e}setScrambleKey(e){this.scrambleKey=P.from(e,"ascii")}async close(){if(this.bridge)return this.bridge.close()}async getBridge(){if(this.bridge)return this.bridge;const e=new(0,(await Promise.all([t.e(937),t.e(149)]).then(t.bind(t,22149))).TransportBridge);return this.bridge=e}}const E=async(e,...[r,t,s,c])=>{const n=await v(e);return{signer:new y(n,(0,i.yJ)(r),!0,t,s,c),cleanup:()=>{}}};let R;const v=async e=>(R&&await R.close(),R=new S(e),R)},40093:()=>{}}]);