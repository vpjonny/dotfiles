import{h as F,k as w}from"./chunk-3H3VDE2B.js";import{b as E}from"./chunk-NMTPXQAP.js";import{Ob as W,Ta as M}from"./chunk-W7IWPUIQ.js";import{a as o,i as c,n as f}from"./chunk-WKJYWAXG.js";c();f();var I=W({authRepository:w,queryClient:F});c();f();var P=new M(E,w,I);c();f();c();f();c();f();var h=o(n=>`sq:doc:value:${n}`,"valueKeyFor"),p=o(n=>`sq:doc:refCount:${n}`,"refCountKeyFor"),g=o(n=>`sq:doc:refIds:${n}`,"refIdsKeyFor"),y=o(n=>`sq:doc:updatedAt:${n}`,"updatedAtKeyFor"),v=o(n=>`sq:doc:streamOrphanRefs:${n}`,"streamOrphanRefsKeyFor"),A=o(n=>`sq:doc:optimisticInsertRefs:${n}`,"optimisticInsertRefsKeyFor"),Q=o(n=>`sq:doc:queue:${n}`,"queueKeyFor"),S=50,b=1e3*60*60*24;var R=class{static{o(this,"AsyncQueryStore")}isWriter;delegate;sendMessage;messageQueue=[];queues=new Map;queueProcessorPromise;resolveQueueWait;constructor(e){this.isWriter=e.isWriter,this.delegate=e.delegate;let{sendMessage:s}=e.connect(this.handleMessage.bind(this));if(this.sendMessage=s,this.isWriter){if(!this.delegate)throw new Error("Writer must have a delegate");this.startQueueProcessor()}}handleMessage(e){this.isWriter&&this.enqueueMessage(e)}enqueueMessage(e){this.messageQueue.push(e),this.resolveQueueWait&&(this.resolveQueueWait(),this.resolveQueueWait=void 0)}startQueueProcessor(){this.queueProcessorPromise=this.processQueue()}async processQueue(){for(;;){for(;this.messageQueue.length===0;)await new Promise(s=>{this.resolveQueueWait=s});let e=this.messageQueue.shift();try{await this.processMessage(e)}catch(s){console.error("Error processing message:",s)}}}async processMessage(e){switch(e.type){case"saveQuery":await this.writerSaveQuery(e.queryDefId,e.queryKey,e.value,e.updatedAt,e.refIds,e.extra);break;case"saveEntity":await this.writerSaveEntity(e.entityKey,e.value,e.refIds);break;case"activateQuery":await this.writerActivateQuery(e.queryDefId,e.queryKey);break;case"deleteQuery":await this.writerDeleteValue(e.queryKey);break}}async loadQuery(e,s,t){if(!this.delegate)return;let i=await this.delegate.getNumber(y(s));if(i===void 0||i<Date.now()-(e.cache?.gcTime??b))return;let a=await this.delegate.getString(h(s));if(a===void 0)return;let r=await this.delegate.getBuffer(g(s));r!==void 0&&await this.preloadEntities(r,t);let u=await this.delegate.getBuffer(v(s)),d=await this.delegate.getBuffer(A(s));u!==void 0&&await this.preloadEntities(u,t),d!==void 0&&await this.preloadEntities(d,t);let l;return(u!==void 0||d!==void 0)&&(l={},u!==void 0&&(l.streamOrphanRefs=Array.from(u)),d!==void 0&&(l.optimisticInsertRefs=Array.from(d))),this.activateQuery(e,s),{value:JSON.parse(a),refIds:r===void 0?void 0:new Set(r??[]),updatedAt:i,extra:l}}async preloadEntities(e,s){if(this.delegate)for(let t of e){let i=await this.delegate.getString(h(t));if(i===void 0)continue;let a=JSON.parse(i);s.setPreloadedEntity(t,a);let r=await this.delegate.getBuffer(g(t));r!==void 0&&await this.preloadEntities(r,s)}}saveQuery(e,s,t,i,a,r){let u={type:"saveQuery",queryDefId:e.id,queryKey:s,value:t,updatedAt:i,refIds:a?Array.from(a):void 0,extra:r};this.isWriter?this.enqueueMessage(u):this.sendMessage(u)}saveEntity(e,s,t){let i={type:"saveEntity",entityKey:e,value:s,refIds:t?Array.from(t):void 0};this.isWriter?this.enqueueMessage(i):this.sendMessage(i)}activateQuery(e,s){let t={type:"activateQuery",queryDefId:e.id,queryKey:s};this.isWriter?this.enqueueMessage(t):this.sendMessage(t)}deleteQuery(e){let s={type:"deleteQuery",queryKey:e};this.isWriter?this.enqueueMessage(s):this.sendMessage(s)}async writerSaveQuery(e,s,t,i,a,r){await this.setValue(s,t,a?new Set(a):void 0),await this.delegate.setNumber(y(s),i),r?.streamOrphanRefs!==void 0&&r.streamOrphanRefs.length>0?await this.delegate.setBuffer(v(s),new Uint32Array(r.streamOrphanRefs)):await this.delegate.delete(v(s)),r?.optimisticInsertRefs!==void 0&&r.optimisticInsertRefs.length>0?await this.delegate.setBuffer(A(s),new Uint32Array(r.optimisticInsertRefs)):await this.delegate.delete(A(s)),await this.writerActivateQuery(e,s)}async writerSaveEntity(e,s,t){await this.setValue(e,s,t?new Set(t):void 0)}async writerActivateQuery(e,s){if(!await this.delegate.has(h(s)))return;let t=this.queues.get(e);if(t===void 0){let r=S;t=await this.delegate.getBuffer(Q(e)),t===void 0?(t=new Uint32Array(r),await this.delegate.setBuffer(Q(e),t)):t.length!==r&&(t=new Uint32Array(t.buffer,0,r),await this.delegate.setBuffer(Q(e),t)),this.queues.set(e,t)}let i=t.indexOf(s);if(i>=0){if(i===0)return;t.copyWithin(1,0,i),t[0]=s;return}let a=t[t.length-1];t.copyWithin(1,0,t.length-1),t[0]=s,a!==0&&(await this.writerDeleteValue(a),await this.delegate.delete(y(a)))}async setValue(e,s,t){let i=this.delegate;await i.setString(h(e),JSON.stringify(s));let a=g(e),r=await i.getBuffer(a);if(t===void 0||t.size===0){if(await i.delete(a),r!==void 0)for(let u=0;u<r.length;u++){let d=r[u];await this.decrementRefCount(d)}}else{let u=new Uint32Array(t);if(r!==void 0)for(let d=0;d<r.length;d++){let l=r[d];t.has(l)?t.delete(l):await this.decrementRefCount(l)}for(let d of t)await this.incrementRefCount(d);await i.setBuffer(a,u)}}async writerDeleteValue(e){let s=this.delegate;await s.delete(h(e)),await s.delete(p(e));let t=await s.getBuffer(g(e));if(await s.delete(g(e)),t!==void 0)for(let i of t)i!==0&&await this.decrementRefCount(i)}async incrementRefCount(e){let s=this.delegate,t=p(e),a=(await s.getNumber(t)??0)+1;await s.setNumber(t,a)}async decrementRefCount(e){let s=this.delegate,t=p(e),i=await s.getNumber(t);if(i===void 0)return;let a=i-1;a===0?await this.writerDeleteValue(e):await s.setNumber(t,a)}};var C=class{static{o(this,"ChromeExtensionPersistentStore")}async has(e){let s=await chrome.storage.local.get(e);return e in s}async getString(e){let t=(await chrome.storage.local.get(e))[e];return t===void 0?void 0:String(t)}async setString(e,s){await chrome.storage.local.set({[e]:s})}async getNumber(e){let t=(await chrome.storage.local.get(e))[e];return t===void 0?void 0:Number(t)}async setNumber(e,s){await chrome.storage.local.set({[e]:s})}async getBuffer(e){let t=(await chrome.storage.local.get(e))[e];if(t!==void 0&&Array.isArray(t))return new Uint32Array(t)}async setBuffer(e,s){await chrome.storage.local.set({[e]:Array.from(s)})}async delete(e){await chrome.storage.local.remove(e)}};function N(n){let e=n.portName??"signalium-query-store";return s=>{if(n.isWriter)return chrome.runtime.onConnect.addListener(t=>{t.name===e&&t.onMessage.addListener(i=>{s(i)})}),{sendMessage:o(()=>{},"sendMessage")};{let t=chrome.runtime.connect({name:e});return{sendMessage:o(i=>{try{t.postMessage(i)}catch(a){console.error("Failed to send message to background:",a)}},"sendMessage")}}}}o(N,"createChromeExtensionConnection");var se=o((n={isWriter:!1})=>new R({isWriter:n?.isWriter??!1,connect:N(n),delegate:n.isWriter?new C:void 0}),"createChromeStorageStore");export{I as a,P as b,se as c};
//# sourceMappingURL=chunk-73ZPMDWU.js.map
