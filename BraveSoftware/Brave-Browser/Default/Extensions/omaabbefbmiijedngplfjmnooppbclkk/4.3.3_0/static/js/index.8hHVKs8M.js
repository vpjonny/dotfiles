import{iv as U,iw as x,im as k,ix as _,io as O,iP as ft,iQ as dt,ip as g,iR as pt,ir as tt,il as et,iS as P,iA as yt,iT as rt,iU as K,is as gt,iM as I,iN as wt,iV as mt,iK as Et,iL as bt,iy as xt,iW as Nt,iX as At}from"./main.D-W_HyrW.js";import{j9 as ne,jq as se,jr as ie,iH as ae,j1 as oe,iD as ue,iC as le,iF as ce,je as he,j8 as fe,jm as de,ja as pe,iG as ye,jv as ge,i$ as we,j0 as me,jc as Ee,jk as be,jd as xe,iE as Ne,jb as Ae,jh as ke,iu as Re,jf as Oe,jn as Be,js as Te,jg as Ve,jo as _e,jt as $e,ju as Ce,jl as Se,j7 as Ie,iq as je,iZ as Le,ji as Pe,it as ve,iz as Ue,j4 as ze,j2 as Me,iI as De,i_ as We,jj as Fe,j3 as Ke,j5 as Je,j6 as Ye,iJ as Ze,iO as qe,jp as Ge,iY as He,iB as Xe}from"./main.D-W_HyrW.js";const p=32,z=new Uint8Array(p),kt=["then"],j={},nt=new WeakMap;function R(l){return nt.get(l)}function J(l,t){nt.set(l,t)}function C(l,t){const e=new Error(`deferred error during ABI decoding triggered accessing ${l}`);throw e.error=t,e}function M(l,t,e){return l.indexOf(null)>=0?t.map((r,n)=>r instanceof A?M(R(r),r,e):r):l.reduce((r,n,s)=>{let i=t.getValue(n);return n in r||(e&&i instanceof A&&(i=M(R(i),i,e)),r[n]=i),r},{})}class A extends Array{#t;constructor(...t){const e=t[0];let r=t[1],n=(t[2]||[]).slice(),s=!0;e!==j&&(r=t,n=[],s=!1),super(r.length),r.forEach((a,c)=>{this[c]=a});const i=n.reduce((a,c)=>(typeof c=="string"&&a.set(c,(a.get(c)||0)+1),a),new Map);if(J(this,Object.freeze(r.map((a,c)=>{const h=n[c];return h!=null&&i.get(h)===1?h:null}))),this.#t=[],this.#t==null&&this.#t,!s)return;Object.freeze(this);const u=new Proxy(this,{get:(a,c,h)=>{if(typeof c=="string"){if(c.match(/^[0-9]+$/)){const m=tt(c,"%index");if(m<0||m>=this.length)throw new RangeError("out of result range");const B=a[m];return B instanceof Error&&C(`index ${m}`,B),B}if(kt.indexOf(c)>=0)return Reflect.get(a,c,h);const w=a[c];if(w instanceof Function)return function(...m){return w.apply(this===h?a:this,m)};if(!(c in a))return a.getValue.apply(this===h?a:this,[c])}return Reflect.get(a,c,h)}});return J(u,R(this)),u}toArray(t){const e=[];return this.forEach((r,n)=>{r instanceof Error&&C(`index ${n}`,r),t&&r instanceof A&&(r=r.toArray(t)),e.push(r)}),e}toObject(t){const e=R(this);return e.reduce((r,n,s)=>(O(n!=null,`value at index ${s} unnamed`,"UNSUPPORTED_OPERATION",{operation:"toObject()"}),M(e,this,t)),{})}slice(t,e){t==null&&(t=0),t<0&&(t+=this.length,t<0&&(t=0)),e==null&&(e=this.length),e<0&&(e+=this.length,e<0&&(e=0)),e>this.length&&(e=this.length);const r=R(this),n=[],s=[];for(let i=t;i<e;i++)n.push(this[i]),s.push(r[i]);return new A(j,n,s)}filter(t,e){const r=R(this),n=[],s=[];for(let i=0;i<this.length;i++){const u=this[i];u instanceof Error&&C(`index ${i}`,u),t.call(e,u,i,this)&&(n.push(u),s.push(r[i]))}return new A(j,n,s)}map(t,e){const r=[];for(let n=0;n<this.length;n++){const s=this[n];s instanceof Error&&C(`index ${n}`,s),r.push(t.call(e,s,n,this))}return r}getValue(t){const e=R(this).indexOf(t);if(e===-1)return;const r=this[e];return r instanceof Error&&C(`property ${JSON.stringify(t)}`,r.error),r}static fromItems(t,e){return new A(j,t,e)}}function Y(l){let t=pt(l);return O(t.length<=p,"value out-of-bounds","BUFFER_OVERRUN",{buffer:t,length:p,offset:t.length}),t.length!==p&&(t=x(U([z.slice(t.length%p),t]))),t}class N{name;type;localName;dynamic;constructor(t,e,r,n){k(this,{name:t,type:e,localName:r,dynamic:n},{name:"string",type:"string",localName:"string",dynamic:"boolean"})}_throwError(t,e){g(!1,t,this.localName,e)}}class D{#t;#e;constructor(){this.#t=[],this.#e=0}get data(){return U(this.#t)}get length(){return this.#e}#r(t){return this.#t.push(t),this.#e+=t.length,t.length}appendWriter(t){return this.#r(x(t.data))}writeBytes(t){let e=x(t);const r=e.length%p;return r&&(e=x(U([e,z.slice(r)]))),this.#r(e)}writeValue(t){return this.#r(Y(t))}writeUpdatableValue(){const t=this.#t.length;return this.#t.push(z),this.#e+=p,e=>{this.#t[t]=Y(e)}}}class F{allowLoose;#t;#e;#r;#s;#n;constructor(t,e,r){k(this,{allowLoose:!!e}),this.#t=x(t),this.#r=0,this.#s=null,this.#n=r??1024,this.#e=0}get data(){return _(this.#t)}get dataLength(){return this.#t.length}get consumed(){return this.#e}get bytes(){return new Uint8Array(this.#t)}#i(t){if(this.#s)return this.#s.#i(t);this.#r+=t,O(this.#n<1||this.#r<=this.#n*this.dataLength,`compressed ABI data exceeds inflation ratio of ${this.#n} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`,"BUFFER_OVERRUN",{buffer:x(this.#t),offset:this.#e,length:t,info:{bytesRead:this.#r,dataLength:this.dataLength}})}#a(t,e,r){let n=Math.ceil(e/p)*p;return this.#e+n>this.#t.length&&(this.allowLoose&&r&&this.#e+e<=this.#t.length?n=e:O(!1,"data out-of-bounds","BUFFER_OVERRUN",{buffer:x(this.#t),length:this.#t.length,offset:this.#e+n})),this.#t.slice(this.#e,this.#e+n)}subReader(t){const e=new F(this.#t.slice(this.#e+t),this.allowLoose,this.#n);return e.#s=this,e}readBytes(t,e){let r=this.#a(0,t,!!e);return this.#i(t),this.#e+=r.length,r.slice(0,t)}readValue(){return ft(this.readBytes(p))}readIndex(){return dt(this.readBytes(p))}}const b={};function o(l,t){let e=!1;return t<0&&(e=!0,t*=-1),new d(b,`${e?"":"u"}int${t}`,l,{signed:e,width:t})}function f(l,t){return new d(b,`bytes${t||""}`,l,{size:t})}const Z=Symbol.for("_ethers_typed");class d{type;value;#t;_typedSymbol;constructor(t,e,r,n){n==null&&(n=null),et(b,t,"Typed"),k(this,{_typedSymbol:Z,type:e,value:r}),this.#t=n,this.format()}format(){if(this.type==="array")throw new Error("");if(this.type==="dynamicArray")throw new Error("");return this.type==="tuple"?`tuple(${this.value.map(t=>t.format()).join(",")})`:this.type}defaultValue(){return 0}minValue(){return 0}maxValue(){return 0}isBigInt(){return!!this.type.match(/^u?int[0-9]+$/)}isData(){return this.type.startsWith("bytes")}isString(){return this.type==="string"}get tupleName(){if(this.type!=="tuple")throw TypeError("not a tuple");return this.#t}get arrayLength(){if(this.type!=="array")throw TypeError("not an array");return this.#t===!0?-1:this.#t===!1?this.value.length:null}static from(t,e){return new d(b,t,e)}static uint8(t){return o(t,8)}static uint16(t){return o(t,16)}static uint24(t){return o(t,24)}static uint32(t){return o(t,32)}static uint40(t){return o(t,40)}static uint48(t){return o(t,48)}static uint56(t){return o(t,56)}static uint64(t){return o(t,64)}static uint72(t){return o(t,72)}static uint80(t){return o(t,80)}static uint88(t){return o(t,88)}static uint96(t){return o(t,96)}static uint104(t){return o(t,104)}static uint112(t){return o(t,112)}static uint120(t){return o(t,120)}static uint128(t){return o(t,128)}static uint136(t){return o(t,136)}static uint144(t){return o(t,144)}static uint152(t){return o(t,152)}static uint160(t){return o(t,160)}static uint168(t){return o(t,168)}static uint176(t){return o(t,176)}static uint184(t){return o(t,184)}static uint192(t){return o(t,192)}static uint200(t){return o(t,200)}static uint208(t){return o(t,208)}static uint216(t){return o(t,216)}static uint224(t){return o(t,224)}static uint232(t){return o(t,232)}static uint240(t){return o(t,240)}static uint248(t){return o(t,248)}static uint256(t){return o(t,256)}static uint(t){return o(t,256)}static int8(t){return o(t,-8)}static int16(t){return o(t,-16)}static int24(t){return o(t,-24)}static int32(t){return o(t,-32)}static int40(t){return o(t,-40)}static int48(t){return o(t,-48)}static int56(t){return o(t,-56)}static int64(t){return o(t,-64)}static int72(t){return o(t,-72)}static int80(t){return o(t,-80)}static int88(t){return o(t,-88)}static int96(t){return o(t,-96)}static int104(t){return o(t,-104)}static int112(t){return o(t,-112)}static int120(t){return o(t,-120)}static int128(t){return o(t,-128)}static int136(t){return o(t,-136)}static int144(t){return o(t,-144)}static int152(t){return o(t,-152)}static int160(t){return o(t,-160)}static int168(t){return o(t,-168)}static int176(t){return o(t,-176)}static int184(t){return o(t,-184)}static int192(t){return o(t,-192)}static int200(t){return o(t,-200)}static int208(t){return o(t,-208)}static int216(t){return o(t,-216)}static int224(t){return o(t,-224)}static int232(t){return o(t,-232)}static int240(t){return o(t,-240)}static int248(t){return o(t,-248)}static int256(t){return o(t,-256)}static int(t){return o(t,-256)}static bytes1(t){return f(t,1)}static bytes2(t){return f(t,2)}static bytes3(t){return f(t,3)}static bytes4(t){return f(t,4)}static bytes5(t){return f(t,5)}static bytes6(t){return f(t,6)}static bytes7(t){return f(t,7)}static bytes8(t){return f(t,8)}static bytes9(t){return f(t,9)}static bytes10(t){return f(t,10)}static bytes11(t){return f(t,11)}static bytes12(t){return f(t,12)}static bytes13(t){return f(t,13)}static bytes14(t){return f(t,14)}static bytes15(t){return f(t,15)}static bytes16(t){return f(t,16)}static bytes17(t){return f(t,17)}static bytes18(t){return f(t,18)}static bytes19(t){return f(t,19)}static bytes20(t){return f(t,20)}static bytes21(t){return f(t,21)}static bytes22(t){return f(t,22)}static bytes23(t){return f(t,23)}static bytes24(t){return f(t,24)}static bytes25(t){return f(t,25)}static bytes26(t){return f(t,26)}static bytes27(t){return f(t,27)}static bytes28(t){return f(t,28)}static bytes29(t){return f(t,29)}static bytes30(t){return f(t,30)}static bytes31(t){return f(t,31)}static bytes32(t){return f(t,32)}static address(t){return new d(b,"address",t)}static bool(t){return new d(b,"bool",!!t)}static bytes(t){return new d(b,"bytes",t)}static string(t){return new d(b,"string",t)}static array(t,e){throw new Error("not implemented yet")}static tuple(t,e){throw new Error("not implemented yet")}static overrides(t){return new d(b,"overrides",Object.assign({},t))}static isTyped(t){return t&&typeof t=="object"&&"_typedSymbol"in t&&t._typedSymbol===Z}static dereference(t,e){if(d.isTyped(t)){if(t.type!==e)throw new Error(`invalid type: expecetd ${e}, got ${t.type}`);return t.value}return t}}class Rt extends N{constructor(t){super("address","address",t,!1)}defaultValue(){return"0x0000000000000000000000000000000000000000"}encode(t,e){let r=d.dereference(e,"string");try{r=P(r)}catch(n){return this._throwError(n.message,e)}return t.writeValue(r)}decode(t){return P(yt(t.readValue(),20))}}class Ot extends N{coder;constructor(t){super(t.name,t.type,"_",t.dynamic),this.coder=t}defaultValue(){return this.coder.defaultValue()}encode(t,e){return this.coder.encode(t,e)}decode(t){return this.coder.decode(t)}}function st(l,t,e){let r=[];if(Array.isArray(e))r=e;else if(e&&typeof e=="object"){let a={};r=t.map(c=>{const h=c.localName;return O(h,"cannot encode object for signature with missing names","INVALID_ARGUMENT",{argument:"values",info:{coder:c},value:e}),O(!a[h],"cannot encode object for signature with duplicate names","INVALID_ARGUMENT",{argument:"values",info:{coder:c},value:e}),a[h]=!0,e[h]})}else g(!1,"invalid tuple value","tuple",e);g(t.length===r.length,"types/value length mismatch","tuple",e);let n=new D,s=new D,i=[];t.forEach((a,c)=>{let h=r[c];if(a.dynamic){let w=s.length;a.encode(s,h);let m=n.writeUpdatableValue();i.push(B=>{m(B+w)})}else a.encode(n,h)}),i.forEach(a=>{a(n.length)});let u=l.appendWriter(n);return u+=l.appendWriter(s),u}function it(l,t){let e=[],r=[],n=l.subReader(0);return t.forEach(s=>{let i=null;if(s.dynamic){let u=l.readIndex(),a=n.subReader(u);try{i=s.decode(a)}catch(c){if(K(c,"BUFFER_OVERRUN"))throw c;i=c,i.baseType=s.name,i.name=s.localName,i.type=s.type}}else try{i=s.decode(l)}catch(u){if(K(u,"BUFFER_OVERRUN"))throw u;i=u,i.baseType=s.name,i.name=s.localName,i.type=s.type}if(i==null)throw new Error("investigate");e.push(i),r.push(s.localName||null)}),A.fromItems(e,r)}class Bt extends N{coder;length;constructor(t,e,r){const n=t.type+"["+(e>=0?e:"")+"]",s=e===-1||t.dynamic;super("array",n,r,s),k(this,{coder:t,length:e})}defaultValue(){const t=this.coder.defaultValue(),e=[];for(let r=0;r<this.length;r++)e.push(t);return e}encode(t,e){const r=d.dereference(e,"array");Array.isArray(r)||this._throwError("expected array value",r);let n=this.length;n===-1&&(n=r.length,t.writeValue(r.length)),rt(r.length,n,"coder array"+(this.localName?" "+this.localName:""));let s=[];for(let i=0;i<r.length;i++)s.push(this.coder);return st(t,s,r)}decode(t){let e=this.length;e===-1&&(e=t.readIndex(),O(e*p<=t.dataLength,"insufficient data length","BUFFER_OVERRUN",{buffer:t.bytes,offset:e*p,length:t.dataLength}));let r=[];for(let n=0;n<e;n++)r.push(new Ot(this.coder));return it(t,r)}}class Tt extends N{constructor(t){super("bool","bool",t,!1)}defaultValue(){return!1}encode(t,e){const r=d.dereference(e,"bool");return t.writeValue(r?1:0)}decode(t){return!!t.readValue()}}class at extends N{constructor(t,e){super(t,t,e,!0)}defaultValue(){return"0x"}encode(t,e){e=x(e);let r=t.writeValue(e.length);return r+=t.writeBytes(e),r}decode(t){return t.readBytes(t.readIndex(),!0)}}class Vt extends at{constructor(t){super("bytes",t)}decode(t){return _(super.decode(t))}}class _t extends N{size;constructor(t,e){let r="bytes"+String(t);super(r,r,e,!1),k(this,{size:t},{size:"number"})}defaultValue(){return"0x0000000000000000000000000000000000000000000000000000000000000000".substring(0,2+this.size*2)}encode(t,e){let r=x(d.dereference(e,this.type));return r.length!==this.size&&this._throwError("incorrect data length",e),t.writeBytes(r)}decode(t){return _(t.readBytes(this.size))}}const $t=new Uint8Array([]);class Ct extends N{constructor(t){super("null","",t,!1)}defaultValue(){return null}encode(t,e){return e!=null&&this._throwError("not null",e),t.writeBytes($t)}decode(t){return t.readBytes(0),null}}const St=BigInt(0),It=BigInt(1),jt=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");class Lt extends N{size;signed;constructor(t,e,r){const n=(e?"int":"uint")+t*8;super(n,n,r,!1),k(this,{size:t,signed:e},{size:"number",signed:"boolean"})}defaultValue(){return 0}encode(t,e){let r=gt(d.dereference(e,this.type)),n=I(jt,p*8);if(this.signed){let s=I(n,this.size*8-1);(r>s||r<-(s+It))&&this._throwError("value out-of-bounds",e),r=wt(r,8*p)}else(r<St||r>I(n,this.size*8))&&this._throwError("value out-of-bounds",e);return t.writeValue(r)}decode(t){let e=I(t.readValue(),this.size*8);return this.signed&&(e=mt(e,this.size*8)),e}}class Pt extends at{constructor(t){super("string",t)}defaultValue(){return""}encode(t,e){return super.encode(t,Et(d.dereference(e,"string")))}decode(t){return bt(super.decode(t))}}class L extends N{coders;constructor(t,e){let r=!1;const n=[];t.forEach(i=>{i.dynamic&&(r=!0),n.push(i.type)});const s="tuple("+n.join(",")+")";super("tuple",s,e,r),k(this,{coders:Object.freeze(t.slice())})}defaultValue(){const t=[];this.coders.forEach(r=>{t.push(r.defaultValue())});const e=this.coders.reduce((r,n)=>{const s=n.localName;return s&&(r[s]||(r[s]=0),r[s]++),r},{});return this.coders.forEach((r,n)=>{let s=r.localName;!s||e[s]!==1||(s==="length"&&(s="_length"),t[s]==null&&(t[s]=t[n]))}),Object.freeze(t)}encode(t,e){const r=d.dereference(e,"tuple");return st(t,this.coders,r)}decode(t){return it(t,this.coders)}}function $(l){const t=new Set;return l.forEach(e=>t.add(e)),Object.freeze(t)}const vt="external public payable override";$(vt.split(" "));const ot="constant external internal payable private public pure view override";$(ot.split(" "));const ut="constructor error event fallback function receive struct";$(ut.split(" "));const lt="calldata memory storage payable indexed",Ut=$(lt.split(" ")),zt="tuple returns",Mt=[ut,lt,zt,ot].join(" "),Dt=$(Mt.split(" ")),Wt={"(":"OPEN_PAREN",")":"CLOSE_PAREN","[":"OPEN_BRACKET","]":"CLOSE_BRACKET",",":"COMMA","@":"AT"},Ft=new RegExp("^(\\s*)"),Kt=new RegExp("^([0-9]+)"),Jt=new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),Yt=new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),ct=new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");class S{#t;#e;get offset(){return this.#t}get length(){return this.#e.length-this.#t}constructor(t){this.#t=0,this.#e=t.slice()}clone(){return new S(this.#e)}reset(){this.#t=0}#r(t=0,e=0){return new S(this.#e.slice(t,e).map(r=>Object.freeze(Object.assign({},r,{match:r.match-t,linkBack:r.linkBack-t,linkNext:r.linkNext-t}))))}popKeyword(t){const e=this.peek();if(e.type!=="KEYWORD"||!t.has(e.text))throw new Error(`expected keyword ${e.text}`);return this.pop().text}popType(t){if(this.peek().type!==t){const e=this.peek();throw new Error(`expected ${t}; got ${e.type} ${JSON.stringify(e.text)}`)}return this.pop().text}popParen(){const t=this.peek();if(t.type!=="OPEN_PAREN")throw new Error("bad start");const e=this.#r(this.#t+1,t.match+1);return this.#t=t.match+1,e}popParams(){const t=this.peek();if(t.type!=="OPEN_PAREN")throw new Error("bad start");const e=[];for(;this.#t<t.match-1;){const r=this.peek().linkNext;e.push(this.#r(this.#t+1,r)),this.#t=r}return this.#t=t.match+1,e}peek(){if(this.#t>=this.#e.length)throw new Error("out-of-bounds");return this.#e[this.#t]}peekKeyword(t){const e=this.peekType("KEYWORD");return e!=null&&t.has(e)?e:null}peekType(t){if(this.length===0)return null;const e=this.peek();return e.type===t?e.text:null}pop(){const t=this.peek();return this.#t++,t}toString(){const t=[];for(let e=this.#t;e<this.#e.length;e++){const r=this.#e[e];t.push(`${r.type}:${r.text}`)}return`<TokenString ${t.join(" ")}>`}}function Zt(l){const t=[],e=i=>{const u=s<l.length?JSON.stringify(l[s]):"$EOI";throw new Error(`invalid token ${u} at ${s}: ${i}`)};let r=[],n=[],s=0;for(;s<l.length;){let i=l.substring(s),u=i.match(Ft);u&&(s+=u[1].length,i=l.substring(s));const a={depth:r.length,linkBack:-1,linkNext:-1,match:-1,type:"",text:"",offset:s,value:-1};t.push(a);let c=Wt[i[0]]||"";if(c){if(a.type=c,a.text=i[0],s++,c==="OPEN_PAREN")r.push(t.length-1),n.push(t.length-1);else if(c=="CLOSE_PAREN")r.length===0&&e("no matching open bracket"),a.match=r.pop(),t[a.match].match=t.length-1,a.depth--,a.linkBack=n.pop(),t[a.linkBack].linkNext=t.length-1;else if(c==="COMMA")a.linkBack=n.pop(),t[a.linkBack].linkNext=t.length-1,n.push(t.length-1);else if(c==="OPEN_BRACKET")a.type="BRACKET";else if(c==="CLOSE_BRACKET"){let h=t.pop().text;if(t.length>0&&t[t.length-1].type==="NUMBER"){const w=t.pop().text;h=w+h,t[t.length-1].value=tt(w)}if(t.length===0||t[t.length-1].type!=="BRACKET")throw new Error("missing opening bracket");t[t.length-1].text+=h}continue}if(u=i.match(Jt),u){if(a.text=u[1],s+=a.text.length,Dt.has(a.text)){a.type="KEYWORD";continue}if(a.text.match(ct)){a.type="TYPE";continue}a.type="ID";continue}if(u=i.match(Kt),u){a.text=u[1],a.type="NUMBER",s+=a.text.length;continue}throw new Error(`unexpected token ${JSON.stringify(i[0])} at position ${s}`)}return new S(t.map(i=>Object.freeze(i)))}function q(l,t){const e=new Set;for(;;){const r=l.peekType("KEYWORD");if(r==null||t&&!t.has(r))break;if(l.pop(),e.has(r))throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);e.add(r)}return Object.freeze(e)}const qt=new RegExp(/^(.*)\[([0-9]*)\]$/);function G(l){const t=l.match(ct);if(g(t,"invalid type","type",l),l==="uint")return"uint256";if(l==="int")return"int256";if(t[2]){const e=parseInt(t[2]);g(e!==0&&e<=32,"invalid bytes length","type",l)}else if(t[3]){const e=parseInt(t[3]);g(e!==0&&e<=256&&e%8===0,"invalid numeric width","type",l)}return l}const V={},H=Symbol.for("_ethers_internal"),X="_ParamTypeInternal";class y{name;type;baseType;indexed;components;arrayLength;arrayChildren;constructor(t,e,r,n,s,i,u,a){if(et(t,V,"ParamType"),Object.defineProperty(this,H,{value:X}),i&&(i=Object.freeze(i.slice())),n==="array"){if(u==null||a==null)throw new Error("")}else if(u!=null||a!=null)throw new Error("");if(n==="tuple"){if(i==null)throw new Error("")}else if(i!=null)throw new Error("");k(this,{name:e,type:r,baseType:n,indexed:s,components:i,arrayLength:u,arrayChildren:a})}format(t){if(t==null&&(t="sighash"),t==="json"){const r=this.name||"";if(this.isArray()){const s=JSON.parse(this.arrayChildren.format("json"));return s.name=r,s.type+=`[${this.arrayLength<0?"":String(this.arrayLength)}]`,JSON.stringify(s)}const n={type:this.baseType==="tuple"?"tuple":this.type,name:r};return typeof this.indexed=="boolean"&&(n.indexed=this.indexed),this.isTuple()&&(n.components=this.components.map(s=>JSON.parse(s.format(t)))),JSON.stringify(n)}let e="";return this.isArray()?(e+=this.arrayChildren.format(t),e+=`[${this.arrayLength<0?"":String(this.arrayLength)}]`):this.isTuple()?e+="("+this.components.map(r=>r.format(t)).join(t==="full"?", ":",")+")":e+=this.type,t!=="sighash"&&(this.indexed===!0&&(e+=" indexed"),t==="full"&&this.name&&(e+=" "+this.name)),e}isArray(){return this.baseType==="array"}isTuple(){return this.baseType==="tuple"}isIndexable(){return this.indexed!=null}walk(t,e){if(this.isArray()){if(!Array.isArray(t))throw new Error("invalid array value");if(this.arrayLength!==-1&&t.length!==this.arrayLength)throw new Error("array is wrong length");const r=this;return t.map(n=>r.arrayChildren.walk(n,e))}if(this.isTuple()){if(!Array.isArray(t))throw new Error("invalid tuple value");if(t.length!==this.components.length)throw new Error("array is wrong length");const r=this;return t.map((n,s)=>r.components[s].walk(n,e))}return e(this.type,t)}#t(t,e,r,n){if(this.isArray()){if(!Array.isArray(e))throw new Error("invalid array value");if(this.arrayLength!==-1&&e.length!==this.arrayLength)throw new Error("array is wrong length");const i=this.arrayChildren,u=e.slice();u.forEach((a,c)=>{i.#t(t,a,r,h=>{u[c]=h})}),n(u);return}if(this.isTuple()){const i=this.components;let u;if(Array.isArray(e))u=e.slice();else{if(e==null||typeof e!="object")throw new Error("invalid tuple value");u=i.map(a=>{if(!a.name)throw new Error("cannot use object value with unnamed components");if(!(a.name in e))throw new Error(`missing value for component ${a.name}`);return e[a.name]})}if(u.length!==this.components.length)throw new Error("array is wrong length");u.forEach((a,c)=>{i[c].#t(t,a,r,h=>{u[c]=h})}),n(u);return}const s=r(this.type,e);s.then?t.push(async function(){n(await s)}()):n(s)}async walkAsync(t,e){const r=[],n=[t];return this.#t(r,t,e,s=>{n[0]=s}),r.length&&await Promise.all(r),n[0]}static from(t,e){if(y.isParamType(t))return t;if(typeof t=="string")try{return y.from(Zt(t),e)}catch{g(!1,"invalid param type","obj",t)}else if(t instanceof S){let u="",a="",c=null;q(t,$(["tuple"])).has("tuple")||t.peekType("OPEN_PAREN")?(a="tuple",c=t.popParams().map(T=>y.from(T)),u=`tuple(${c.map(T=>T.format()).join(",")})`):(u=G(t.popType("TYPE")),a=u);let h=null,w=null;for(;t.length&&t.peekType("BRACKET");){const T=t.pop();h=new y(V,"",u,a,null,c,w,h),w=T.value,u+=T.text,a="array",c=null}let m=null;if(q(t,Ut).has("indexed")){if(!e)throw new Error("");m=!0}const ht=t.peekType("ID")?t.pop().text:"";if(t.length)throw new Error("leftover tokens");return new y(V,ht,u,a,m,c,w,h)}const r=t.name;g(!r||typeof r=="string"&&r.match(Yt),"invalid name","obj.name",r);let n=t.indexed;n!=null&&(g(e,"parameter cannot be indexed","obj.indexed",t.indexed),n=!!n);let s=t.type,i=s.match(qt);if(i){const u=parseInt(i[2]||"-1"),a=y.from({type:i[1],components:t.components});return new y(V,r||"",s,"array",n,null,u,a)}if(s==="tuple"||s.startsWith("tuple(")||s.startsWith("(")){const u=t.components!=null?t.components.map(c=>y.from(c)):null;return new y(V,r||"",s,"tuple",n,u,null,null)}return s=G(t.type),new y(V,r||"",s,s,n,null,null,null)}static isParamType(t){return t&&t[H]===X}}const E=new Map;E.set(0,"GENERIC_PANIC");E.set(1,"ASSERT_FALSE");E.set(17,"OVERFLOW");E.set(18,"DIVIDE_BY_ZERO");E.set(33,"ENUM_RANGE_ERROR");E.set(34,"BAD_STORAGE_DATA");E.set(49,"STACK_UNDERFLOW");E.set(50,"ARRAY_RANGE_ERROR");E.set(65,"OUT_OF_MEMORY");E.set(81,"UNINITIALIZED_FUNCTION_CALL");const Gt=new RegExp(/^bytes([0-9]*)$/),Ht=new RegExp(/^(u?int)([0-9]*)$/);let v=null,Q=1024;function Xt(l,t,e,r){let n="missing revert data",s=null;const i=null;let u=null;if(e){n="execution reverted";const c=xt(e);if(e=_(e),c.length===0)n+=" (no data present; likely require(false) occurred",s="require(false)";else if(c.length%32!==4)n+=" (could not decode reason; invalid data length)";else if(_(c.slice(0,4))==="0x08c379a0")try{s=r.decode(["string"],c.slice(4))[0],u={signature:"Error(string)",name:"Error",args:[s]},n+=`: ${JSON.stringify(s)}`}catch{n+=" (could not decode reason; invalid string data)"}else if(_(c.slice(0,4))==="0x4e487b71")try{const h=Number(r.decode(["uint256"],c.slice(4))[0]);u={signature:"Panic(uint256)",name:"Panic",args:[h]},s=`Panic due to ${E.get(h)||"UNKNOWN"}(${h})`,n+=`: ${s}`}catch{n+=" (could not decode panic code)"}else n+=" (unknown custom error)"}const a={to:t.to?P(t.to):null,data:t.data||"0x"};return t.from&&(a.from=P(t.from)),Nt(n,"CALL_EXCEPTION",{action:l,data:e,reason:s,transaction:a,invocation:i,revert:u})}class W{#t(t){if(t.isArray())return new Bt(this.#t(t.arrayChildren),t.arrayLength,t.name);if(t.isTuple())return new L(t.components.map(r=>this.#t(r)),t.name);switch(t.baseType){case"address":return new Rt(t.name);case"bool":return new Tt(t.name);case"string":return new Pt(t.name);case"bytes":return new Vt(t.name);case"":return new Ct(t.name)}let e=t.type.match(Ht);if(e){let r=parseInt(e[2]||"256");return g(r!==0&&r<=256&&r%8===0,"invalid "+e[1]+" bit length","param",t),new Lt(r/8,e[1]==="int",t.name)}if(e=t.type.match(Gt),e){let r=parseInt(e[1]);return g(r!==0&&r<=32,"invalid bytes length","param",t),new _t(r,t.name)}g(!1,"invalid type","type",t.type)}getDefaultValue(t){const e=t.map(n=>this.#t(y.from(n)));return new L(e,"_").defaultValue()}encode(t,e){rt(e.length,t.length,"types/values length mismatch");const r=t.map(i=>this.#t(y.from(i))),n=new L(r,"_"),s=new D;return n.encode(s,e),s.data}decode(t,e,r){const n=t.map(i=>this.#t(y.from(i)));return new L(n,"_").decode(new F(e,r,Q))}static _setDefaultMaxInflation(t){g(typeof t=="number"&&Number.isInteger(t),"invalid defaultMaxInflation factor","value",t),Q=t}static defaultAbiCoder(){return v==null&&(v=new W),v}static getBuiltinCallException(t,e,r){return Xt(t,e,r,W.defaultAbiCoder())}}const te={en:At.wordlist()};export{W as AbiCoder,ne as AbstractSigner,se as BaseWallet,ie as HDNodeVoidWallet,ae as HDNodeWallet,At as LangEn,oe as MessagePrefix,ue as Mnemonic,y as ParamType,A as Result,le as Signature,ce as SigningKey,he as Transaction,d as Typed,fe as TypedDataEncoder,de as Utf8ErrorFuncs,pe as VoidSigner,ye as Wordlist,ge as WordlistOwl,we as ZeroAddress,me as ZeroHash,Ee as accessListify,O as assert,g as assertArgument,rt as assertArgumentCount,be as assertNormalize,et as assertPrivate,xe as computeAddress,Ne as computeHmac,U as concat,Ae as copyRequest,ke as dataLength,Re as dataSlice,Oe as decodeBase58,Be as decodeRlp,Te as defaultPath,k as defineProperties,Ve as encodeBase58,_e as encodeRlp,$e as encryptKeystoreJson,Ce as encryptKeystoreJsonSync,mt as fromTwos,P as getAddress,gt as getBigInt,xt as getBytes,x as getBytesCopy,tt as getNumber,Se as getUint,Ie as hashMessage,_ as hexlify,je as id,Le as isAddressable,Pe as isBytesLike,K as isError,ve as isHexString,Ue as keccak256,Nt as makeError,I as mask,ze as pbkdf2,Me as randomBytes,De as recoverAddress,We as resolveAddress,Fe as resolveProperties,Ke as ripemd160,Je as scrypt,Ye as scryptSync,Ze as sha256,pt as toBeArray,yt as toBeHex,ft as toBigInt,dt as toNumber,qe as toQuantity,wt as toTwos,Et as toUtf8Bytes,bt as toUtf8String,Ge as uuidV4,He as version,te as wordlists,Xe as zeroPadValue};
