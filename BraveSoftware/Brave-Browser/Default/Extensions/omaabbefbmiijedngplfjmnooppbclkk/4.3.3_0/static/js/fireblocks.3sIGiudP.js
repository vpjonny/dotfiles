import{bc as z,bd as bt}from"./main.D-W_HyrW.js";/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const R={p:0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedn,n:0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3edn,a:0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffecn,d:0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3n,Gx:0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,Gy:0x6666666666666666666666666666666666666666666666666666666666666658n},{p:h,n:Y,Gx:j,Gy:W,a:C,d:F}=R,wt=8n,ft=32,gt=64,b=(t="")=>{throw new Error(t)},mt=t=>typeof t=="bigint",ct=t=>typeof t=="string",Bt=t=>t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array",v=(t,n)=>!Bt(t)||typeof n=="number"&&n>0&&t.length!==n?b("Uint8Array expected"):t,H=t=>new Uint8Array(t),O=t=>Uint8Array.from(t),it=(t,n)=>t.toString(16).padStart(n,"0"),V=t=>Array.from(v(t)).map(n=>it(n,2)).join(""),m={_0:48,_9:57,A:65,F:70,a:97,f:102},k=t=>{if(t>=m._0&&t<=m._9)return t-m._0;if(t>=m.A&&t<=m.F)return t-(m.A-10);if(t>=m.a&&t<=m.f)return t-(m.a-10)},I=t=>{const n="hex invalid";if(!ct(t))return b(n);const e=t.length,o=e/2;if(e%2)return b(n);const f=H(o);for(let r=0,c=0;r<o;r++,c+=2){const a=k(t.charCodeAt(c)),i=k(t.charCodeAt(c+1));if(a===void 0||i===void 0)return b(n);f[r]=a*16+i}return f},At=(t,n)=>v(ct(t)?I(t):O(v(t)),n),at=()=>globalThis?.crypto,Et=()=>at()?.subtle??b("crypto.subtle must be defined"),J=(...t)=>{const n=H(t.reduce((o,f)=>o+v(f).length,0));let e=0;return t.forEach(o=>{n.set(o,e),e+=o.length}),n},_t=(t=ft)=>at().getRandomValues(H(t)),S=BigInt,A=(t,n,e,o="bad number: out of range")=>mt(t)&&n<=t&&t<e?t:b(o),s=(t,n=h)=>{const e=t%n;return e>=0n?e:n+e},ut=(t,n)=>{(t===0n||n<=0n)&&b("no inverse n="+t+" mod="+n);let e=s(t,n),o=n,f=0n,r=1n;for(;e!==0n;){const c=o/e,a=o%e,i=f-r*c;o=e,e=a,f=r,r=i}return o===1n?s(f,n):b("no inverse")},Q=t=>t instanceof p?t:b("Point expected"),G=2n**256n;class p{static BASE;static ZERO;ex;ey;ez;et;constructor(n,e,o,f){const r=G;this.ex=A(n,0n,r),this.ey=A(e,0n,r),this.ez=A(o,1n,r),this.et=A(f,0n,r),Object.freeze(this)}static fromAffine(n){return new p(n.x,n.y,1n,s(n.x*n.y))}static fromBytes(n,e=!1){const o=F,f=O(v(n,ft)),r=n[31];f[31]=r&-129;const c=vt(f);A(c,0n,e?G:h);const i=s(c*c),u=s(i-1n),d=s(o*i+1n);let{isValid:y,value:l}=Ut(u,d);y||b("bad point: y not sqrt");const x=(l&1n)===1n,w=(r&128)!==0;return!e&&l===0n&&w&&b("bad point: x==0, isLastByteOdd"),w!==x&&(l=s(-l)),new p(l,c,1n,s(l*c))}assertValidity(){const n=C,e=F,o=this;if(o.is0())throw new Error("bad point: ZERO");const{ex:f,ey:r,ez:c,et:a}=o,i=s(f*f),u=s(r*r),d=s(c*c),y=s(d*d),l=s(i*n),x=s(d*s(l+u)),w=s(y+s(e*s(i*u)));if(x!==w)throw new Error("bad point: equation left != right (1)");const E=s(f*r),_=s(c*a);if(E!==_)throw new Error("bad point: equation left != right (2)");return this}equals(n){const{ex:e,ey:o,ez:f}=this,{ex:r,ey:c,ez:a}=Q(n),i=s(e*a),u=s(r*f),d=s(o*a),y=s(c*f);return i===u&&d===y}is0(){return this.equals(T)}negate(){return new p(s(-this.ex),this.ey,this.ez,s(-this.et))}double(){const{ex:n,ey:e,ez:o}=this,f=C,r=s(n*n),c=s(e*e),a=s(2n*s(o*o)),i=s(f*r),u=n+e,d=s(s(u*u)-r-c),y=i+c,l=y-a,x=i-c,w=s(d*l),E=s(y*x),_=s(d*x),U=s(l*y);return new p(w,E,U,_)}add(n){const{ex:e,ey:o,ez:f,et:r}=this,{ex:c,ey:a,ez:i,et:u}=Q(n),d=C,y=F,l=s(e*c),x=s(o*a),w=s(r*y*u),E=s(f*i),_=s((e+o)*(c+a)-l-x),U=s(E-w),M=s(E+w),K=s(x-d*l),lt=s(_*U),ht=s(M*K),pt=s(_*K),xt=s(U*M);return new p(lt,ht,xt,pt)}multiply(n,e=!0){if(!e&&(n===0n||this.is0()))return T;if(A(n,1n,Y),n===1n)return this;if(this.equals(Z))return St(n).p;let o=T,f=Z;for(let r=this;n>0n;r=r.double(),n>>=1n)n&1n?o=o.add(r):e&&(f=f.add(r));return o}toAffine(){const{ex:n,ey:e,ez:o}=this;if(this.equals(T))return{x:0n,y:1n};const f=ut(o,h);return s(o*f)!==1n&&b("invalid inverse"),{x:s(n*f),y:s(e*f)}}toBytes(){const{x:n,y:e}=this.assertValidity().toAffine(),o=Tt(e);return o[31]|=n&1n?128:0,o}toHex(){return V(this.toBytes())}clearCofactor(){return this.multiply(S(wt),!1)}isSmallOrder(){return this.clearCofactor().is0()}isTorsionFree(){let n=this.multiply(Y/2n,!1).double();return Y%2n&&(n=n.add(this)),n.is0()}static fromHex(n,e){return p.fromBytes(At(n),e)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}toRawBytes(){return this.toBytes()}}const Z=new p(j,W,1n,s(j*W)),T=new p(0n,1n,1n,0n);p.BASE=Z;p.ZERO=T;const Tt=t=>I(it(A(t,0n,G),gt)).reverse(),vt=t=>S("0x"+V(O(v(t)).reverse())),g=(t,n)=>{let e=t;for(;n-- >0n;)e*=e,e%=h;return e},Zt=t=>{const e=t*t%h*t%h,o=g(e,2n)*e%h,f=g(o,1n)*t%h,r=g(f,5n)*f%h,c=g(r,10n)*r%h,a=g(c,20n)*c%h,i=g(a,40n)*a%h,u=g(i,80n)*i%h,d=g(u,80n)*i%h,y=g(d,10n)*r%h;return{pow_p_5_8:g(y,2n)*t%h,b2:e}},P=0x2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0n,Ut=(t,n)=>{const e=s(n*n*n),o=s(e*e*n),f=Zt(t*o).pow_p_5_8;let r=s(t*e*f);const c=s(n*r*r),a=r,i=s(r*P),u=c===t,d=c===s(-t),y=c===s(-t*P);return u&&(r=a),(d||y)&&(r=i),(s(r)&1n)===1n&&(r=s(-r)),{isValid:u||d,value:r}},q={sha512Async:async(...t)=>{const n=Et(),e=J(...t);return H(await n.digest("SHA-512",e.buffer))},sha512Sync:void 0,bytesToHex:V,hexToBytes:I,concatBytes:J,mod:s,invert:ut,randomBytes:_t},X=8,Rt=256,dt=Math.ceil(Rt/X)+1,L=2**(X-1),zt=()=>{const t=[];let n=Z,e=n;for(let o=0;o<dt;o++){e=n,t.push(e);for(let f=1;f<L;f++)e=e.add(n),t.push(e);n=e.double()}return t};let tt;const nt=(t,n)=>{const e=n.negate();return t?e:n},St=t=>{const n=tt||(tt=zt());let e=T,o=Z;const f=2**X,r=f,c=S(f-1),a=S(X);for(let i=0;i<dt;i++){let u=Number(t&c);t>>=a,u>L&&(u-=r,t+=1n);const d=i*L,y=d,l=d+Math.abs(u)-1,x=i%2!==0,w=u<0;u===0?o=o.add(nt(x,n[y])):e=e.add(nt(w,n[l]))}return{p:e,f:o}};/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Xt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function $(t,...n){if(!Xt(t))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(t.length))throw new Error("Uint8Array expected of length "+n+", got length="+t.length)}const yt=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ht=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function Yt(t){if($(t),yt)return t.toHex();let n="";for(let e=0;e<t.length;e++)n+=Ht[t[e]];return n}const B={_0:48,_9:57,A:65,F:70,a:97,f:102};function et(t){if(t>=B._0&&t<=B._9)return t-B._0;if(t>=B.A&&t<=B.F)return t-(B.A-10);if(t>=B.a&&t<=B.f)return t-(B.a-10)}function Ct(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(yt)return Uint8Array.fromHex(t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const o=new Uint8Array(e);for(let f=0,r=0;f<e;f++,r+=2){const c=et(t.charCodeAt(r)),a=et(t.charCodeAt(r+1));if(c===void 0||a===void 0){const i=t[r]+t[r+1];throw new Error('hex string expected, got non-hex character "'+i+'" at index '+r)}o[f]=c*16+a}return o}function N(...t){let n=0;for(let o=0;o<t.length;o++){const f=t[o];$(f),n+=f.length}const e=new Uint8Array(n);for(let o=0,f=0;o<t.length;o++){const r=t[o];e.set(r,f),f+=r.length}return e}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ft=BigInt(0);function D(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Ft:BigInt("0x"+t)}function ot(t){return $(t),D(Yt(Uint8Array.from(t).reverse()))}function qt(t,n){return Ct(t.toString(16).padStart(n*2,"0"))}function st(t,n){return qt(t,n).reverse()}async function Nt(t,n){const e=D(n),o=st(e,32),f=N(t),r=z.Buffer.from(n,"hex"),c=await rt(r,o,f),a=q.mod(ot(c),R.n),u=p.BASE.multiply(a).toRawBytes(),d=Gt(n),y=await rt(u,d,f),l=q.mod(ot(y),R.n),x=q.mod(l*e+a,R.n);return z.Buffer.from(N(u,st(x,32)))}function Gt(t){const n=D(t),e=p.BASE.multiply(n);return z.Buffer.from(e.toRawBytes())}const rt=async(...t)=>{const n=N(...t);return bt.sha512(z.Buffer.from(n))};export{Gt as fireblocksSecretToPublicKey,Nt as signWithFireblocksKey};
