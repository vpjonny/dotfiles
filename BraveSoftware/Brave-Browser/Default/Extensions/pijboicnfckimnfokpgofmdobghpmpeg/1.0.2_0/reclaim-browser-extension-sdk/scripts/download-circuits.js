const fs=require("fs"),path=require("path"),https=require("https"),REPO="reclaimprotocol/zk-symmetric-crypto",TARGET_DIR=path.join(process.cwd(),"public","browser-rpc","resources"),TEMP_DIR=path.join(process.cwd(),"zk-resources");function getLatestCommitHash(){return new Promise((e,t)=>{const o=`https://api.github.com/repos/${REPO}/commits/HEAD`,r=https.get(o,{headers:{"User-Agent":"Node.js"}},o=>{let r="";o.on("data",e=>r+=e),o.on("end",()=>{try{const o=JSON.parse(r);o.sha?e(o.sha):t(new Error("No SHA found in GitHub API response"))}catch(e){t(new Error(`Failed to parse GitHub API response: ${e.message}`))}})});r.on("error",t),r.setTimeout(1e4,()=>{r.destroy(),t(new Error("Timeout fetching latest commit hash"))})})}function getFileSize(e,t,o=null){return o||(o=`https://github.com/${REPO}/raw/${t}/resources/${e}`),new Promise((r,s)=>{const n=https.request(o,{method:"HEAD"},o=>{if([301,302].includes(o.statusCode)&&o.headers.location)return r(getFileSize(e,t,o.headers.location));const s=parseInt(o.headers["content-length"],10);r(isNaN(s)?0:s)});n.on("error",s),n.end()})}async function downloadFile(e,t,o,r,s=null,n=3){s||(s=`https://github.com/${REPO}/raw/${r}/resources/${e}`);const a=path.dirname(t);await fs.promises.mkdir(a,{recursive:!0});for(let a=1;a<=n;a++)try{return await new Promise((n,a)=>{const i=fs.createWriteStream(t),c=https.get(s,s=>{if([301,302].includes(s.statusCode)&&s.headers.location)return downloadFile(e,t,o,r,s.headers.location).then(n).catch(a);s.on("data",e=>{o(e.length)}),s.pipe(i),i.on("finish",()=>{i.close(n)})});c.on("error",e=>{fs.unlink(t,()=>a(e))}),c.setTimeout(3e4,()=>{c.destroy(),a(new Error(`Timeout downloading ${e}`))})})}catch(t){if(a===n)throw new Error(`Failed to download ${e} after ${n} attempts: ${t.message}`);console.log(`\nRetry ${a}/${n} for ${e}: ${t.message}`),await new Promise(e=>setTimeout(e,1e3*Math.pow(2,a)))}}function formatBytes(e){const t=["B","KB","MB","GB"];let o=0;for(;e>=1024&&o<t.length-1;)e/=1024,o++;return`${e.toFixed(1)} ${t[o]}`}function renderProgress(e,t,o,r,s,n){const a=Math.min(r>0?o/r:0,1),i=Math.round(25*a),c=Math.max(0,25-i),l="â–ˆ".repeat(i)+"â–‘".repeat(c),d=s>0?Math.max(0,r-o)/s:0,m=(100*a).toFixed(1).padStart(5),p=`${formatBytes(s)}/s`,h=isFinite(d)?`${Math.round(d)}s`.padStart(4):"--";return`[${e.toString().padStart(2)}/${t}] ${m}% [${l}] Speed: ${p} Time Left: ${h} | ${n}`}async function main(){try{console.log("ðŸ”„ Fetching latest commit hash...");const e=await getLatestCommitHash();console.log(`ðŸ“ Using commit: ${e}`),await fs.promises.mkdir(TARGET_DIR,{recursive:!0});const t=["circuit_final.zkey","circuit.wasm","circuit.r1cs"],o=[...["chacha20","aes-256-ctr","aes-128-ctr"].flatMap(e=>t.map(t=>`snarkjs/${e}/${t}`))];if(await Promise.all(o.map(async e=>{try{return await fs.promises.access(path.join(TARGET_DIR,e)),!0}catch{return!1}})).then(e=>e.every(e=>e)))return console.log("ZK files already exist in target directory, skipping download."),void process.exit(0);await fs.promises.rm(TEMP_DIR,{recursive:!0,force:!0}),await fs.promises.mkdir(TEMP_DIR,{recursive:!0}),console.log("ðŸ“¦ Downloading ZK files ");const r=o.length;console.log("ðŸ” Fetching file information... please wait");let s={},n=0;for(const t of o)try{const o=await getFileSize(t,e);s[t]=o,n+=o}catch(e){s[t]=0}let a=0,i=0;const c=Date.now();process.stdout.write("[?25l");for(const t of o){const o=path.join(TEMP_DIR,t);let s=0;await downloadFile(t,o,e=>{s+=e,i+=e;const o=(Date.now()-c)/1e3,l=renderProgress(a,r,i,n,o>0?i/o:0,path.basename(t));process.stdout.write("\r[K"+l)},e),a++;const l=(Date.now()-c)/1e3,d=renderProgress(a,r,i,n,l>0?i/l:0,path.basename(t));process.stdout.write("\r[K"+d)}process.stdout.write("[?25h\n"),console.log("\nMoving files to final location..."),await fs.promises.rm(TARGET_DIR,{recursive:!0,force:!0}),await fs.promises.rename(TEMP_DIR,TARGET_DIR),console.log("Download completed successfully!"),process.exit(0)}catch(e){process.stdout.write("[?25h\n"),console.error("\nFatal error during download:",e),await fs.promises.rm(TEMP_DIR,{recursive:!0,force:!0}),process.exit(1)}}process.on("unhandledRejection",e=>{console.error("Unhandled promise rejection:",e),process.exit(1)}),main();