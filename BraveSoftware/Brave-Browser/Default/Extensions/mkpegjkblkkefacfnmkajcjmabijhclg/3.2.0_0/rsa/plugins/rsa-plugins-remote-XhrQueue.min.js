import{k as e,s as a,m as t,r as s,g as n,w as r,n as l,o,d as u,y as i,L as d,v as c,z as m}from"./rsa-plugins-common.min.js";import{R as v}from"./rsa-plugins-RetryQueue.min.js";const p={maxRetryDelay:36e4,minRetryDelay:1e3,backoffFactor:2,maxAttempts:10,maxItems:100},h="v1",y=(e,t,s)=>a({batch:e,sentAt:t},!0,void 0,s),$=(e,a)=>{const t=new URL(e);return new URL(s([t.pathname,"/",h,"/",a].join("")),t).href},f=(a,t,s,l,o,u)=>{if(n(null==a?void 0:a.error)||n(u))return;const i=r(a);let d=((a,t)=>`${a}${e}Failed to deliver event(s) to ${t}.`)("XhrQueuePlugin",t);const c="The event(s) will be dropped.";i?s?(d=`${d} It/they will be retried.`,l>0&&(d=`${d} Retry attempt ${l} of ${o}.`)):d=`${d} Retries exhausted (${o}). ${c}`:d=`${d} ${c}`,null==u||u.error(d)},R=(e,a,t)=>{let s,n,r;const d=l();if(Array.isArray(e)){const l=e.map((e=>o(e.event,d)));s=y(l,d,t),n=e[0]?u(e[0].headers):{},c=a.lifecycle.activeDataplaneUrl.value,r=$(c,"batch")}else{const{url:a,event:l,headers:c}=e,m=o(l,d);s=i(m,t),n=u(c),r=a}var c;return{data:s,headers:n,url:r}},g="XhrQueue",w=()=>({name:g,deps:[],initialize:e=>{e.plugins.loadedPlugins.value=[...e.plugins.loadedPlugins.value,g]},dataplaneEventsQueue:{init(e,a,s,n,o){const u=e.lifecycle.writeKey.value;a.setAuthHeader(u);const i=(c=e.loadOptions.value.queueOptions,t(p,c));var c;return new v(`rudder_${u}`,i,((t,s,n,l,u)=>{const{data:i,url:d,headers:c}=R(t,e,o);a.getAsyncData({url:d,options:{method:"POST",headers:c,data:i,sendRawData:!0},isRawResponse:!0,timeout:3e4,callback:(e,a)=>{const t=r(a)?a:null;f(a,d,u,n,l,o),s(t,e)}})}),s,d,o,(e=>{var a;const t=l(),s=e.map((e=>e.event));return null===(a=y(s,t,o))||void 0===a?void 0:a.length}))},enqueue(e,a,t,s,n){t.sentAt=l(),c(t,n);const r=e.lifecycle.activeDataplaneUrl.value,o=$(r,t.type),u={AnonymousId:m(t.anonymousId)};a.addItem({url:o,headers:u,event:t})}}});export{w as XhrQueue,w as default};
//# sourceMappingURL=rsa-plugins-remote-XhrQueue.min.js.map
