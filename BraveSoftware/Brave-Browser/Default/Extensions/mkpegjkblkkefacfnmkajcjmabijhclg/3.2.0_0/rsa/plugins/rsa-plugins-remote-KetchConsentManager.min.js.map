{"version":3,"file":"rsa-plugins-remote-KetchConsentManager.min.js","sources":["../../../../src/ketchConsentManager/logMessages.ts","../../../../src/ketchConsentManager/constants.ts","../../../../src/ketchConsentManager/utils.ts","../../../../src/ketchConsentManager/index.ts"],"sourcesContent":["import { LOG_CONTEXT_SEPARATOR } from '@rudderstack/analytics-js-common/constants/logMessages';\n\nconst KETCH_CONSENT_COOKIE_READ_ERROR = (context: string): string =>\n  `${context}${LOG_CONTEXT_SEPARATOR}Failed to read the consent cookie.`;\n\nconst KETCH_CONSENT_COOKIE_PARSE_ERROR = (context: string): string =>\n  `${context}${LOG_CONTEXT_SEPARATOR}Failed to parse the consent cookie.`;\n\nconst DESTINATION_CONSENT_STATUS_ERROR = `Failed to determine the consent status for the destination. Please check the destination configuration and try again.`;\n\nexport {\n  KETCH_CONSENT_COOKIE_READ_ERROR,\n  KETCH_CONSENT_COOKIE_PARSE_ERROR,\n  DESTINATION_CONSENT_STATUS_ERROR,\n};\n","const KETCH_CONSENT_MANAGER_PLUGIN = 'KetchConsentManagerPlugin';\nconst KETCH_CONSENT_COOKIE_NAME_V1 = '_ketch_consent_v1_';\n\nexport { KETCH_CONSENT_MANAGER_PLUGIN, KETCH_CONSENT_COOKIE_NAME_V1 };\n","/* eslint-disable no-param-reassign */\nimport type { IStoreManager } from '@rudderstack/analytics-js-common/types/Store';\nimport type { ILogger } from '@rudderstack/analytics-js-common/types/Logger';\nimport type { ApplicationState } from '@rudderstack/analytics-js-common/types/ApplicationState';\nimport type { ConsentsInfo } from '@rudderstack/analytics-js-common/types/Consent';\nimport { isDefined } from '@rudderstack/analytics-js-common/utilities/checks';\nimport { checks, storages, string } from '../shared-chunks/common';\nimport { KETCH_CONSENT_COOKIE_PARSE_ERROR, KETCH_CONSENT_COOKIE_READ_ERROR } from './logMessages';\nimport { KETCH_CONSENT_COOKIE_NAME_V1, KETCH_CONSENT_MANAGER_PLUGIN } from './constants';\nimport type { KetchConsentCookieData, KetchConsentData } from './types';\n\n/**\n * Gets the consent data from the Ketch's consent cookie\n * @param storeManager Store manager instance\n * @param logger Logger instance\n * @returns Consent data from the consent cookie\n */\nconst getKetchConsentData = (\n  storeManager?: IStoreManager,\n  logger?: ILogger,\n): KetchConsentData | undefined => {\n  let rawConsentCookieData = null;\n  try {\n    // Create a data store instance to read the consent cookie\n    const dataStore = storeManager?.setStore({\n      id: KETCH_CONSENT_MANAGER_PLUGIN,\n      name: KETCH_CONSENT_MANAGER_PLUGIN,\n      type: storages.COOKIE_STORAGE,\n    });\n    rawConsentCookieData = dataStore?.engine.getItem(KETCH_CONSENT_COOKIE_NAME_V1);\n  } catch (err) {\n    logger?.error(KETCH_CONSENT_COOKIE_READ_ERROR(KETCH_CONSENT_MANAGER_PLUGIN), err);\n    return undefined;\n  }\n\n  if (checks.isNullOrUndefined(rawConsentCookieData)) {\n    return undefined;\n  }\n\n  // Decode and parse the cookie data to JSON\n  let consentCookieData: KetchConsentCookieData;\n  try {\n    consentCookieData = JSON.parse(string.fromBase64(rawConsentCookieData as string));\n  } catch (err) {\n    logger?.error(KETCH_CONSENT_COOKIE_PARSE_ERROR(KETCH_CONSENT_MANAGER_PLUGIN), err);\n    return undefined;\n  }\n\n  if (!consentCookieData) {\n    return undefined;\n  }\n\n  // Convert the cookie data to consent data\n  const consentPurposes: KetchConsentData = {};\n  Object.entries(consentCookieData).forEach(pEntry => {\n    const purposeCode = pEntry[0];\n    const purposeValue = pEntry[1];\n    consentPurposes[purposeCode] = purposeValue?.status === 'granted';\n  });\n  return consentPurposes;\n};\n\n/**\n * Gets the consent data in the format expected by the application state\n * @param ketchConsentData Consent data derived from the consent cookie\n * @returns Consent data\n */\nconst getConsentData = (ketchConsentData?: KetchConsentData): ConsentsInfo => {\n  const allowedConsentIds: string[] = [];\n  const deniedConsentIds: string[] = [];\n  if (ketchConsentData) {\n    Object.entries(ketchConsentData).forEach(e => {\n      const purposeCode = e[0];\n      const isConsented = e[1];\n      if (isConsented) {\n        allowedConsentIds.push(purposeCode);\n      } else {\n        deniedConsentIds.push(purposeCode);\n      }\n    });\n  }\n\n  return { allowedConsentIds, deniedConsentIds };\n};\n\nconst updateConsentStateFromData = (\n  state: ApplicationState,\n  ketchConsentData: KetchConsentData,\n) => {\n  const consentData = getConsentData(ketchConsentData);\n  state.consents.initialized.value = isDefined(ketchConsentData);\n  state.consents.data.value = consentData;\n};\n\nexport { getKetchConsentData, getConsentData, updateConsentStateFromData };\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-param-reassign */\nimport type { ApplicationState } from '@rudderstack/analytics-js-common/types/ApplicationState';\nimport type { ExtensionPlugin } from '@rudderstack/analytics-js-common/types/PluginEngine';\nimport type { IStoreManager } from '@rudderstack/analytics-js-common/types/Store';\nimport type { ILogger } from '@rudderstack/analytics-js-common/types/Logger';\nimport type { DestinationConfig } from '@rudderstack/analytics-js-common/types/Destination';\nimport type { IErrorHandler } from '@rudderstack/analytics-js-common/types/ErrorHandler';\nimport type { PluginName } from '@rudderstack/analytics-js-common/types/PluginsManager';\nimport { checks } from '../shared-chunks/common';\nimport { DESTINATION_CONSENT_STATUS_ERROR } from './logMessages';\nimport { KETCH_CONSENT_MANAGER_PLUGIN } from './constants';\nimport type { KetchConsentData } from './types';\nimport { getKetchConsentData, updateConsentStateFromData } from './utils';\n\nconst pluginName: PluginName = 'KetchConsentManager';\n\nconst KetchConsentManager = (): ExtensionPlugin => ({\n  name: pluginName,\n  deps: [],\n  initialize: (state: ApplicationState) => {\n    state.plugins.loadedPlugins.value = [...state.plugins.loadedPlugins.value, pluginName];\n  },\n  consentManager: {\n    init(state: ApplicationState, logger?: ILogger): void {\n      // getKetchUserConsentedPurposes returns current ketch opted-in purposes\n      // This will be helpful for debugging\n      (globalThis as any).getKetchUserConsentedPurposes = () =>\n        (state.consents.data.value.allowedConsentIds as string[])?.slice();\n\n      // getKetchUserDeniedPurposes returns current ketch opted-out purposes\n      // This will be helpful for debugging\n      (globalThis as any).getKetchUserDeniedPurposes = () =>\n        (state.consents.data.value.deniedConsentIds as string[])?.slice();\n\n      // updateKetchConsent callback function to update current consent purpose state\n      // this will be called from ketch rudderstack plugin\n      (globalThis as any).updateKetchConsent = (ketchConsentData: KetchConsentData) => {\n        updateConsentStateFromData(state, ketchConsentData);\n      };\n    },\n\n    updateConsentsInfo(\n      state: ApplicationState,\n      storeManager?: IStoreManager,\n      logger?: ILogger,\n    ): void {\n      // retrieve consent data and update the state\n      let ketchConsentData;\n      if (!checks.isUndefined((globalThis as any).ketchConsent)) {\n        ketchConsentData = (globalThis as any).ketchConsent;\n      } else {\n        ketchConsentData = getKetchConsentData(storeManager, logger);\n      }\n\n      updateConsentStateFromData(state, ketchConsentData);\n    },\n\n    isDestinationConsented(\n      state: ApplicationState,\n      destConfig: DestinationConfig,\n      errorHandler?: IErrorHandler,\n      logger?: ILogger,\n    ): boolean {\n      if (!state.consents.initialized.value) {\n        return true;\n      }\n\n      const allowedConsentIds = state.consents.data.value.allowedConsentIds as string[];\n\n      try {\n        const { ketchConsentPurposes, consentManagement } = destConfig;\n        const matchPredicate = (consent: string) => allowedConsentIds.includes(consent);\n\n        // Generic consent management\n        if (consentManagement) {\n          // Get the corresponding consents for the destination\n          const cmpConsents = consentManagement.find(\n            c => c.provider === state.consents.provider.value,\n          )?.consents;\n\n          // If there are no consents configured for the destination for the current provider, events should be sent.\n          if (!cmpConsents) {\n            return true;\n          }\n\n          const configuredConsents = cmpConsents.map(c => c.consent.trim()).filter(n => n);\n\n          // match the configured consents with user provided consents as per\n          // the configured resolution strategy\n          switch (state.consents.resolutionStrategy.value) {\n            case 'or':\n              return configuredConsents.some(matchPredicate) || configuredConsents.length === 0;\n            case 'and':\n            default:\n              return configuredConsents.every(matchPredicate);\n          }\n\n          // Legacy cookie consent management\n          // TODO: To be removed once the source config API is updated to support generic consent management\n        } else if (ketchConsentPurposes) {\n          const configuredConsents = ketchConsentPurposes.map(p => p.purpose.trim()).filter(n => n);\n\n          // Check if any of the destination's mapped ketch purposes are consented by the user in the browser.\n          return configuredConsents.some(matchPredicate) || configuredConsents.length === 0;\n        }\n\n        // If there are no consents configured for the destination for the current provider, events should be sent.\n        return true;\n      } catch (err) {\n        errorHandler?.onError(err, KETCH_CONSENT_MANAGER_PLUGIN, DESTINATION_CONSENT_STATUS_ERROR);\n        return true;\n      }\n    },\n  },\n});\n\nexport { KetchConsentManager };\n\nexport default KetchConsentManager;\n"],"names":["KETCH_CONSENT_MANAGER_PLUGIN","getKetchConsentData","storeManager","logger","rawConsentCookieData","dataStore","setStore","id","name","type","storages","engine","getItem","err","error","context","LOG_CONTEXT_SEPARATOR","checks","consentCookieData","JSON","parse","string","KETCH_CONSENT_COOKIE_PARSE_ERROR","consentPurposes","Object","entries","forEach","pEntry","purposeCode","purposeValue","status","updateConsentStateFromData","state","ketchConsentData","consentData","allowedConsentIds","deniedConsentIds","e","push","getConsentData","consents","initialized","value","isDefined","data","pluginName","KetchConsentManager","deps","initialize","plugins","loadedPlugins","consentManager","init","globalThis","getKetchUserConsentedPurposes","_state$consents$data$","slice","getKetchUserDeniedPurposes","_state$consents$data$2","updateKetchConsent","updateConsentsInfo","ketchConsent","isDestinationConsented","destConfig","errorHandler","ketchConsentPurposes","consentManagement","matchPredicate","consent","includes","_consentManagement$fi","cmpConsents","find","c","provider","configuredConsents","map","trim","filter","n","resolutionStrategy","some","length","every","p","purpose","onError"],"mappings":"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"}