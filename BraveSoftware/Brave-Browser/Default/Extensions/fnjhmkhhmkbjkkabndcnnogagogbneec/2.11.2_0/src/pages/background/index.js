var Ha=Object.defineProperty;var Ja=(a,n,t)=>n in a?Ha(a,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[n]=t;var Ia=(a,n,t)=>Ja(a,typeof n!="symbol"?n+"":n,t);import{G as Z,L as h,b as k,C as $a,M as E}from"../../../assets/js/enum.CGJbW6Yf.js";import{b1 as Qa,b2 as Ya,av as O,b3 as Xa,b4 as Za,b5 as z,B as _,b6 as ka,b7 as b,b8 as w,b9 as Y,ba as za,bb as I,bc as Ra,E as T,bd as xa,be as G,at as aa,au as ta,bf as qa,bg as at,bh as ba,w as U,J as tt,bi as Na,bj as nt,bk as it,a3 as W,ay as N,bl as J,bm as ct,aA as na,az as p,N as Va,a as M,ax as st,ab as et,a9 as rt,bn as ot,W as dt,bo as Ta,s as lt,l as R,k as A,bp as gt,bq as ht,br as ut,bs as ft,b as K,T as x,e as q,f as B,bt as St,bu as Et,bv as _a,bw as wt,bx as Ct,by as mt,bz as Pt,an as yt,bA as Ot,g as pa,F as va,o as Da}from"../../../assets/js/windowUtils.Ut7JS-rc.js";import{a as La,c as At,h as $,g as It,b as Ga,d as Ka,e as X}from"../../../assets/js/solana.CGFphaJI.js";import{b as j,a as Ua,c as bt}from"../../../assets/js/openApp._aQ9ORSc.js";import{f as Nt,a as Tt}from"../../../assets/js/index.qcz-Rm7u.js";import{t as Ma}from"../../../assets/js/useDebouncedEffect.CslCnlPq.js";import{i as V}from"../../../assets/js/index.umd.Dte_l0di.js";import"../../../assets/js/tiny-invariant.BHpmfUqq.js";import"../../../assets/js/index.CxJLds0B.js";import"../../../assets/js/preload-helper.2LWRYvkK.js";const _t=new Qa;class pt extends Ya{async getAllAddresses(){return await O.getAllAccounts({ignoreViewOnly:!0,currentAccountFirst:!0})}async getCurrentAddress(){var t,i,e,d;const n=await O.get();return{address:Xa.getAdapter((t=n==null?void 0:n.currentAccount)==null?void 0:t.blockchain).normalizeAddress(((e=(i=n==null?void 0:n.currentAccount)==null?void 0:i.address)==null?void 0:e.toLowerCase())??""),blockchain:(d=n==null?void 0:n.currentAccount)==null?void 0:d.blockchain}}}class vt extends Za{waitForApproval(){return new Promise((n,t)=>{const i=async()=>{this.removeListener(Z.POPUP_CLOSED,i),y.rejectCurrent(),t("User cancelled")};this.addListener(Z.POPUP_CLOSED,i);const e=async d=>{if(y.removeListener(z.ACTION_UPDATED,e),d.payload.status===b.APPROVED){const{currentAccount:r}=await O.get();n(r==null?void 0:r.address)}else t("User rejected")};y.on(z.ACTION_UPDATED,e)})}async waitForUnlock(n,t){const i=y.addAction({type:ka.ENABLE,metadata:n,blockchain:_.EVM,shouldClose:t});return(await y.watch(i)).status===b.APPROVED}}const Dt=50;class Lt{constructor(){Ia(this,"state",{actions:[],currentAction:null})}addAction(n){this.state.actions.length>=Dt&&this.state.actions.splice(0,10),this.state.actions.push(n),this.state.currentAction=this.state.actions[0],this.update()}approveCurrent(n=!1){this.state.currentAction&&(this.state.currentAction.status=b.APPROVED,n||(this.state.currentAction=this.state.actions.length>1?this.state.actions[1]:null,this.state.actions.shift()),this.update())}getCurrentAction(){return this.state.currentAction}rejectCurrent(){this.state.currentAction&&(this.state.currentAction.status=b.REJECTED,this.state.currentAction=this.state.actions.length>1?this.state.actions[1]:null,this.state.actions.shift(),this.update())}reset(){this.state={actions:[],currentAction:null},this.update()}update(){return Ut(this.state.actions.length>0?this.state.actions.length.toString():""),La.set(this.state)}async refetch(){const n=await La.get();n&&(this.state=n)}insertAction(n){}}const Ut=async a=>{try{await chrome.action.setBadgeBackgroundColor({color:"#ff0000"}),await chrome.action.setBadgeTextColor({color:"#ffffff"}),await chrome.action.setBadgeText({text:a})}catch(n){h.error("Set Badge",n)}},Mt=async()=>{try{const a=await w.get();if(a.latestStorageVersion===Y){h.debug("Storage is already migrated");return}const n=[O,w,At];await Promise.all(n.map(t=>t.migration(a.latestStorageVersion??0,Y))),await w.setStorageVersion(Y)}catch(a){h.error("Migrate storage error",a)}},L=new Lt,Ft=a=>{},Vt=a=>{},y=new za({store:L}),Wa={};Wa[I.ronin_requestPage]=["wallet.roninchain.com"];const Ba=["dev.ronin-wallet-website.axieinfinity.services","wallet.roninchain.com"],H=new Ra({actionQueue:y,supportedChainIds:xa.map(a=>qa(a)),defaultChainId:{chainId:T.RONIN,blockchain:_.EVM},callbacks:{onDefaultChainIdChanged:Ft,onSupportedChainIdsChanged:Vt},whitelistRpcMethod:Wa,whitelistDomains:Ba,engineProvider:new pt({providerManager:ta,signerManager:aa,sessionsManager:G,actionQueue:y})});at(H);const ia=new vt;O.getAllAccounts({currentAccountFirst:!0,ignoreViewOnly:!0}).then(async a=>{const t=(await w.getSupportedChains()).map(i=>({chainId:i.chainConfig.chainId,blockchain:i.chainConfig.blockchain}));await ba.init({whitelistDomains:Ba,chainIds:[{chainId:T.RONIN,blockchain:_.EVM},...t.filter(i=>i.chainId!==T.RONIN)],addresses:a})}).catch(()=>ba.init());U.enableIfNeeded();Mt();async function Gt(){const n=(await Ma.get()).lastFetchConfigs??0,t=await w.get(),i=await Na.get(),[e,d]=await Promise.all([Nt(!n||!i.common),Tt(!n||!t.chainConfigs)]);await Na.set(r=>{const s={...r};return e&&(s.common=e),s}),await w.set(r=>{var c;const s={...r};if(d){const o={};(c=s==null?void 0:s.chainConfigs)==null||c.forEach(u=>{o[u.configId]=u}),d.forEach(u=>{o[u.configId]={chainConfig:u.chainConfig,configId:u.configId}}),s.chainConfigs=[...nt(Object.values(o))]}return s}),await it(),await Ma.setLastFetchConfigs()}const Kt=async()=>{j.isSidePanel=await tt(),h.debug("CheckConfig: isSidePanel",j.isSidePanel)},Wt=async()=>{const a=await W.get();if(a!=null&&a.passcode)try{await U.unlock(a.passcode)}catch(n){h.error("EnableWalletModule",n)}};Kt();Gt();Wt();const F=async a=>{await st.set(a.localTxId,a)},Bt=async(a,n,t,i,e=!1)=>{var s,c;if(!a)return;const d=(n==null?void 0:n.toLowerCase())===((s=a==null?void 0:a.from)==null?void 0:s.toLowerCase()),r=[{type:na.SEND,to:n,from:a==null?void 0:a.from,value:i||"1",token:{name:t==null?void 0:t.name,symbol:t==null?void 0:t.symbol,address:t==null?void 0:t.address,standard:t==null?void 0:t.standard}}];await F({timestamp:$().valueOf(),txHash:a==null?void 0:a.hash,from:a==null?void 0:a.from,to:a==null?void 0:a.to,value:i||"1",gasUsed:(c=a==null?void 0:a.gasLimit)==null?void 0:c.toString(),gasPrice:`${a==null?void 0:a.gasPrice}`,chainId:t==null?void 0:t.chainId,localTxId:(a==null?void 0:a.hash)||J(),nonce:a==null?void 0:a.nonce,status:e?N.DROPPED:N.PENDING,decoded:{type:d?p.SELF:p.SEND,actionName:d?M.activity.status.selfTransfer:M.activity.status.sendNft,contract:{address:t==null?void 0:t.address},activities:r,balanceDiffs:d?[]:r}})},jt=async(a,n,t,i,e=!1)=>{var s,c,o;if(!a||!t)return;const d=(n==null?void 0:n.toLowerCase())===((s=a==null?void 0:a.from)==null?void 0:s.toLowerCase()),r=[{value:i,type:na.SEND,from:a==null?void 0:a.from,to:n,token:{name:t==null?void 0:t.name,symbol:t==null?void 0:t.symbol,address:t==null?void 0:t.address,decimals:t==null?void 0:t.decimal,standard:(t==null?void 0:t.standard)||Va.ERC20,logo:t==null?void 0:t.logoUrl}}];await F({timestamp:$().valueOf(),txHash:a==null?void 0:a.hash,from:a==null?void 0:a.from,to:a==null?void 0:a.to,value:i,gasUsed:(c=a==null?void 0:a.gasLimit)==null?void 0:c.toString(),gasPrice:(o=a==null?void 0:a.gasPrice)==null?void 0:o.toString(),chainId:Number(a==null?void 0:a.chainId),localTxId:(a==null?void 0:a.hash)||J(),nonce:a==null?void 0:a.nonce,status:e?N.DROPPED:N.PENDING,decoded:{type:d?p.SELF:p.SEND,actionName:d?M.activity.status.selfTransfer:M.activity.status.sendToken,contract:{address:t==null?void 0:t.address},activities:r,balanceDiffs:d?[]:r}})},Ht=async(a,n,t,i)=>{var d,r,s,c,o;const e={txHash:t,from:(d=n==null?void 0:n.from)==null?void 0:d.toString(),to:(r=n==null?void 0:n.to)==null?void 0:r.toString(),decoded:a,chainId:Number(n==null?void 0:n.chainId),localTxId:t||J(),gasPrice:(s=n==null?void 0:n.gasPrice)==null?void 0:s.toString(),gasUsed:(c=n==null?void 0:n.gasLimit)==null?void 0:c.toString(),value:(o=n==null?void 0:n.value)==null?void 0:o.toString(),timestamp:$().valueOf(),nonce:n==null?void 0:n.nonce,status:i?N.DROPPED:N.PENDING};await F(e)},Jt=async(a,n,t,i)=>{const e=await It({txHash:t,tx:n,chainId:ct.MAINNET,isError:i,decodedData:a});await F(e)},$t=async a=>{const{tx:n,token:t,rawAmount:i,recipient:e,chainId:d,txHash:r}=a,s=Ga(n),c=[{value:i,type:na.SEND,from:s,to:e,token:{name:t==null?void 0:t.name,symbol:t==null?void 0:t.symbol,address:t==null?void 0:t.address,decimals:t==null?void 0:t.decimal,standard:t==null?void 0:t.standard,logo:t==null?void 0:t.logoUrl}}],o={timestamp:$().valueOf(),txHash:r,localTxId:r||J(),from:s,to:e,value:i,chainId:d,status:N.PENDING,decoded:{type:p.SEND,actionName:`Send ${t==null?void 0:t.symbol}`,contract:{address:t==null?void 0:t.address},activities:c,balanceDiffs:c},gasUsed:"0",gasPrice:"0",nonce:void 0};await F(o)},Qt=async a=>{const{chainId:n,from:t}=a;if(!n||!t)throw new Error(`Invalid chainId (${n}) or from address (${t})`);const i=ta.getProvider(n),e=await aa.getSignerForAddress(t.toString().toLowerCase());if(!e)throw new Error("Signer not found");const d=U.getAccountByAddress(t.toString());if((d==null?void 0:d.type)===dt.MPC){const c=await Ta.get(),o=lt(c.accountStatus,!0);if(!R.isEmpty(o))throw await Ta.setShownWarningStatus("showing"),new Error(o)}R.isEmpty(a.value)&&(a.value=0);const r=e.connect(i),s=await r.populateTransaction(a);return r.sendTransaction(s)},Yt=async(a,n)=>{const t=Ga(n),i=ta.getProvider(a),e=await aa.getSignerForAddress(t);if(!e)throw new Error("Signer not found");return e.connect(i).sendTransaction(n)},Xt=async a=>{const{txRequest:n,token:t,rawAmount:i,receiverAddress:e,blockchain:d,chainId:r}=a,s=et(t==null?void 0:t.standard,Va.ERC20)||rt(t==null?void 0:t.address);try{if(d===_.SOLANA){const c=ot(n),o=await Yt(r,c);return await $t({tx:c,token:t,recipient:e,rawAmount:i,chainId:r,txHash:o}),o}else{const c=await Qt(n);return s?await jt(c,e,t,i):await Bt(c,e,t,i),c.hash}}catch(c){h.error("[sendTx] err:",c);const o=typeof c=="object"?{...c,message:c==null?void 0:c.message,code:c==null?void 0:c.code}:c;throw await Ka(o),o}},Fa=async(a,n)=>{var sa,ea,ra,oa,da,la,ga,ha,ua,fa,Sa,Ea,wa,Ca,ma,Pa,ya;const t=W.hasPassword(),i=Et.includes((sa=a==null?void 0:a.message)==null?void 0:sa.method),d=Object.values(_a).includes((ea=a==null?void 0:a.message)==null?void 0:ea.method)?_.SOLANA:_.EVM;if(i&&!t)return{isWalletEvent:!0,type:V.WalletEventType.JSON_RPC_RESPONSE,data:{...a.message,result:[]}};const r=n.origin||n.url;let s=new URL(r);const c=wt.includes((ra=a==null?void 0:a.message)==null?void 0:ra.method),o=Ct(s.hostname,d);if(((oa=a==null?void 0:a.message)==null?void 0:oa.method)===I.wallet_switchEthereumChain&&o)try{const l=parseInt((la=(da=a==null?void 0:a.message)==null?void 0:da.params)==null?void 0:la[0].chainId,16);if(o.getChainIds()[0]===l)return{isWalletEvent:!0,type:V.WalletEventType.JSON_RPC_RESPONSE,data:{...a.message,result:null}}}catch(l){h.error("SwitchChain",l)}let C=!1;const S=s.hostname===mt();S&&((ga=a.peerMeta)!=null&&ga.url)&&(s=new URL(a.peerMeta.url)),h.debug("Request Sender:",S,n,s.hostname);const v=Pt.includes((ha=a==null?void 0:a.message)==null?void 0:ha.method);if(!S&&(c||v&&(!o||!t))){const l=((ua=a==null?void 0:a.message)==null?void 0:ua.method)!==I.ronin_requestPage,f=v&&H.isWhitelistedDomain(s.hostname)&&t;((fa=n.tab)==null?void 0:fa.id)&&!f&&bt(n.tab.id,l),C=!t&&!!o}const D=await w.get();let g=T.RONIN;D.isSingleChain&&(g=((wa=(Ea=await yt(((Sa=D.activeChainIds)==null?void 0:Sa[0])??T.RONIN))==null?void 0:Ea.chainConfig)==null?void 0:wa.chainId)??T.RONIN),o&&(g=(Ca=o.getChainIds())==null?void 0:Ca[0]);const m={...a.peerMeta,url:S?(ma=a.peerMeta)==null?void 0:ma.url:s.origin};if(C){const l=[I.eth_requestAccounts,I.eth_accounts].includes((Pa=a==null?void 0:a.message)==null?void 0:Pa.method);if(!await ia.waitForUnlock(m,l))return{isWalletEvent:!0,type:V.WalletEventType.JSON_RPC_RESPONSE,data:{...a.message,error:{message:"User rejected the request.",code:4001}}}}const P=await H.handleAdvanced({...a.message,options:{clientMetadata:m,connectMethod:S?void 0:Ot.INJECTED,chainId:g,requestTypes:S?["granted"]:void 0,hooks:{postProcess:async(l,f)=>{var Q,Oa,Aa;if(l.method===I.eth_sendTransaction){const ja=l.decodedData||{type:p.GENERIC,actionName:M.common.contractInteraction,balanceDiffs:[],activities:[],contract:{address:(Oa=(Q=l==null?void 0:l.txRequest)==null?void 0:Q.to)==null?void 0:Oa.toString()}};await Ht(ja,l==null?void 0:l.txRequest,f==null?void 0:f.result,!!(f!=null&&f.error))}l.method===_a.sol_signAndSendTransaction&&await Jt(l.decodedData,l.txRequest,(Aa=f==null?void 0:f.result)==null?void 0:Aa.signature,!!f.error)}}}});return await Ka(P),I.eth_sendTransaction===((ya=a==null?void 0:a.message)==null?void 0:ya.method)&&K.sendBackgroundEvent(x.Noop,q.SendTx,P!=null&&P.error?B.Failed:B.Successfully,{action_properties:{tx_hash:P.result,source:S?"wallet":s.hostname}}),{isWalletEvent:!0,type:V.WalletEventType.JSON_RPC_RESPONSE,data:P}},Zt=async a=>{var o,u,C,S,v,D;let n,t,i;const e=a.changedKeys.includes("currentAccount"),d=a.changedKeys.includes("wallets");let r,s,c;switch(a.storageKey){case A.ACCOUNT_STORE:if(d&&await H.handleAccountChanged(!0),e){await K.onAccountChanged();const g=await O.get(),m=g==null?void 0:g.currentAccount,P=g==null?void 0:g.wallets[m==null?void 0:m.walletId],ca=St(m==null?void 0:m.address,Object.values(P==null?void 0:P.accounts));await G.handleCurrentAccountChanged(m.address),await G.handleCurrentAccountChanged(ca)}break;case A.PENDING_TX_STORE:if(r=await X.get(),(o=r.pendingSignTx)!=null&&o.payload&&((u=r.pendingSignTx)==null?void 0:u.status)==="pending"&&a.changedKeys.includes("pendingSignTx"))try{const g=await Xt((C=r==null?void 0:r.pendingSignTx)==null?void 0:C.payload);await X.setPendingSignTx({...r.pendingSignTx,status:"success",txHash:g}),K.sendBackgroundEvent(x.Noop,q.SendTx,B.Successfully,{action_properties:{tx_hash:g,source:"wallet"}})}catch(g){await X.setPendingSignTx({...r.pendingSignTx,status:"error",error:g}),K.sendBackgroundEvent(x.Noop,q.SendTx,B.Failed,{action_properties:{source:"wallet"}})}break;case A.SESSION_STORE:await G.init();break;case A.WALLET_STORE:await W.updateLastChanged(),n=await ft.getValues(),n.length===0&&await U.lock(!1);break;case A.UNLOCK_STORE:if(t=await W.get(),t.passcode)try{h.debug("Unlock background"),await U.unlock(t.passcode)}catch(g){h.error("UnlockB",g)}break;case A.ACTION_QUEUE_STORE:if(await L.refetch(),i=L==null?void 0:L.getCurrentAction(),!i||(i==null?void 0:i.status)===b.PENDING)return;if((i==null?void 0:i.status)==b.APPROVED){y.approveCurrent((S=i.payload)!=null&&S.result?{result:(v=i.payload)==null?void 0:v.result}:void 0);return}(i==null?void 0:i.status)===b.REJECTED&&y.rejectCurrent();break;case A.CONFIG_STORE:a.changedKeys.includes("isOverwriteEthereum")&&xt(),(a.changedKeys.includes("chainConfigs")||a.changedKeys.includes("activeChainIds"))&&(s=await w.get(),c=await gt.get(),ht(s.chainConfigs,(D=s.activeChainIds)==null?void 0:D[0],ut(s==null?void 0:s.isSingleChain,c==null?void 0:c.enableCustomRPC)));break}};k.runtime.onConnect.addListener(async a=>{var n;if(((n=a.sender)==null?void 0:n.id)!==k.runtime.id){h.error("onConnect: Unknown sender id");return}switch(a.name){case $a.POPUP:Ua.setIsOpening(!0),a.onDisconnect.addListener(t=>{ia.emit(Z.POPUP_CLOSED,t.sender),Ua.setIsOpening(!1)});break}});y.on(z.ACTION_ADDED,async()=>{try{await ia.waitForApproval()}catch(a){h.error("Wait For Unlock:",a)}});chrome.storage.onChanged.addListener(async a=>{var n,t;for(const i in a){const e=[],d=Object.entries(((n=a==null?void 0:a[i])==null?void 0:n.oldValue)??{}),r=Object.entries(((t=a==null?void 0:a[i])==null?void 0:t.newValue)??{});d.forEach(c=>{const o=c[0],u=c[1],C=r.find(S=>S[0]===o);C&&!R.isEqual(C[1],u)&&e.push(o)}),r.forEach(c=>{const o=c[0];d.find(C=>C[0]===o)||e.push(o)});const s={type:E.STORAGE_CHANGE,storageKey:i,changedKeys:e};await Zt(s)}});_t.subscribe([E.SIDE_PANEL_CONFIG_CHANGED,E.ASK_PROVIDER_FROM_CONTENT_SCRIPT,E.ASK_PROVIDER_FROM_POPUP,E.KEEP_ALIVE_FROM_POPUP,E.KEEP_ALIVE_FROM_CONTENT_SCRIPT],async(a,n)=>{var t;switch(a.type){case E.SIDE_PANEL_CONFIG_CHANGED:return j.isSidePanel=((t=await chrome.sidePanel.getPanelBehavior())==null?void 0:t.openPanelOnActionClick)??!1,Promise.resolve(void 0);case E.ASK_PROVIDER_FROM_CONTENT_SCRIPT:return Fa(a,n);case E.ASK_PROVIDER_FROM_POPUP:return Fa(a,n);case E.KEEP_ALIVE_FROM_POPUP:return Promise.resolve(void 0);case E.KEEP_ALIVE_FROM_CONTENT_SCRIPT:return Promise.resolve(void 0)}});const kt=async()=>{var a;try{const n=k.storage.local,t=(await O.get()).isMigrated;!(await n.get("selectedAccount")).selectedAccount&&!t&&((a=chrome.sidePanel)==null||a.setPanelBehavior({openPanelOnActionClick:!0}).catch(e=>console.error(e)).finally(()=>{j.isSidePanel=!0}))}catch(n){h.error("checkSidePanelSetting",n)}},zt=async()=>{try{if(await w.needShowConsent()){const i=pa(va.TRACKING_CONSENT);await Da(i);return}const n=await O.get();if(n!=null&&n.currentAccount)return;const t=pa(va.WELCOME,"menu");await Da(t)}catch(a){h.error("checkConsent",a)}};chrome.runtime.onInstalled.addListener(async()=>{await kt(),await zt()});const Rt=async()=>{const{isOverwriteEthereum:a}=await w.get();try{await chrome.scripting.registerContentScripts([{id:"inpage",matches:["file://*/*","http://*/*","https://*/*"],js:[a?"in-page-ethereum.js":"in-page.js"],runAt:"document_start",world:"MAIN",allFrames:!0}])}catch(n){h.info(`Failed to register in-page content script. ${n}`)}},xt=async()=>{try{const{isOverwriteEthereum:a}=await w.get();await chrome.scripting.updateContentScripts([{id:"inpage",js:[a?"in-page-ethereum.js":"in-page.js"]}])}catch(a){h.error("updateInPageContentScripts",a)}};Rt();
