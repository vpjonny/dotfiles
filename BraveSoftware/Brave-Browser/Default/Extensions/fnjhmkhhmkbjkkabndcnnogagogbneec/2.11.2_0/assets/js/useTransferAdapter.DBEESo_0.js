var O=Object.defineProperty;var V=(m,c,e)=>c in m?O(m,c,{enumerable:!0,configurable:!0,writable:!0,value:e}):m[c]=e;var w=(m,c,e)=>V(m,typeof c!="symbol"?c+"":c,e);import{r as $}from"./index.CxJLds0B.js";import{B as F,N as g,aF as K,aG as h,aH as S,aI as E,aJ as q,aK as U,aL as H,am as b,aM as J,aN as P,a5 as j,au as k,aO as v}from"./windowUtils.Ut7JS-rc.js";import{L as u}from"./enum.CGJbW6Yf.js";import{S as I}from"./token.types.DkObBlUj.js";import{T as N,a as B,g as A,b as R,c as z,d as Q}from"./associatedTokenAccount.Cs_dSOLN.js";import{ac as M,ad as L,ae as C}from"./PopupLoading.D-LitESe.js";class G{constructor(c){w(this,"blockchain");this.blockchain=c}getBlockchain(){return this.blockchain}}const W=5e3;class x extends G{constructor(e){super(F.SOLANA);w(this,"connection");this.connection=e}isNativeToken(e){return e.standard===g.NATIVE||e.address===K}isNftToken(e){return e.standard===I.SPL_NFT||e.standard===g.ERC721||e.standard===g.ERC1155}isSplToken(e){return e.standard===I.SPL||e.standard===I.SPL_NFT||!this.isNativeToken(e)&&!!e.address}async getTokenProgramId(e){try{const t=await this.connection.getAccountInfo(e);return t?t.owner.equals(B)?B:N:N}catch(t){return u.error("[SolanaTransferAdapter] Failed to detect token program",t),N}}async getTokenBalance(e,t){try{const r=new h(t);if(this.isNativeToken(e))return(await this.connection.getBalance(r)).toString();if(this.isNftToken(e))return this.getNftBalance(e.address,t);{const a=new h(e.address),n=await this.getTokenProgramId(a),o=await A(a,r,!1,n);try{return(await this.connection.getTokenAccountBalance(o)).value.amount}catch(s){throw u.debug("[SolanaTransferAdapter] ATA does not exist for token:",e.address),s}}}catch(r){throw u.error("[SolanaTransferAdapter] Failed to get balance:",r),r}}async estimateFee(e){try{const{from:t,to:r,token:a,amount:n,extraInstructions:o=0}=e,s=await this.buildTransferTx({from:t,to:r,token:a,amount:n,chainId:e.chainId}),i=(await this.connection.getFeeForMessage(s.compileMessage())).value||5e3;let d=i,l;return!this.isNativeToken(a)&&o>0&&(l=await this.connection.getMinimumBalanceForRentExemption(165),d+=l),{estimatedFee:d.toString(),feeSymbol:"SOL",baseTransactionFee:i.toString(),ataCreationFee:l==null?void 0:l.toString()}}catch(t){throw u.error("[SolanaTransferAdapter] Failed to estimate fee:",t),t}}validateRecipient(e){try{return new h(e),!0}catch{return!1}}formatAddress(e,t={}){const{short:r=!0,chars:a=4}=t;return r?`${e.slice(0,a)}...${e.slice(-a)}`:e}async calculateMaxAmount(e){const{token:t,balance:r,feeEstimate:a}=e;try{const n=new S(r);if(n.lte(0))return null;if(this.isNativeToken(t)){const o=new S((a==null?void 0:a.estimatedFee)??W);return n.lte(o)?null:{rawAmount:n.minus(o).toFixed(0),estimatedFee:o.toFixed(0),feeDetails:a}}return{rawAmount:n.toFixed(0),estimatedFee:a==null?void 0:a.estimatedFee,feeDetails:a}}catch(n){return u.error("[SolanaTransferAdapter] Failed to calculate max amount:",n),null}}async buildTransferTx(e){const{from:t,to:r,token:a,amount:n}=e,o=new h(t),s=new h(r),f=new S(n);return this.isNativeToken(a)?this.buildSolTransfer(o,s,f):this.isNftToken(a)||this.isSplToken(a)?this.buildSplTransfer(o,s,a,f):this.buildSplTransfer(o,s,a,f)}async buildSolTransfer(e,t,r){const a=new E().add(q.transfer({fromPubkey:e,toPubkey:t,lamports:r.toNumber()})),{blockhash:n}=await this.connection.getLatestBlockhash();return a.recentBlockhash=n,a.feePayer=e,a}async buildSplTransfer(e,t,r,a){const n=new h((r==null?void 0:r.mintAddress)??r.address),o=await this.getTokenProgramId(n),s=await A(n,e,!1,o),f=await A(n,t,!1,o);if(!await this.connection.getAccountInfo(s))throw new Error(`Source token account does not exist for mint ${r.address}.`);const d=await R(this.connection,n,void 0,o),l=new E;await this.connection.getAccountInfo(f)||l.add(z(e,f,t,n,o));const p=this.isNftToken(r)?1:a.toNumber();l.add(Q(s,n,f,e,p,d.decimals,[],o));const{blockhash:y}=await this.connection.getLatestBlockhash();return l.recentBlockhash=y,l.feePayer=e,l}formatLamports(e){return e.div(U).toFixed(9)}async checkAtaExists(e,t){try{const r=new h(e),a=new h(t),n=await this.getTokenProgramId(r),o=await A(r,a,!1,n),s=await this.connection.getAccountInfo(o);return{exists:!!s,address:o.toString(),needsCreation:!s}}catch(r){throw u.error("[SolanaTransferAdapter] Failed to check ATA:",r),r}}async verifyNftMint(e){try{const t=new h(e),r=await this.getTokenProgramId(t),a=await R(this.connection,t,void 0,r);return{isNft:a.decimals===0&&a.supply===1n,decimals:a.decimals,supply:a.supply.toString()}}catch(t){throw u.error("[SolanaTransferAdapter] Failed to verify NFT mint:",t),t}}async getNftBalance(e,t){try{const r=new h(t),a=new h(e),n=await this.getTokenProgramId(a),o=await A(a,r,!1,n);try{return(await this.connection.getTokenAccountBalance(o)).value.amount}catch(s){throw u.debug("[SolanaTransferAdapter] NFT ATA does not exist:",e),s}}catch(r){throw u.error("[SolanaTransferAdapter] Failed to get NFT balance:",r),r}}async getMinimumBalanceForRentExemption(e=0){return this.connection.getMinimumBalanceForRentExemption(e)}}class X extends G{constructor(e){super(F.EVM);w(this,"provider");this.provider=e}isNativeToken(e){return e.standard===g.NATIVE||H(e==null?void 0:e.address)}isNftToken(e){return e.standard===g.ERC721||e.standard===g.ERC1155}async getTokenBalance(e,t){try{if(this.isNftToken(e)){const n=e.id;if(!n)throw new Error("tokenId is required for NFT balance check");if(e.standard===g.ERC721){const o=new b(e.address,M,this.provider);try{return(await o.ownerOf(n)).toLowerCase()===t.toLowerCase()?"1":"0"}catch(s){throw u.error("[EVMTransferAdapter] Failed to get NFT balance:",s),s}}else if(e.standard===g.ERC1155)return(await new b(e.address,L,this.provider).balanceOf(t,n)).toString()}return this.isNativeToken(e)?(await this.provider.getBalance(t)).toString():(await new b(e.address,C,this.provider).balanceOf(t)).toString()}catch(r){throw u.error("[EVMTransferAdapter] Failed to get balance:",r),r}}async estimateFee(e){var t,r,a;try{const{from:n,to:o,token:s,amount:f,feeData:i,tokenId:d}=e,l=d||s.id,T=await this.buildTransferTx({from:n,to:o,token:s,amount:f,tokenId:l,chainId:e.chainId});if(!(i!=null&&i.maxFeePerGas)&&!(i!=null&&i.maxPriorityFeePerGas)&&!(i!=null&&i.gasPrice))throw new Error("No gas price or fee data found!");let p=await this.provider.estimateGas(T);const y=BigInt(parseInt(`${Number(p)*J}`));p+=y;const _=(i==null?void 0:i.maxFeePerGas)||(i==null?void 0:i.gasPrice);return{estimatedFee:(p*BigInt(_)).toString(),gasLimit:p.toString(),gasPrice:(t=i==null?void 0:i.gasPrice)==null?void 0:t.toString(),maxFeePerGas:(r=i==null?void 0:i.maxFeePerGas)==null?void 0:r.toString(),maxPriorityFeePerGas:(a=i==null?void 0:i.maxPriorityFeePerGas)==null?void 0:a.toString()}}catch(n){throw u.error("[EVMTransferAdapter] Failed to estimate fee:",n),n}}async calculateMaxAmount(e){const{token:t,balance:r,feeEstimate:a}=e;try{const n=BigInt(r);if(!this.isNativeToken(t))return{rawAmount:r,estimatedFee:"0",feeDetails:{estimatedFee:"0",feeSymbol:t.symbol}};const o=BigInt(a.estimatedFee||"0"),s=n-o;return s<0n?null:{rawAmount:s.toString(),estimatedFee:a.estimatedFee,feeDetails:a}}catch(n){return u.error("[EVMTransferAdapter] Failed to calculate max amount:",n),null}}async buildTransferTx(e){const{from:t,to:r,token:a,amount:n,tokenId:o,customFee:s,customNonce:f,chainId:i}=e;try{let d;if(a.standard===g.ERC721){if(!o)throw new Error("tokenId is required for ERC721 transfers");const T=new P(M).encodeFunctionData("safeTransferFrom",[t,r,o]);d={from:t,to:a.address,data:T,value:"0",chainId:i}}else if(a.standard===g.ERC1155){if(!o)throw new Error("tokenId is required for ERC1155 transfers");const T=new P(L).encodeFunctionData("safeTransferFrom",[t,r,o,n,"0x"]);d={from:t,to:a.address,data:T,value:"0",chainId:i}}else if(this.isNativeToken(a))d={from:t,to:r,value:n,chainId:i};else{const T=new P(C).encodeFunctionData("transfer",[r,n]);d={from:t,to:a.address,data:T,value:"0",chainId:i}}return s&&(s.gasLimit&&(d.gasLimit=s.gasLimit.toString()),s.maxFeePerGas&&s.maxPriorityFeePerGas?(d.maxFeePerGas=s.maxFeePerGas.toString(),d.maxPriorityFeePerGas=s.maxPriorityFeePerGas.toString()):s.gasPrice&&(d.gasPrice=s.gasPrice.toString())),f!==void 0&&(d.nonce=f),d}catch(d){throw u.error("[EVMTransferAdapter] Failed to build transfer tx:",d),d}}validateRecipient(e){try{return j(e)}catch{return!1}}}class Y{constructor(){w(this,"adapters");this.adapters=new Map}getAdapter(c,e){if(!c||!e)return null;const t=`${c}_${e}`;if(this.adapters.has(t))return this.adapters.get(t);let r=null;switch(c){case F.SOLANA:r=this.createSolanaAdapter(e);break;case F.EVM:r=this.createEVMAdapter(e);break;default:return u.error(`[TransferAdapterFactory] Unsupported blockchain: ${c}`),null}return r&&this.adapters.set(t,r),r}createSolanaAdapter(c){try{const e=k.getProvider(c);return e?new x(e):(u.warning("[TransferAdapterFactory] No Solana connection found, creating default"),new x(new v("https://api.mainnet-beta.solana.com")))}catch(e){return u.error("[TransferAdapterFactory] Failed to create Solana adapter:",e),new x(new v("https://api.mainnet-beta.solana.com"))}}createEVMAdapter(c){try{const e=k.getProvider(c);return e?new X(e):(u.error("[TransferAdapterFactory] No EVM provider found for chainId:",c),null)}catch(e){return u.error("[TransferAdapterFactory] Failed to create EVM adapter:",e),null}}clearCache(){this.adapters.clear()}clearAdapter(c,e){const t=`${c}_${e}`;this.adapters.delete(t)}}const Z=new Y,ie=(m,c)=>$.useMemo(()=>Z.getAdapter(m,c),[m,c]);export{Z as a,ie as u};
